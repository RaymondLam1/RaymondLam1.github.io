<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.19" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.70" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme="dark"] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <title>Java 持久化</title><meta name="description" content="Raymondlam1 的博客演示">
    <link rel="preload" href="/assets/style-BdUcpB_j.css" as="style"><link rel="stylesheet" href="/assets/style-BdUcpB_j.css">
    <link rel="modulepreload" href="/assets/app-B5Vu5nrn.js"><link rel="modulepreload" href="/assets/high-performance_java_persistence.html-Dpd8lUWD.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-DlAUqK2U.js">
    <link rel="prefetch" href="/assets/index.html-BBMOdiNT.js" as="script"><link rel="prefetch" href="/assets/intro.html-B5wusbx_.js" as="script"><link rel="prefetch" href="/assets/index.html-CKvIIRKm.js" as="script"><link rel="prefetch" href="/assets/work.html-BTWbVYBl.js" as="script"><link rel="prefetch" href="/assets/FineBI.html-BULdmcXz.js" as="script"><link rel="prefetch" href="/assets/Tableau.html-DcQmAk_m.js" as="script"><link rel="prefetch" href="/assets/antlr4.html-CjM97WrB.js" as="script"><link rel="prefetch" href="/assets/gradle_jvm配置.html-OQR65pAb.js" as="script"><link rel="prefetch" href="/assets/jsy.html-lJjYYSI2.js" as="script"><link rel="prefetch" href="/assets/vscode_pic_location.html-D3VUiFdM.js" as="script"><link rel="prefetch" href="/assets/为什么我不推荐读硕士.html-CKc-GINE.js" as="script"><link rel="prefetch" href="/assets/九寨沟之旅.html-9-lr9r9S.js" as="script"><link rel="prefetch" href="/assets/婆罗门.html-VcNcnQ1Q.js" as="script"><link rel="prefetch" href="/assets/很多人不适合开车.html-cg2lB73Z.js" as="script"><link rel="prefetch" href="/assets/2025-11-03.html-ChxaJeeb.js" as="script"><link rel="prefetch" href="/assets/index.html-BFCaS7zn.js" as="script"><link rel="prefetch" href="/assets/index.html-D8kNwD42.js" as="script"><link rel="prefetch" href="/assets/finalize.html-DHUG8nEY.js" as="script"><link rel="prefetch" href="/assets/泛型.html-C6xOpCrx.js" as="script"><link rel="prefetch" href="/assets/index.html-B4Sz6AOt.js" as="script"><link rel="prefetch" href="/assets/The-Go-Programming-Language.html-C6JGZezm.js" as="script"><link rel="prefetch" href="/assets/index.html-Bn1mj15U.js" as="script"><link rel="prefetch" href="/assets/ch00.html-DI0e22CD.js" as="script"><link rel="prefetch" href="/assets/ch01.html-BrYUixZG.js" as="script"><link rel="prefetch" href="/assets/ch02.html-E-Igw9Gs.js" as="script"><link rel="prefetch" href="/assets/ch03_searching_files.html-BN9pJJIz.js" as="script"><link rel="prefetch" href="/assets/ch04_vim_grammar.html-DTTbz68B.js" as="script"><link rel="prefetch" href="/assets/2025-01-04.html-Ui-uUsSD.js" as="script"><link rel="prefetch" href="/assets/2025-01-11.html-L6iY38v1.js" as="script"><link rel="prefetch" href="/assets/2025-01-18.html-DYOiXxcZ.js" as="script"><link rel="prefetch" href="/assets/2025-02-01.html-CalnNsIg.js" as="script"><link rel="prefetch" href="/assets/2025-02-08.html-D_Ev7NRM.js" as="script"><link rel="prefetch" href="/assets/2025-02-15.html-Zg4EHI4C.js" as="script"><link rel="prefetch" href="/assets/2025-03-01.html-Ctx_XXN2.js" as="script"><link rel="prefetch" href="/assets/2025-03-15.html-BgADHzZC.js" as="script"><link rel="prefetch" href="/assets/2025-03-22.html-CC3GoQGb.js" as="script"><link rel="prefetch" href="/assets/2025-03-29.html-CvcleXkL.js" as="script"><link rel="prefetch" href="/assets/2025-04-14.html-D9PRjpqs.js" as="script"><link rel="prefetch" href="/assets/2025-04-21.html-BJ-H14-E.js" as="script"><link rel="prefetch" href="/assets/2025-04-26.html-Bw5pOOpg.js" as="script"><link rel="prefetch" href="/assets/2025-05-12.html-mWCpOK8x.js" as="script"><link rel="prefetch" href="/assets/2025-06-03.html-HuAmEK_q.js" as="script"><link rel="prefetch" href="/assets/2025-06-09.html-DXgmee-P.js" as="script"><link rel="prefetch" href="/assets/2025-06-24.html-DRnruIby.js" as="script"><link rel="prefetch" href="/assets/2025-10-27.html-QH_-Jjhk.js" as="script"><link rel="prefetch" href="/assets/current.html-PB0l0RjE.js" as="script"><link rel="prefetch" href="/assets/大模型.html-B_4uKcHf.js" as="script"><link rel="prefetch" href="/assets/404.html-DNkvD0D_.js" as="script"><link rel="prefetch" href="/assets/index.html-7F5TisIx.js" as="script"><link rel="prefetch" href="/assets/index.html-CzB9DzO_.js" as="script"><link rel="prefetch" href="/assets/index.html-D7dLNObx.js" as="script"><link rel="prefetch" href="/assets/index.html-ccFKnm7b.js" as="script"><link rel="prefetch" href="/assets/index.html-Bqqo3Gx1.js" as="script"><link rel="prefetch" href="/assets/index.html-C1VUbZP8.js" as="script"><link rel="prefetch" href="/assets/index.html-C0aAmI4O.js" as="script"><link rel="prefetch" href="/assets/index.html-BdvEcLam.js" as="script"><link rel="prefetch" href="/assets/index.html-DAXQd7Uw.js" as="script"><link rel="prefetch" href="/assets/index.html-wSQ6hb8V.js" as="script"><link rel="prefetch" href="/assets/index.html-BCGC8c9S.js" as="script"><link rel="prefetch" href="/assets/index.html-BCXE2CXF.js" as="script"><link rel="prefetch" href="/assets/index.html-B-F84wf-.js" as="script"><link rel="prefetch" href="/assets/index.html-DMMqR597.js" as="script"><link rel="prefetch" href="/assets/index.html-BpSTSbD4.js" as="script"><link rel="prefetch" href="/assets/index.html-CiaR1tkB.js" as="script"><link rel="prefetch" href="/assets/index.html-DlZ_NXod.js" as="script"><link rel="prefetch" href="/assets/index.html-C5v1HNx1.js" as="script"><link rel="prefetch" href="/assets/index.html-BAGB2GYY.js" as="script"><link rel="prefetch" href="/assets/index.html-C3s2tWlt.js" as="script"><link rel="prefetch" href="/assets/index.html-Da_lbZAL.js" as="script"><link rel="prefetch" href="/assets/index.html-CFXn8H8m.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-CMg0yb1C.js" as="script"><link rel="prefetch" href="/assets/giscus-B3IT9xos.js" as="script"><link rel="prefetch" href="/assets/index-ZTuUv0iQ.js" as="script"><link rel="prefetch" href="/assets/setupDevtools-7MC2TMWH-BlaAR4_x.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container external-link-icon has-toc" vp-container><!--[--><header id="navbar" class="vp-navbar" vp-navbar><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><a class="route-link vp-brand" href="/" aria-label="带我回家"><img class="vp-nav-logo" src="/assets/images/WechatIMG8.jpg" alt><!----><!----></a><!--]--></div><div class="vp-navbar-center"><!--[--><nav class="vp-nav-links"><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/" aria-label="主页" iconsizing="height"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:house" height="1em" sizing="height"></iconify-icon><!--]-->主页<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/blog/" aria-label="技术" iconsizing="height"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:pen-to-square" height="1em" sizing="height"></iconify-icon><!--]-->技术<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link route-link-active auto-link" href="/tech-week/" aria-label="周刊" iconsizing="height"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:blog" height="1em" sizing="height"></iconify-icon><!--]-->周刊<!----></a></div></nav><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!----><div class="vp-nav-item hide-in-mobile"><button type="button" class="vp-color-mode-switch" id="color-mode-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" name="auto" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" name="dark" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" name="light" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!--[--><div id="docsearch-container" style="display:none;"></div><div><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"><svg width="15" height="15" class="DocSearch-Control-Key-Icon"><path d="M4.505 4.496h2M5.505 5.496v5M8.216 4.496l.055 5.993M10 7.5c.333.333.5.667.5 1v2M12.326 4.5v5.996M8.384 4.496c1.674 0 2.116 0 2.116 1.5s-.442 1.5-2.116 1.5M3.205 9.303c-.09.448-.277 1.21-1.241 1.203C1 10.5.5 9.513.5 8V7c0-1.57.5-2.5 1.464-2.494.964.006 1.134.598 1.24 1.342M12.553 10.5h1.953" stroke-width="1.2" stroke="currentColor" fill="none" stroke-linecap="square"></path></svg></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar" vp-sidebar><!----><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><p class="vp-sidebar-header active"><iconify-icon class="vp-icon" icon="fa6-solid:laptop-code" height="1em" sizing="height"></iconify-icon><span class="vp-sidebar-title">周刊</span><!----></p><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><!----><span class="vp-sidebar-title">2025</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/tech-week/2025/2025-10-27.html" aria-label="2025 Tech Time" iconsizing="both"><!---->2025 Tech Time<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/tech-week/2025/2025-01-04.html" aria-label="2025-01-04 Tech Time" iconsizing="both"><!---->2025-01-04 Tech Time<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/tech-week/2025/2025-01-11.html" aria-label="2025-01-11 Tech Time" iconsizing="both"><!---->2025-01-11 Tech Time<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/tech-week/2025/2025-01-18.html" aria-label="2025-01-18 Tech Time" iconsizing="both"><!---->2025-01-18 Tech Time<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/tech-week/2025/2025-02-01.html" aria-label="2025-02-01 Tech Time" iconsizing="both"><!---->2025-02-01 Tech Time<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/tech-week/2025/2025-02-08.html" aria-label="2025-02-08 Tech Time" iconsizing="both"><!---->2025-02-08 Tech Time<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/tech-week/2025/2025-02-15.html" aria-label="2025-02-15 Tech Time" iconsizing="both"><!---->2025-02-15 Tech Time<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/tech-week/2025/2025-03-01.html" aria-label="2025-03-01 Tech Time" iconsizing="both"><!---->2025-03-01 Tech Time<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/tech-week/2025/2025-03-15.html" aria-label="2025-03-15 Tech Time" iconsizing="both"><!---->2025-03-15 Tech Time<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/tech-week/2025/2025-03-22.html" aria-label="2025-03-22 Tech Time" iconsizing="both"><!---->2025-03-22 Tech Time<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/tech-week/2025/2025-03-29.html" aria-label="2025-03-29 Tech Time" iconsizing="both"><!---->2025-03-29 Tech Time<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/tech-week/2025/2025-04-14.html" aria-label="2025-04-14 Tech Time" iconsizing="both"><!---->2025-04-14 Tech Time<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/tech-week/2025/2025-04-21.html" aria-label="2025-04-21 Tech Time" iconsizing="both"><!---->2025-04-21 Tech Time<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/tech-week/2025/2025-04-26.html" aria-label="2025-04-26 Tech Time" iconsizing="both"><!---->2025-04-26 Tech Time<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/tech-week/2025/2025-05-12.html" aria-label="2025-05-12 Tech Time" iconsizing="both"><!---->2025-05-12 Tech Time<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/tech-week/2025/2025-06-03.html" aria-label="2025-06-03 Tech Time" iconsizing="both"><!---->2025-06-03 Tech Time<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/tech-week/2025/2025-06-09.html" aria-label="2025-06-09 Tech Time" iconsizing="both"><!---->2025-06-09 Tech Time<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/tech-week/2025/2025-06-24.html" aria-label="2025-06-24 Tech Time" iconsizing="both"><!---->2025-06-24 Tech Time<!----></a></li><li><a class="route-link route-link-active auto-link vp-sidebar-link active" href="/tech-week/2025/high-performance_java_persistence.html" aria-label="Java 持久化" iconsizing="both"><!---->Java 持久化<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/tech-week/2025/%E5%A4%A7%E6%A8%A1%E5%9E%8B.html" aria-label="大模型" iconsizing="both"><!---->大模型<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/tech-week/2025/current.html" aria-label="当前要做的一些事情" iconsizing="both"><!---->当前要做的一些事情<!----></a></li></ul></section></li><li><a class="route-link auto-link vp-sidebar-link" href="/tech-week/2025-11-03.html" aria-label="2025-10-27 Tech Time" iconsizing="both"><!---->2025-10-27 Tech Time<!----></a></li></ul></section></li></ul><!----></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->Java 持久化</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon" name="author"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://github.com/RaymondLam1" target="_blank" rel="noopener noreferrer">Raymondlam1</a></span><span property="author" content="Raymondlam1"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon" name="calendar"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span data-allow-mismatch="text">2025年11月3日</span><meta property="datePublished" content="2025-11-03T07:20:51.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon" name="timer"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 88 分钟</span><meta property="timeRequired" content="PT88M"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon" name="category"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><!--[--><span class="page-category-item color4 clickable" role="navigation">技术</span><!--]--><meta property="articleSection" content="技术"></span><span class="page-tag-info" aria-label="标签🏷" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="tag icon" name="tag"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><!--[--><span class="page-tag-item color6 clickable" role="navigation">专栏</span><!--]--><meta property="keywords" content="专栏"></span></div><hr></div><div class="vp-toc-placeholder"><aside id="toc" vp-toc><!----><!--[--><div class="vp-toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon" name="print"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button><div class="arrow end"></div></div><div class="vp-toc-wrapper"><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#数据库服务器和连接层">数据库服务器和连接层</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#应用数据访问层">应用数据访问层</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#orm框架">ORM框架</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#本地查询构建框架">本地查询构建框架</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_4-4-客户端语句缓存">4.4 客户端语句缓存</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_5-1-结果集的可滚动性">5.1 结果集的可滚动性</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_5-2-结果集的可变更性">5.2 结果集的可变更性</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_5-3-结果集保持性">5.3 结果集保持性</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_5-5-结果集大小">5.5 结果集大小</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_5-5-2-列数过多">5.5.2 列数过多</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_6-1-原子性">6.1 原子性</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_6-2-一致性">6.2 一致性</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_6-3-隔离">6.3 隔离</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_6-3-1-并发控制">6.3.1 并发控制</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_6-3-2-异像">6.3.2 异像</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_6-3-3-隔离级别">6.3.3 隔离级别</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_6-4-持久性">6.4 持久性</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_6-5-只读事务">6.5 只读事务</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_6-5-1-只读事务路由">6.5.1 只读事务路由</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_6-6-事务边界">6.6 事务边界</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_6-6-1-分布式事务">6.6.1 分布式事务</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_6-6-2-声明式事务">6.6.2 声明式事务</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_6-7-应用级事务">6.7 应用级事务</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_6-7-1-悲观锁和乐观锁">6.7.1 悲观锁和乐观锁</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_7-2-jpa-与-hibernate">7.2 JPA 与 Hibernate</a></li><!----><!--]--></ul><div class="vp-toc-marker" style="top:-1.7rem;"></div></div><!--]--><!----></aside></div><!----><div class="theme-hope-content" vp-content><h1 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h1><p>在企业系统中，设计合理的数据库访问层可以对整体应用程序性能产生重大影响。根据 AppDynamics3 的数据，超过一半的应用程序性能瓶颈源于数据库。数据分布在各种结构（表行、索引节点）中，数据库记录可以被多个并发用户读取和写入。从并发的角度来看，这是一个极具挑战性的任务，为了最大限度地发挥持久层的作用，数据访问逻辑必须与底层数据库系统相匹配。</p><figure><img src="/assets/image-BP9yjLjw.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>典型的关系数据库管理系统（RDBMS）数据访问层需要掌握多种技术，而整个企业解决方案的强度取决于团队中最薄弱的技能。在深入到更高抽象层（例如对象关系映射（ORM）框架）之前，最好先攻克底层技术。</p><h2 id="数据库服务器和连接层" tabindex="-1"><a class="header-anchor" href="#数据库服务器和连接层"><span>数据库服务器和连接层</span></a></h2><p>数据库手册并非仅供数据库管理员使用。在不了解数据库工作原理的情况下与其交互，就像驾驶赛车却不接受任何驾驶培训一样。熟悉 SQL 标准和数据库特有的功能，能够决定应用程序的运行速度是高性能还是慢如蜗牛。对数据库可移植性的担忧可能会导致人们因为某些功能在不同数据库系统之间无法互换而放弃使用它们。实际上，数据库层运行缓慢的情况比将一个正在运行的系统移植到新的数据库解决方案更为常见。</p><p>所有数据访问框架都依赖 JDBC（Java 数据库连接）API 与数据库服务器通信。JDBC 提供了许多性能优化技术，旨在缩短事务响应时间并处理更多流量。因此，本书的第一部分专门介绍 JDBC 和数据库基础知识，涵盖数据库连接管理、语句批处理、结果集获取和数据库事务等主题。</p><h2 id="应用数据访问层" tabindex="-1"><a class="header-anchor" href="#应用数据访问层"><span>应用数据访问层</span></a></h2><p>许多企业应用场景中都证明了某些数据访问模式的有效性。Martin Fowler 的《企业应用架构模式》是每位企业应用开发人员的必读之作。除了对象关系映射 (ORM) 模式之外，大多数 ORM 框架还采用了诸如工作单元 (Unit of Work)、身份映射 (Identity Map)、延迟加载 (Lazy Loading)、嵌入值 (Embedded Value)、实体继承 (Entity Inheritance) 或乐观锁和悲观锁等技术。</p><h3 id="orm框架" tabindex="-1"><a class="header-anchor" href="#orm框架"><span>ORM框架</span></a></h3><p>ORM工具可以提升应用程序的开发速度，但其学习曲线无疑十分陡峭。要解决将关系数据与应用程序领域模型桥接起来的固有复杂性，唯一的方法就是完全理解所使用的ORM框架。</p><p>有时，即使是参考文档也可能不够，当遇到性能相关问题时，熟悉源代码是不可避免的。JPA（Java持久化API）在数据写入方面表现出色，因为所有DML（数据操作语言）语句都会在持久化模型更改时自动更新，从而加快迭代开发过程。</p><p>本书第二部分介绍了各种Hibernate特有的优化技术，例如标识符生成器、高效的实体获取、状态转换、应用程序级事务和实体缓存。</p><h3 id="本地查询构建框架" tabindex="-1"><a class="header-anchor" href="#本地查询构建框架"><span>本地查询构建框架</span></a></h3><p>JPA 和 Hibernate 从来不是用来替代 SQL 的，并且在任何非平凡的企业应用中，本地查询都是不可避免的。虽然 JPA 可以抽象 DML 语句和常见的实体检索查询，但在读取和处理数据时，没有什么可以胜过本地 SQL。</p><p>JPQL（Java 持久化查询语言）抽象了大多数关系型数据库支持的常见 SQL 语法。因此，JPQL 无法利用窗口函数、公共表表达式、派生表或 PIVOT。</p><p>与 JPA 不同，jOOQ（Java 面向对象查询）提供了类型安全的 API，它支持底层数据库系统提供的任何数据库特定查询功能。正如 Criteria API 在动态生成实体查询时能防止 SQL 注入攻击一样，jOOQ 在构建本地 SQL 语句时也提供了相同的安全保障。</p><p>因此，本书的第三部分是关于高级查询的。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>关于数据库性能基准测试</p><p>本书中穿插了一些基准测试，旨在展示特定性能优化带来的相对收益。基准测试结果始终取决于底层硬件、操作系统和数据库服务器配置、数据库大小以及并发模式。因此，绝对值不如相对优化收益重要。实际上，最相关的基准测试结果是针对实际生产系统进行的测试。</p><p>为了防止读者将不同数据库进行比较，并基于某些特定用例的基准测试得出错误的结论，数据库名称已进行混淆处理，分别以 DB_A、DB_B、DB_C 和 DB_D 表示。本书中使用的所有示例的源代码均可在 GitHub 上找到。</p></div><h1 id="jdbc-和数据库基础知识" tabindex="-1"><a class="header-anchor" href="#jdbc-和数据库基础知识"><span>JDBC 和数据库基础知识</span></a></h1><h1 id="_1-性能与扩展" tabindex="-1"><a class="header-anchor" href="#_1-性能与扩展"><span>1. 性能与扩展</span></a></h1><p>企业应用程序需要尽可能快速地存储和检索数据。在应用程序性能管理中，响应时间和吞吐量是两个最重要的指标。响应时间越短，应用程序的响应速度就越快。因此，响应时间是衡量性能的指标。扩展性是指在增加系统负载的同时保持较低的响应时间，因此，吞吐量是衡量可扩展性的指标。</p><p>1.1 响应时间和吞吐量</p><p>由于本书侧重于高性能数据访问，因此被测系统的边界位于事务管理器级别。</p><p>事务响应时间是指完成一个事务所需的时间，因此它包含以下时间段：</p><p>• 获取数据库连接的时间</p><p>• 通过网络发送所有数据库语句所需的时间</p><p>• 执行所有传入语句所需的时间</p><p>• 将结果集发送回数据库客户端所需的时间</p><p>• 在释放数据库连接之前，由于应用程序级计算而导致事务空闲的时间</p><figure><img src="/assets/image-1-CmsH8igx.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>吞吐量定义为完成传入负载的速率。在数据库上下文中，吞吐量可以计算为在给定时间间隔内执行的事务数量。</p><figure><img src="/assets/image-2-NRIQMYGn.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>根据这个定义，我们可以得出结论：通过缩短事务执行时间，系统可以处理更多请求。</p><p>在单数据库连接测试中，测得的吞吐量将成为进一步基于并发性改进的基准。</p><figure><img src="/assets/image-3-CxRzlUn1.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>理想情况下，如果系统呈线性扩展，增加数据库连接数将带来成比例的吞吐量提升。然而，由于数据库资源争用以及维护多个并发数据库会话间数据一致性的成本，相对吞吐量提升并非呈线性关系，而是呈曲线关系。通用可扩展性定律 (USL)¹ 可以近似表示最大相对吞吐量（系统容量）与负载生成器（数据库连接数）之间的关系。</p><figure><img src="/assets/image-4-3cqTWpX_.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>• C - 给定并发级别的相对吞吐量增益<br> • α - 争用系数（数据处理例程的可串行化部分）<br> • β - 一致性系数（在所有并发数据库会话中保持一致性的成本）。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>在 PostgreSQL 9.2 版本之前，预编译语句的规划和编译完全在准备阶段完成，因此执行计划是在没有实际绑定参数值的情况下生成的。虽然这种策略旨在节省数据库资源，但它对数据倾斜非常敏感。从 PostgreSQL 9.2 版本开始，准备阶段仅解析和重写语句，而优化和规划阶段则延迟到执行阶段。这样，重写的语法树会根据实际绑定参数值进行优化，从而生成最优的执行计划。</p><p>对于单次执行，普通语句只需要一次数据库往返，而预编译语句则需要两次（一次准备请求和一次执行调用）。为了避免网络开销，默认情况下，JDBC PreparedStatement 会在一次数据库请求中完成准备和执行两个阶段。</p><p>客户端预编译语句必须至少运行 5 次，驱动程序才能将其转换为服务器端语句。默认执行次数由 prepareThreshold 参数指定，该参数可通过连接属性或驱动程序特定的 API 进行配置。</p><p>经过多次执行后，如果性能对绑定参数值不敏感，优化器可能会将执行计划转换为通用计划并缓存以供重用。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>MySQL 在准备语句时，MySQL 解析器会生成一个语法树，并通过解析机制对其进行进一步验证和预优化。该语法树会经历若干数据不敏感的转换，最终输出为一个永久树。自 MySQL 5.7.4a 起，所有永久转换（例如重连接顺序或子查询优化）都在准备阶段完成，因此执行阶段仅应用数据敏感的转换。MySQL 不缓存执行计划，因此每个语句的执行都会针对当前的绑定参数值进行优化，从而避免数据倾斜问题。</p><p>由于一些未解决的问题，自 5.0.5b 版本起，MySQL JDBC 驱动程序仅模拟服务器端预处理语句。要切换到服务器端预处理语句，必须将 useServerPrepStmts 和 cachePrepStmts 连接属性都设置为 true。</p><p>启用此功能之前，最好查看最新的 Connector/J 发行说明，并确认此功能可以安全使用。</p></div><h2 id="_4-4-客户端语句缓存" tabindex="-1"><a class="header-anchor" href="#_4-4-客户端语句缓存"><span>4.4 客户端语句缓存</span></a></h2><p>缓存语句不仅对数据库端有益，JDBC 驱动程序也可以重用已构建的语句对象。客户端语句缓存的主要目标可以概括如下：</p><p>• 减少客户端语句处理，从而缩短事务响应时间。<br> • 通过回收语句对象及其关联的数据库特定元数据来节省应用程序资源。</p><p>在高性能 OLTP 应用中，事务往往非常短，因此即使响应时间略有减少，也能对整体事务吞吐量产生影响。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Oracle 隐式语句缓存</p><p>与服务器端计划缓存不同，客户端缓存仅限于数据库连接。由于 SQL 字符串会成为缓存条目键，因此 PreparedStatement 和 CallableStatement 语句更容易被重用。因此，Oracle JDBC 驱动程序仅支持这两种语句类型的缓存。启用缓存（默认禁用）后，驱动程序会返回一个逻辑语句，因此当客户端关闭连接时，该逻辑语句会返回缓存。</p><p>从开发角度来看，存在隐式语句缓存机制以及显式缓存机制。两种缓存选项共享相同的驱动程序存储空间，需要根据当前应用程序的需求进行配置。</p><p>隐式缓存只能存储语句元数据，这些元数据在每次执行之间不会改变。虽然可以为每个连接单独设置，但在数据源级别进行配置更为方便（所有连接继承相同的缓存属性）。</p><p>connectionProperties.put(&quot;oracle.jdbc.implicitStatementCacheSize&quot;, Integer.toString(cacheSize));<br> dataSource.setConnectionProperties(connectionProperties);</p><p>设置 implicitStatementCacheSize 也会启用缓存。默认情况下，所有正在执行的语句都会被隐式缓存，但这可能并非理想之选（某些偶尔执行的查询可能会清除其他频繁执行的语句）。为了控制语句缓存策略，JDBC 定义了 isPoolable() 和 setPoolable(boolean poolable) 语句方法：</p><p>if (statement.isPoolable()) {<br> statement.setPoolable(false);<br> }</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Oracle 显式语句缓存</p><p>显式缓存是可配置的，并通过 Oracle 特定的 API 管理。在使用它之前，必须使用底层的 OracleConnection 引用启用并调整其大小。</p><pre><code>    OracleConnection oracleConnection = (OracleConnection) connection;
    oracleConnection.setExplicitCachingEnabled(true);
    oracleConnection.setStatementCacheSize(cacheSize);
</code></pre><p>在使用显式缓存时，数据访问会控制哪些语句可以被缓存，因此不再需要使用 setPoolable(boolean poolable) 方法。以下示例演示了如何利用显式缓存机制。</p><pre><code>    PreparedStatement statement = oracleConnection
            .getStatementWithKey(SELECT_POST_REVIEWS_KEY);
    if (statement == null)
        statement = connection.prepareStatement(SELECT_POST_REVIEWS);
    try {
        statement.setInt(1, 10);
        statement.execute();
    } finally {
        ((OraclePreparedStatement) statement).closeWithKey(SELECT_POST_REVIEWS_KEY);
    }
</code></pre><p>显式缓存依赖于两种主要操作，可以总结如下：</p><ol><li>getStatementWithKey(String key) 方法从缓存中加载语句。如果未找到条目，则必须使用标准 JDBC API 手动创建 PreparedStatement</li><li>closeWithKey(String key) 方法将语句推回到池中。</li></ol><p>特定于供应商的 API 将数据访问代码与 Oracle 特定的 API 绑定，这会阻碍可移植性，并且在兼容多种数据库系统时需要更复杂的数据访问逻辑。</p><p>除了缓存元数据之外，显式缓存还存储执行状态和数据。尽管重用更多的客户端构造可能进一步提高性能，但这种策略存在将先前和当前执行上下文混合的风险，因此建议谨慎使用。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>SQL Server</p><p>虽然 Microsoft SQL Server JDBC 驱动程序定义了 disableStatementPooling 属性，但截至撰写本文时（4.2 版本），语句缓存无法启用。另一方面，jTDS（开源的 JDBC 3.0 实现）提供基于每个连接的语句缓存。作为 JDBC 4.0 特定的 API，setPoolable(boolean poolable) Statement 方法在 1.3.1 版本的 jTDS 中未实现。缓存的默认大小为 500 条目，也可以调整。</p><pre><code>    ((JtdsDataSource) dataSource).setMaxStatements(cacheSize);
</code></pre><p>即便 jTDS 一直专注于性能，与 Microsoft 驱动程序相比，缺乏稳定的发布计划仍是一个主要缺点。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>PostgreSQL</p><p>自 PostgreSQL JDBC 驱动 9.4-1202a 版本起，客户端的语句会被缓存，并且其关联的服务器端语句键即使在初始 PreparedStatement 关闭后也会被保留。只要当前连接缓存中包含指定的 SQL 语句，客户端的 PreparedStatement 和服务器端对象都可以被重用。setPoolable(boolean poolable) 方法无效，并且无法在每个语句的基础上禁用缓存。语句缓存由以下连接属性控制：• preparedStatementCacheQueries - 每个数据库连接缓存的语句数量。值为 0 时禁用缓存，并且在 PreparedStatement 关闭后，服务器端准备语句将不再可用。默认值为 256。• preparedStatementCacheSizeMiB - 语句缓存有上限内存，默认值为 5 MB。值为 0 时禁用缓存。这些属性既可以作为连接参数设置，也可以作为 DataSource 属性设置：</p><pre><code>    ((PGSimpleDataSource) dataSource).setPreparedStatementCacheQueries(cacheSize);
    ((PGSimpleDataSource) dataSource).setPreparedStatementCacheSizeMiB(cacheSizeMb);
</code></pre></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>MySQL</p><p>语句缓存与数据库连接相关，并适用于所有正在执行的语句。在 5.1.36 版本的 Connector/J 驱动程序中，setPoolable(boolean poolable) 方法只能禁用服务器端语句的缓存，客户端语句不受此设置影响。客户端语句缓存可以使用以下属性进行配置：<br> • cachePrepStmts - 启用客户端语句缓存以及服务器端语句有效性检查。默认情况下，语句缓存是禁用的。<br> • prepStmtCacheSize - 为每个数据库连接缓存的语句数量。默认缓存大小为 25。• prepStmtCacheSqlLimit - 允许缓存的 SQL 语句的最大长度。默认最大值为 256。</p><p>这些属性既可以作为连接参数设置，也可以在 DataSource 级别设置：</p><pre><code>    ((MysqlDataSource) dataSource).setCachePrepStmts(true);
    ((MysqlDataSource) dataSource).setPreparedStatementCacheSize(cacheSize);
    ((MysqlDataSource) dataSource).setPreparedStatementCacheSqlLimit(maxLength);
</code></pre></div><h1 id="_5-结果集获取" tabindex="-1"><a class="header-anchor" href="#_5-结果集获取"><span>5 结果集获取</span></a></h1><p>在讨论了 SQL 语句优化（批处理和缓存）之后，现在是时候关注查询处理的响应部分了。与仅返回受影响行数的 INSERT、UPDATE 和 DELETE 语句不同，JDBC SELECT 查询返回的是一个 ResultSet。</p><p>数据库执行器接收执行计划并将数据提取到结果集中。行可以一次性提取，也可以在数据库客户端请求时提取。</p><p>SQL 标准通过以下属性定义了结果集和游标描述符：</p><p>• 可滚动性（结果集的迭代方向）</p><p>• 敏感性（何时提取数据）</p><p>• 可更新性（适用于游标，允许客户端在遍历结果集时修改记录）</p><p>• 可持有性（结果集在事务生命周期中的作用范围）。</p><p>遵循标准规范，JDBC ResultSet 支持以上所有属性。</p><table><thead><tr><th>属性名称</th><th>描述</th></tr></thead><tbody><tr><td>TYPE_FORWARD_ONLY</td><td>结果集只能从第一个元素到最后一个元素进行迭代。这是默认的滚动性值。</td></tr><tr><td>TYPE_SCROLL_INSENSITIVE</td><td>结果集在加载时会生成一个快照，可以向前和向后迭代。</td></tr><tr><td>TYPE_SCROLL_SENSITIVE</td><td>结果集在迭代过程中按需获取，没有任何方向限制。</td></tr><tr><td>CONCUR_READ_ONLY</td><td>结果集只是一个静态数据投影，不允许行级操作。这是默认的可更改性值。</td></tr><tr><td>CONCUR_UPDATABLE</td><td>可以使用光标位置更新或删除记录，甚至插入新记录。</td></tr><tr><td>CLOSE_CURSORS_AT_COMMIT</td><td>当当前事务结束时，结果集将被关闭。</td></tr><tr><td>HOLD_CURSORS_OVER_COMMIT</td><td>即使当前事务已提交，结果集仍保持打开状态。</td></tr></tbody></table><h2 id="_5-1-结果集的可滚动性" tabindex="-1"><a class="header-anchor" href="#_5-1-结果集的可滚动性"><span>5.1 结果集的可滚动性</span></a></h2><p>JDBC 结果集可以使用应用程序级游标进行遍历。因此，数据获取机制隐藏在迭代器 API 之后，从而将应用程序代码与数据检索策略解耦。一些数据库驱动程序会在客户端预取整个结果集，而其他实现则会按需检索一批数据。</p><p>默认情况下，结果集使用仅向前遍历的应用程序级游标，该游标只能从第一个位置遍历到最后一个位置一次。虽然这对于大多数应用程序来说已经足够，但 JDBC 也提供了可滚动游标，因此允许行级指针自由定位（可以沿任意方向遍历每个记录）。</p><p>两种可滚动结果集的主要区别在于它们的选择性。不敏感游标提供当前结果集的静态视图，因此数据需要在迭代之前完全获取。敏感游标允许动态获取结果集，以便反映并发更改。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Oracle</p><p>由于数据库引擎不支持可滚动结果集，JDBC 驱动程序通过客户端缓存机制模拟滚动结果集。因此，结果集不宜过大，否则很容易耗尽客户端应用程序的内存。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>SQL Server</p><p>支持所有三种游标类型。不敏感滚动会生成服务器端数据库快照，客户端分批获取该快照。敏感滚动使用服务器端可更新窗口，并且仅在当前处理窗口内同步更改。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>PostgreSQL<br> 默认情况下，结果集会被完整获取并缓存在客户端。仅支持前向滚动和不敏感滚动。对于大型结果集，一次性获取所有记录可能会给数据库服务器资源和客户端内存带来巨大压力。为此，PostgreSQL 允许将结果集与数据库游标关联，以便按需获取记录。</p><p>PreparedStatement statement = connection.prepareStatement(</p><p>&quot;SELECT title FROM post WHERE id BETWEEN ? AND ?&quot;</p><p>);</p><p>statement.setFetchSize(100);</p><p>只有前向只读结果集类型才能利用数据库端游标，并且语句提取大小必须设置为正整数值。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>MySQL<br> 即使显式指定了前向只读结果集，也仅支持不敏感滚动类型。默认情况下，驱动程序会检索整个结果集并将其缓存在客户端。</p><p>如果语句类型同时是前向只读和只读，并且提取大小值设置为 Integer.MIN_VALUE，则可以流式传输大型结果集。这样，在迭代结果集时，每一行都会被单独提取，这可能会导致多次数据库往返。此外，在流关闭之前，连接无法执行任何其他语句。</p><p>PreparedStatement statement = connection.prepareStatement(</p><p>“SELECT title FROM post WHERE id BETWEEN ?” AND ?”</p><p>);</p><p>statement.setFetchSize(Integer.MIN_VALUE);</p><p>另一种方法是将 useCursorFetchb Connection 属性设置为 true，然后将 Statement 的提取大小设置为一个正整数值，表示一次需要提取的记录数。</p><p>statement.setFetchSize(100);</p></div><h2 id="_5-2-结果集的可变更性" tabindex="-1"><a class="header-anchor" href="#_5-2-结果集的可变更性"><span>5.2 结果集的可变更性</span></a></h2><p>默认情况下，结果集只是底层数据投影的只读视图。受数据库游标的启发，JDBC 标准提供了可更新的结果集，因此数据访问逻辑可以在迭代应用程序级游标的同时修改记录。</p><p>将读取和写入逻辑混合到单个数据库事务中，让人联想到两层架构，在两层架构中，即使在用户思考时间内持有结果集也是常见且可以接受的。</p><p>对于 Web 应用程序，请求应该尽可能短，并且大多数应用程序级事务跨越多个 Web 请求。前一个请求可能使用只读数据库事务来获取数据并将其呈现给用户，而后一个请求可能使用读写事务来应用数据修改。在这种情况下，可更新的结果集几乎没有用处，尤其是在多个请求中保持其打开状态（以及底层数据库连接）会严重影响应用程序的可扩展性。</p><p>以下测试用例验证了只读且仅向前的游标是否比敏感且可更新的游标性能更好。该测试执行 10000 条语句，获取 100 篇帖子及其详细信息和 1000 条相关评论。</p><figure><img src="/assets/image-5-BgLuBFU3.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>所有受测数据库系统在使用仅前向和只读结果集时均表现出轻微的性能提升。</p><h2 id="_5-3-结果集保持性" tabindex="-1"><a class="header-anchor" href="#_5-3-结果集保持性"><span>5.3 结果集保持性</span></a></h2><p>JDBC 3.0 版本增加了对结果集保持性的支持，与滚动性和更新性不同，其默认值取决于具体的实现。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Oracle<br> 默认且唯一支持的保持性值为 HOLD_CURSORS_OVER_COMMIT。尝试将此设置更改为任何其他值都会引发异常。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>SQL Server<br> 默认情况下，即使当前事务已提交或回滚，结果集仍保持打开状态。SQL Server 也支持 CLOSE_CURSORS_AT_COMMIT 设置。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>PostgreSQL<br> 与其他数据库系统不同，其默认保持性值为 CLOSE_CURSORS_AT_COMMIT，但驱动程序也支持 HOLD_CURSORS_OVER_COMMIT 设置。</p></div><p>:::<br> MySQL<br> 默认且唯一支持的保持性值为 HOLD_CURSORS_OVER_COMMIT。</p><p>在典型的企业应用中，数据库连接会在事务之间重复使用，因此在事务结束后保留​​结果集存在风险。根据底层数据库系统和游标类型的不同，结果集可能会占用系统资源，出于可扩展性的考虑，这些资源需要尽快释放。</p><p>虽然并非所有数据库引擎都支持 <code>CLOSE_CURSORS_AT_COMMIT</code> 选项，但只需关闭所有已获取的结果集及其关联的 <code>Statement</code> 对象即可达到相同的效果。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><h2 id="_5-4-提取大小" tabindex="-1"><a class="header-anchor" href="#_5-4-提取大小"><span>5.4 提取大小</span></a></h2><p>JDBC ResultSet 充当应用程序级游标，因此每次遍历语句时，结果都必须从数据库传输到客户端。传输速率由语句提取大小控制。</p><p>statement.setFetchSize(fetchSize);</p><p>自定义提取大小可以提示驱动程序在单次数据库往返中需要检索的行数。</p><p>默认值为 0，这意味着每个数据库都可以选择其驱动程序特定的提取策略。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Oracle</p><p>由于 JDBC 驱动程序的内存模型，默认提取大小设置为 10 条记录。Oracle 10i 和 11g 驱动程序在语句创建时预分配一个 byte[] 和一个 char[] 缓冲区，其长度由提取大小乘以每个选定列的最大内存占用量得出。VARCHAR2(N) 列最多可以容纳 N 个字节。将最大长度为 5 个字符的字段存储到 VARCHAR2(4000) 列中会在客户端预分配 4000 字节，这无疑会浪费内存。</p><p>通过重用现有缓冲区来避免内存分配，是采用语句缓存的一个非常重要的理由。只有在使用隐式语句缓存时，10i 和 11g 驱动程序才能从回收客户端内存缓冲区中获益。</p><p>12c 实现将缓冲区分配延迟到结果集准备好进行提取时。此驱动程序版本使用两个 byte[] 数组，并采用延迟分配的方式。与之前的版本相比，12c 的内存占用大大减少，因为驱动程序不再分配最大可能的数据存储空间，而是使用实际提取的数据大小。</p><p>尽管最佳提取大小取决于应用程序，并受数据大小和运行时环境并发拓扑结构的影响，但 Oracle JDBC 驱动程序规范建议将提取大小限制在最多 100 条记录。与其他任何性能优化一样，这些建议充其量只是参考，衡量应用程序性能才是找到合适提取大小的唯一可行方法。</p></div></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>SQL Server</p><p>SQL Server JDBC 驱动程序使用自适应缓冲，因此结果集会根据需要分批提取。因此，批次大小由驱动程序自动控制。</p><p>虽然默认情况下启用自适应缓冲，但它仅限于只读和前向游标。可滚动和可更新的结果集都基于单个数据块进行操作，该数据块的长度由当前语句的提取大小决定。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>PostgreSQL</p><p>整个结果集一次性加载到客户端内存中。默认的加载大小只需要一次数据库往返，但会增加驱动程序的内存消耗。通过更改加载大小，结果集会与数据库游标关联，从而允许按需加载数据。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>MySQL<br> 由于网络协议设计方面的考虑，加载整个结果集是最有效的数据检索策略。唯一的流式选项需要一次处理一行，数据库往返次数由预读缓冲区配置决定。</p></div><p>下图展示了四个数据库系统在加载 10,000 行数据时，随着只前进（forward-only）和只读(read-only)结果集加载大小的变化，响应时间的变化情况。</p><figure><img src="/assets/image-6-DeODYfFW.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>一次加载一行需要 10,000 次往返，网络开销会影响响应时间。最多 100 行时，提取大小在降低检索时间方面起着重要作用（只需 100 次往返），但超过这个点后，收益就不那么明显了。</p><h2 id="_5-5-结果集大小" tabindex="-1"><a class="header-anchor" href="#_5-5-结果集大小"><span>5.5 结果集大小</span></a></h2><p>设置合适的提取大小无疑可以加快结果集检索速度，前提是语句仅提取当前业务逻辑所需的数据。然而，不幸的是，尤其是在 ORM 工具广泛应用的情况下，语句经常会选择超出实际需要的数据。这个问题可能是由于选择了过多的行或列造成的，而这些数据随后会在数据访问层或业务层被丢弃。</p><p>5.5.1 行数过多</p><p>表往往会不断增长（尤其是在应用程序获得更多用户之后），随着时间的推移，即使是适中的结果集也可能很容易成为性能瓶颈。这些问题通常在生产系统中被发现，而此时应用程序代码早已发布。</p><p>用户界面能够容纳的信息量取决于视图允许显示的信息量。因此，如果结果集无法容纳在用户界面中，则提取整个结果集是低效的。分页或动态滚动是解决此问题的常用方法，而对数据集进行分区则变得不可避免。</p><p>限制结果集在批处理中也很常见。为了避免长时间运行的事务（这可能会给数据库的撤销/重做日志带来压力），并利用并行执行的优势，批处理处理器会将当前工作负载拆分成更小的作业。这样，一个批处理作业只需处理整个数据的一部分即可。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>当结果集大小受外部因素限制时，选择超出实际需要的数据是没有意义的。</p><p>如果不设置上限，结果集会随着底层表数据量成比例增长。庞大的结果集需要更多的时间来提取和传输。</p><p>因此，限制查询可以确保可预测的响应时间和数据库资源利用率。查询处理时间越短，行级锁释放得越快，数据访问层的可扩展性就越强。</p></div><p>限制结果集大小的方法主要有两种。</p><p>第一种也是最有效的策略是在 SQL 语句中包含行限制子句。这样，优化器就能更好地针对当前结果集大小生成最优执行计划（例如，选择索引扫描而不是表扫描）。</p><p>第二种方法是在 JDBC 语句级别配置最大行数。理想情况下，驱动程序可以调整语句，使其包含等效的结果集大小限制（作为 SQL 子句），但大多数情况下，它只是提示数据库引擎使用数据库游标。</p><h4 id="_5-5-1-1-sql-limit-子句" tabindex="-1"><a class="header-anchor" href="#_5-5-1-1-sql-limit-子句"><span>5.5.1.1 SQL LIMIT 子句</span></a></h4><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>SQL:2008</p><p>虽然 SQL:2008 增加了对限制结果集大小的支持，但只有从 Oracle 12ca、SQL Server 2012b 和 PostgreSQL 8.4c 开始才支持标准语法。</p><p>SELECT <a href="http://pc.id" target="_blank" rel="noopener noreferrer">pc.id</a> AS pc_id, p.title AS p_title</p><p>FROM post_comment pc</p><p>INNER JOIN post p ON <a href="http://p.id" target="_blank" rel="noopener noreferrer">p.id</a> = pc.post_id</p><p>ORDER BY pc_id</p><p>OFFSET ? ROWS</p><p>FETCH FIRST (?) ROWS ONLY</p><p>在 PostgreSQL 数据库中，用括号括起行数占位符是一种变通方法。在 SQL Server 中，无论是否使用括号，此方法都有效。</p><p>较旧的数据库版本或其他数据库系统（例如 MySQL 5.7）仍然依赖于特定于供应商的语法来限制结果集的大小。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Oracle</p><p>与其他关系型数据库不同，Oracle 没有用于限制查询结果集的保留关键字，但由于每条记录都分配有一个结果集条目顺序号（由 ROWNUM 虚拟列提供），因此限制结果集的语法如下：</p><p>SELECT *<br> FROM (<br> SELECT <a href="http://pc.id" target="_blank" rel="noopener noreferrer">pc.id</a> AS pc_id, p.title AS p_title<br> FROM post_comment pc<br> INNER JOIN post p ON <a href="http://p.id" target="_blank" rel="noopener noreferrer">p.id</a> = pc.post_id<br> ORDER BY pc_id<br> )<br> WHERE ROWNUM &lt;= ?</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>SQL Server</p><p>TOP 关键字一直是限制结果集大小的事实标准方法：</p><p>SELECT TOP (?) <a href="http://pc.id" target="_blank" rel="noopener noreferrer">pc.id</a> AS pc_id, p.title AS p_title<br> FROM post_comment pc<br> INNER JOIN post p ON <a href="http://p.id" target="_blank" rel="noopener noreferrer">p.id</a> = pc.post_id<br> ORDER BY pc_id</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>PostgreSQL 和 MySQL</p><p>LIMIT 关键字用于限制结果集的大小上限：</p><p>SELECT <a href="http://pc.id" target="_blank" rel="noopener noreferrer">pc.id</a> AS pc_id, p.title AS p_title<br> FROM post_comment pc<br> INNER JOIN post p ON <a href="http://p.id" target="_blank" rel="noopener noreferrer">p.id</a> = pc.post_id<br> ORDER BY pc_id<br> LIMIT ?</p></div><h4 id="_5-5-1-2-jdbc-最大行数" tabindex="-1"><a class="header-anchor" href="#_5-5-1-2-jdbc-最大行数"><span>5.5.1.2 JDBC 最大行数</span></a></h4><p>JDBC 规范定义了 <code>maxRows</code> 属性，用于限制当前语句的所有结果集 (ResultSet) 的数量。</p><p><code>statement.setMaxRows(maxRows);</code></p><p>与 SQL 构造不同，JDBC 的这种替代方案可以在所有驱动程序实现之间移植。</p><p>这在应用程序需要支持多个数据库系统时尤其方便。</p><p>根据 JDBC 文档，当达到最大阈值时，驱动程序应该丢弃多余的行。</p><p>从数据访问性能的角度来看，丢弃多余的行是一种糟糕的策略，因为它会浪费数据库资源（CPU、I/O、内存）以及网络带宽。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Oracle</p><p>当遍历 ResultSet 时，客户端游标会分块提取数据（fetch size 属性控制每个块中的记录数）。</p><p>每次新的批次检索后，系统会检查记录总数是否超过 maxRows 上限。如果达到该阈值，驱动程序将关闭网络流。</p><p>因此，maxRows 上限可以防止数据库和客户端驱动程序浪费资源来提取客户端不需要的记录。但是，如果 maxRows 值较小，当扫描的数据集较大时，优化器将不会使用索引。</p><p>SQL Server</p><p>当调用 Statement.setMaxRows(int maxRows) 方法时，驱动程序会调用 SET ROWCOUNT SQL 命令：</p><p>SET ROWCOUNT N</p><p>与 TOP 或 FETCH SQL 指令不同，ROWCOUNT 命令仅在执行阶段生效，不会影响执行计划的生成。因此，执行计划可能并未针对给定的结果集大小进行优化，所以可能会选择表扫描而不是索引。</p><p>SQL Server 文档建议使用 SQL 指令而不是 SET ROWCOUNT 命令。</p><p>PostgreSQL</p><p>JDBC 驱动程序会获取 maxRows 语句属性并将其与正在执行的查询一起发送。有了此信息，优化器可以选择一个针对给定结果集大小的执行计划，甚至可以避免一些耗时的操作，例如对整个投影进行排序。提取器也可以在提取所需数量的记录后立即关闭数据库游标，从而节省数据库和网络资源。</p><p>MySQL<br> maxRows 属性不会发送到数据库服务器，因此优化器和提取器都无法从中受益。虽然 JDBC 驱动程序通常会提取所有行，但通过设置结果集大小的上限，客户端可以节省一些网络开销。</p></div><h4 id="_5-5-1-3-少即是多" tabindex="-1"><a class="header-anchor" href="#_5-5-1-3-少即是多"><span>5.5.1.3 少即是多</span></a></h4><p>以下测试将演示限制结果集大小对性能的提升。测试数据集包含 10 万条帖子和 100 万条评论。在第一轮测试中，系统会获取整个结果集，响应时间与结果集的大小成正比。通过将结果集限制为 100 条记录（无论是使用 SQL 还是 JDBC 的 maxRows 设置），响应时间将显著降低。</p><figure><img src="/assets/image-7-CSsGn13z.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>测试结果证实了之前的假设，SQL 层限制被证明是限制结果集的最佳策略。maxRows 驱动程序的实现效果出乎意料地好，尤其是在考虑到 JDBC 规范中关于丢弃多余记录的规定时。获取大型结果集会给数据库资源带来巨大压力，这不仅会影响当前工作单元的处理时间，还会导致其他并发事务的处理时间延长，这是由于数据库资源不足造成的。</p><h3 id="_5-5-2-列数过多" tabindex="-1"><a class="header-anchor" href="#_5-5-2-列数过多"><span>5.5.2 列数过多</span></a></h3><p>获取过多行不仅会导致性能问题，提取过多列也会增加结果集的处理响应时间。下一个测试用例将使用以下两个语句之一，选择 100 篇帖子及其关联的 1000 条评论：</p><p>SELECT *<br> FROM post_comment pc<br> INNER JOIN post p ON <a href="http://p.id" target="_blank" rel="noopener noreferrer">p.id</a> = pc.post_id<br> INNER JOIN post_details pd ON <a href="http://p.id" target="_blank" rel="noopener noreferrer">p.id</a> = <a href="http://pd.id" target="_blank" rel="noopener noreferrer">pd.id</a></p><p>SELECT pc.version<br> FROM post_comment pc<br> INNER JOIN post p ON <a href="http://p.id" target="_blank" rel="noopener noreferrer">p.id</a> = pc.post_id<br> INNER JOIN post_details pd ON <a href="http://p.id" target="_blank" rel="noopener noreferrer">p.id</a> = <a href="http://pd.id" target="_blank" rel="noopener noreferrer">pd.id</a></p><p>下图展示了获取所有列与仅提取部分列投影的执行时间对比。</p><figure><img src="/assets/image-8-CndHLqWi.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>这种情况在 ORM 工具中更为常见，因为要完整填充实体，需要选择所有列。如果只选择少量实体，这可能不会造成明显影响，但对于大型结果集，这可能会演变成一个显著的性能问题。</p><p>如果业务需求仅需实体属性的子集，则获取额外的列将浪费数据库和应用程序资源（CPU、内存、I/O、网络）。</p><h1 id="_6-事务" tabindex="-1"><a class="header-anchor" href="#_6-事务"><span>6. 事务</span></a></h1><p>数据库系统必须允许对底层数据进行并发访问。然而，共享数据意味着读写操作必须同步，以确保数据完整性不受影响。</p><p>为了控制并发修改，Java 编程语言定义了 synchronized 关键字，其用途有二：</p><p>• 它可以限制对共享对象的访问（以保持不变性），从而确保在任何给定时间只有一个线程可以执行某个例程。</p><p>• 它将当前线程本地内存中的更改传播到所有正在运行的线程都可以访问的全局内存。</p><p>这种行为在其他并发编程环境中很常见，数据库系统也不例外。在关系数据库中，确保数据完整性的机制是在事务之上实现的。</p><p>事务是一组读写操作的集合，这些操作可以作为一个整体同时成功或失败。所有数据库语句都必须在事务上下文中执行，即使数据库客户端没有显式定义事务边界。</p><p>1981 年，Jim Gray 在他著名的论文《事务概念：优点和局限性》中首次定义了数据库事务的属性。这篇论文以及 SQL 标准的早期版本（SQL-86 和 SQL-89）都只使用了三个属性来定义数据库事务：原子性、一致性和持久性。</p><p>此后，事务研究以及其他关系数据库主题的研究一直在持续进行，因此 SQL-92 版本引入了隔离级别（IL）的概念。这四个特性被组合成著名的 ACID（原子性、一致性、隔离性和持久性）缩写，并很快成为关系数据库事务的代名词。</p><p>了解数据库事务的工作原理非常重要，原因有二：</p><ul><li>有效的数据访问（在追求高性能的同时，不应牺牲数据完整性）</li></ul><p>• 高效的数据访问（减少争用可以最大限度地缩短事务响应时间，从而提高吞吐量）。</p><p>接下来的章节将详细介绍与高性能数据处理相关的各项事务属性。</p><h2 id="_6-1-原子性" tabindex="-1"><a class="header-anchor" href="#_6-1-原子性"><span>6.1 原子性</span></a></h2><p>原子性是指将多个操作组合成一个要么全部成功要么全部失败的工作单元的特性，只有当所有单独的操作都成功时，该工作单元才能成功。因此，数据库必须能够回滚与每个已执行语句关联的所有操作。</p><figure><img src="/assets/image-9-BqeWTD1T.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>写-写冲突</p><p>理想情况下，每个事务都应该有一个完全隔离的分支，以便在回滚时可以轻松丢弃。这类似于版本控制系统（例如 Git）实现分支的方式。如果发生冲突，虚拟控制系统会中止提交操作，客户端必须手动解决冲突。与版本控制系统工具不同，关系数据库引擎必须在没有任何人工干预的情况下管理冲突。</p><p>因此，数据库会防止写-写冲突，并且在任何给定时间只能有一个事务写入记录。</p></div><p>所有语句均针对实际数据结构（表、索引、内存缓冲区）执行，仅在提交时才实际生效。如果发生回滚，数据库必须将所有待处理的已更改数据还原到之前的状态。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Oracle</p><p>撤销表空间将先前的数据版本存储在撤销段中。回滚时，数据库引擎会搜索关联的撤销段，以恢复当前运行事务所更改的每个数据的先前映像。</p><p>SQL Server</p><p>事务日志存储有关当前运行事务及其关联修改的详细信息。回滚过程会向后扫描事务日志以查找关联的撤销记录。找到记录后，数据库引擎会恢复受影响数据的先前映像。</p><p>为防止事务日志被填满，必须定期截断日志。长时间运行的事务会延迟截断过程，因此这也是应尽可能避免长时间运行事务的另一个原因。</p><p>PostgreSQL<br> 与其他数据库系统不同，PostgreSQL 不使用专用的仅追加撤销日志。由于其多版本特性，每个数据库对象都维护着自己的版本历史记录。由于没有日志查找阶段，回滚过程变得更加轻量级，因为它只需要从一个版本切换到另一个版本。</p><p>缺点是旧版本占用的空间大小有限，因此必须重复利用。回收旧版本占用存储空间的过程称为 VACUUM 清理。</p><p>每个事务都有一个关联的 XIDa，新事务的 XID 必须大于所有先前事务的 XID。</p><p>事务 XID 是一个 32 位数字，因此可以容纳超过 40 亿个事务。在高性能应用程序中，事务的生命周期非常短，如果禁用 VACUUM 清理，则可能会达到此阈值。当 XID 计数器达到其最大值时，它会循环并从零重新开始计数。</p><p>在 XID 回绕之前发起的事务的标识符大于 XID 计数器重置之后发起的新事务的标识符。这种异常情况会导致系统将较旧的事务视为未来发起的事务，从而导致非常严重的数据完整性问题。</p><p>MySQL<br> 撤销日志存储在系统表空间的回滚段中。</p><p>每个撤销日志分为两个部分，一部分用于回滚，另一部分用于重建回滚前的映像。事务结束后，第一部分可以立即清除，而第二部分则需要保留一段时间，直到当前正在运行的查询或其他并发事务需要查看相关记录的先前版本为止。</p><p>在后台，MySQL 会运行一个清除进程，清理已删除记录占用的存储空间，并回收不再需要的撤销日志段。</p><p>长时间运行的事务会延迟清除过程的执行，导致撤销日志变得非常大，尤其是在写入密集型数据访问场景中。</p></div><h2 id="_6-2-一致性" tabindex="-1"><a class="header-anchor" href="#_6-2-一致性"><span>6.2 一致性</span></a></h2><p>修改事务可以看作是一种状态转换，它将数据库从一个有效状态转移到另一个有效状态。关系数据库模式确保所有主要修改（插入/更新/删除语句）以及次要修改（由触发器发出）都遵循底层数据结构的特定规则：</p><ul><li>列类型</li><li>列长度</li><li>列是否允许为空</li><li>外键约束</li><li>唯一键约束</li><li>自定义检查约束。</li></ul><p>一致性是指验证事务状态的变更，确保所有已提交的事务离开数据库时都处于正确的状态。如果违反了任何约束，整个事务将被回滚，所有修改都将被还原。</p><p>虽然应用程序必须在编写数据库语句之前验证用户输入，但应用程序级别的检查无法跨越其他并发请求，这些请求可能来自不同的 Web 服务器。当数据库是主要集成点时，严格模式的优势就更加明显了。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>MySQL</p><p>传统上，MySQL 的约束并非严格执行，数据库引擎会将无效值替换为预定义的默认值：</p><ul><li>超出范围的数值会被设置为 0 或最大值。</li><li>字符串值会被截断至最大长度。</li><li>允许使用错误的日期/时间值（例如 2015-02-30）。</li><li>NOT NULL 约束仅对单行 INSERT 语句强制执行。对于多行插入，空数值会被替换为 0，空字符串会被替换为 &#39;&#39;。</li></ul><p>自 5.0.2 版本起，如果数据库引擎配置为使用自定义 SQL 模式，则可以执行严格的约束：</p><p>SET GLOBAL sql_mode=&#39;POSTGRESQL,STRICT_ALL_TABLES&#39;;</p><p>由于服务器启动时 sql_mode 会重置，因此最好在 MySQL 配置文件中进行设置：</p><p>[mysqld]<br> sql_mode = POSTGRESQL,STRICT_ALL_TABLES”</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>CAP 定理中的一致性</p><p>根据 CAP 定理，当分布式系统遇到网络分区时，系统必须在一致性（所有更改立即应用于所有节点）和可用性（任何节点都可以接受请求）之间做出选择，而不能同时选择两者。虽然在 ACID 的定义中，一致性是指遵守约束，但在 CAP 定理的语境下，一致性指的是线性化，这是一种隔离性保证。</p></div><h2 id="_6-3-隔离" tabindex="-1"><a class="header-anchor" href="#_6-3-隔离"><span>6.3 隔离</span></a></h2><p>如果只有一个用户访问数据库，则不会出现数据冲突的风险。根据通用可扩展性定律，如果数据访问模式的顺序部分小于 100%，则数据库系统可以从并行化中获益。</p><p>通过提供多个并发连接，可以提高事务吞吐量，从而使数据库系统能够处理更多流量。然而，并行化也带来了额外的挑战，因为数据库必须以某种方式交错执行事务，以确保冲突不会损害数据完整性。当所有当前正在运行的事务操作的执行顺序与底层事务按顺序执行的结果相同时，则称这些事务操作的执行顺序是可串行化的。</p><p>因此，可串行化执行是唯一既不损害数据完整性又允许一定程度并行化的事务隔离级别。1981 年，Jim Gray 曾描述最大的航空公司和银行拥有 10,000 个终端和 100 个活跃事务，这解释了为什么在 SQL-92 之前，可串行化一直是事实上的事务隔离级别。</p><h3 id="_6-3-1-并发控制" tabindex="-1"><a class="header-anchor" href="#_6-3-1-并发控制"><span>6.3.1 并发控制</span></a></h3><p>为了管理数据冲突，多年来人们开发了多种并发控制机制。处理数据冲突主要有两种策略：</p><p>避免冲突（例如两阶段锁定）需要使用锁定来控制对共享资源的访问。</p><p>检测冲突（例如多版本并发控制）可以提供更好的并发性，但代价是降低了可串行性，并且可能接受各种数据异常。</p><h4 id="_6-3-1-1-两阶段锁定" tabindex="-1"><a class="header-anchor" href="#_6-3-1-1-两阶段锁定"><span>6.3.1.1 两阶段锁定</span></a></h4><p>1976 年，Kapali Eswaran 和 Jim Gray 等人发表了题为《数据库系统中的一致性和谓词锁的概念》的论文，该论文证明，如果所有事务都使用两阶段锁定 (2PL) 协议，则可以实现可串行化。</p><p>最初，所有数据库系统都采用 2PL 来实现可串行化事务，但随着时间的推移，许多厂商转向了 MVCC（多版本并发控制）架构。默认情况下，SQL Server 仍然使用锁定来实现可串行化隔离级别。</p><p>由于 2PL 保证了事务的可串行化，因此了解维护严格数据完整性对应用程序整体可扩展性和事务性能的影响至关重要。</p><p>然而，锁并非仅用于两阶段逻辑（2PL）实现。为了解决数据操作语言（DML）和数据定义语言（DDL）语句交互问题，并最大限度地减少对共享资源的争用，关系数据库系统采用多粒度锁。</p><p>数据库对象本质上是分层的，一个逻辑表空间映射到多个数据库文件，这些文件由数据页构成，每个数据页包含多行数据。因此，可以对不同类型的数据库对象获取锁。</p><p>对较低层级（例如行）进行锁可以提高并发性，因为它降低了争用的可能性。由于每个锁都会占用资源，持有多个较低层级的锁会累积资源消耗，因此数据库可能会决定将多个较低层级的锁合并为一个较高层级的锁。这个过程称为锁升级，它以牺牲并发性为代价来换取数据库资源。</p><p>每个数据库系统都有其自身的锁层次结构，但最常见的锁类型（甚至在 2PL 的初始论文中也有提及）仍然是以下几种：</p><ul><li>共享（读）锁，允许读取操作，但阻止写入记录；</li><li>排他（写）锁，禁止读取和写入操作。</li></ul><p>仅靠锁不足以防止冲突。并发控制策略必须定义如何获取和释放锁，因为这也会影响事务交错。</p><p>为此，2PL协议定义了一种锁管理策略来确保可串行化。</p><p>2PL协议将事务分为两个阶段：</p><ul><li><p>扩展阶段（获取锁，但不释放锁）</p></li><li><p>收缩阶段（释放所有锁，且不再获取其他锁）。</p></li></ul><p>在基于锁的并发控制中，所有事务都必须遵循 2PL 协议，否则可串行性可能会受到损害，从而导致数据异常。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>事务调度</p><p>为了确保从故障中恢复，事务调度（所有交错操作的顺序）必须严格执行。如果第一个事务中的写操作发生在后续事务发生冲突之前，为了实现事务的严格性，第一个事务的提交事件也必须发生在冲突之前。</p><p>由于操作顺序正确，严格性可以防止级联中止（一个事务回滚触发一系列其他事务中止，从而维护数据一致性）。只有在事务结束（提交或回滚）后才释放所有锁是实现严格调度的必要条件。</p></div><p>下图展示了2PL机制如何协调事务的交错执行：</p><figure><img src="/assets/image-10-DinKxq17.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><ul><li><p>Alice和Bob都选择了一条帖子记录，并都获得了该记录的共享锁。</p></li><li><p>当Bob尝试更新该帖子记录时，由于Alice仍然持有该数据库行的共享锁，Bob的语句被锁管理器阻塞。</p></li><li><p>只有在Alice的事务结束并释放所有锁之后，Bob才能继续执行更新操作。</p></li><li><p>Bob的更新操作会触发锁升级，共享锁被替换为排他锁，从而阻止任何其他并发的读写操作。</p></li><li><p>Alice启动了一个新事务，并对同一条帖子记录发出查询请求，但由于Bob持有该记录的排他锁，Alice的语句被锁管理器阻塞。</p></li><li><p>在Bob的事务提交后，所有锁都被释放，Alice的查询可以继续执行，从而获取该数据库记录的最新值。</p></li></ul><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>死锁</p><p>使用锁来控制对共享资源的访问容易导致死锁，而事务调度程序本身无法阻止死锁的发生。</p><p>当两个并发事务都无法继续执行，因为它们都在等待对方释放锁时，就会发生死锁。<br> 由于两个事务都处于获取锁的阶段，因此在获取下一个锁之前，它们都不会释放当前持有的锁。</p><figure><img src="/assets/image-11-CWqsmudr.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>维护锁的顺序成为数据访问层的责任，数据库只能协助处理死锁情况。</p><p>数据库引擎运行一个独立的进程，扫描当前的冲突图以查找锁等待循环（即死锁）。当检测到循环时，数据库引擎会选择其中一个事务并终止它，从而释放该事务持有的锁，使其他事务能够继续执行。</p></div><h4 id="_6-3-1-2-多版本并发控制" tabindex="-1"><a class="header-anchor" href="#_6-3-1-2-多版本并发控制"><span>6.3.1.2 多版本并发控制</span></a></h4><p>尽管加锁可以提供可串行化的事务调度，但锁竞争的开销会损害事务响应时间和可伸缩性。响应时间会增加，因为事务必须等待锁释放，而且长时间运行的事务也会减慢其他并发事务的执行速度。根据阿姆达尔定律和通用可伸缩性定律，并发性也会受到竞争的影响。</p><p>为了解决这些缺点，数据库厂商选择了乐观并发控制机制。如果说两阶段锁定（2PL）是防止冲突，那么多版本并发控制（MVCC）则采用冲突检测策略。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>MVCC 的优势在于，读操作不会阻塞写操作，写操作也不会阻塞读操作。唯一的冲突来源是写操作会阻塞其他并发的写操作，否则会影响事务回滚和原子性。</p></div><p>为了防止阻塞，数据库可以重建数据库记录的先前版本，从而将未提交的更改隐藏起来，使其不被并发读取者访问。由于缺乏锁定机制，实现可串行化调度变得更加困难，因此数据库引擎必须分析当前交错执行的操作，并检测可能破坏可串行性的异常情况。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Oracle</p><p>Oracle 数据库完全不使用两阶段锁定（2PL），而是依靠多版本并发控制（MVCC）机制来管理并发数据访问。每个查询都会获取一个特定时间点的数据快照，并且根据隔离级别的不同，时间戳引用可以是相对于当前语句或当前事务开始时间。</p><p>为了重建之前的记录版本，Oracle 使用撤销段，其中已包含回滚未提交更改所需的所有数据。时间点基于系统更改号（SCN），这是一个逻辑时间戳引用，与物理时间不同，它保证单调递增。</p><p>除了 MVCC 之外，Oracle 还支持显式锁定，使用 SELECT FOR UPDATE SQL 语法。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>SQL Server</p><p>默认情况下，SQL Server 使用锁来实现 SQL 标准规定的所有隔离级别。</p><p>为了使 Read Committed 隔离级别能够利用 MVCC 模型，必须首先进行以​​下配置：</p><p>ALTER DATABASE high_performance_java_persistence<br> SET READ_COMMITTED_SNAPSHOT ON;</p><p>对于更高级别的隔离，SQL Server 提供了快照隔离模式，该模式必须在数据库级别启用：</p><p>ALTER DATABASE high_performance_java_persistence<br> SET ALLOW_SNAPSHOT_ISOLATION ON;</p><p>由于快照隔离是一种自定义隔离级别，因此在启动新事务之前，也必须在连接级别进行设置：</p><p>SET TRANSACTION ISOLATION LEVEL SNAPSHOT;<br> GO<br> BEGIN TRANSACTION;<br> GO<br> COMMIT TRANSACTION;<br> GO</p><p>启用行版本控制后，数据库可以在 tempdb 数据库中跟踪记录更改。</p><p>当行被更新或删除时，当前行条目会引用到存储在 tempdb 数据库版本存储中的先前版本。行不会立即删除，而只是标记为删除，实际删除操作由 Ghost 清理任务完成。旧版本必须保留，直到当前正在运行的事务不再需要它们为止，这由事务隔离级别指定。</p><p>Ghost 清理任务会定期运行，回收不再需要的旧版本占用的存储空间。</p><p>长时间运行的事务会要求数据库引擎长时间保留一些旧版本，而且由于版本更改是以链表结构链接在一起的，因此恢复非常旧的版本可能会消耗大量资源。”</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>PostgreSQL</p><p>与其他所有数据库系统不同，PostgreSQL 将当前行及其先前版本（甚至包括已中止事务的版本）都存储在实际的数据库表中。与 Oracle 类似，PostgreSQL 采用 MVCC 数据访问模型，并且完全不提供 2PL 事务隔离实现。</p><p>每个表行都有两个额外的列（xmin 和 xmax），用于控制不同行版本的可见性。插入行时，当前事务标识符存储在 xmin 列中。</p><p>更新和删除操作最终都会创建一个新的行条目，其 xmax 列存储当前事务标识符。</p><p>Vacuum 进程会定期运行，回收被删除条目（以及已成功提交的事务）或当前运行事务不再需要的先前版本所占用的存储空间。</p><p>尽管 PostgreSQL 被视为纯粹的 MVCC 模型，但仍然需要锁定来防止写-写冲突或进行显式锁定。SELECT FOR UPDATE 用于获取排他行级锁，而 SELECT FOR SHARE 则用于应用共享锁。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>MySQL</p><p>InnoDB 存储引擎支持 ACID 事务，并使用 MVCC（多版本并发控制）来控制对共享资源的访问。InnoDB 的 MVCC 实现与 Oracle 非常相似，之前的数据库行版本也存储在回滚段中。</p><p>当事务需要访问之前的行版本时，MySQL 必须从回滚段中重建该版本。删除操作只是将条目标记为待删除状态，实际的物理清理工作由清除线程完成。</p><p>事务回滚和恢复之前行版本（这是保证给定事务可见性所必需的）的过程非常相似。</p><p>与其他数据库系统一样，当 MVCC 无法满足需求时，MySQL 也提供显式锁定机制。可以使用 SELECT LOCK IN SHARE MODE 获取共享锁，而独占锁则使用更常见的 SELECT FOR UPDATE 语法。</p></div><h3 id="_6-3-2-异像" tabindex="-1"><a class="header-anchor" href="#_6-3-2-异像"><span>6.3.2 异像</span></a></h3><p>对于合理的事务吞吐量值，假定事务可串行化是合理的。但随着传入流量的增长，严格数据完整性的代价变得过高，这是存在多种隔离级别的主要原因。放宽可串行化保证可能会导致数据完整性异常，这些异常也称为现象。</p><p>SQL-92 标准引入了三种在偏离可串行化事务调度时可能出现的异像：</p><ul><li>脏读</li><li>不可重复读</li><li>幻读</li></ul><p>实际上，由于事务交错执行，还会出现其他一些现象，正如著名的论文《对 ANSI SQL 隔离级别的批判》中所描述的那样：</p><ul><li>脏写</li><li>读倾斜</li><li>写倾斜</li><li>丢失更新</li></ul><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>选择合适的隔离级别需要在提高并发性和容忍可能出现的异常之间进行权衡。</p><p>可伸缩性会受到资源争用和数据一致性维护成本的影响。隔离级别越低，所需的锁（或多版本事务回滚）就越少，应用程序的可伸缩性就越高。</p><p>然而，较低的隔离级别允许更多异常情况发生，数据完整性的责任也从数据库端转移到了应用程序逻辑层。应用程序必须确保采取一​​切措施来防止或减轻任何此类数据异常。</p></div><p>在深入探讨隔离级别之前，最好先了解每种现象背后的原理以及它们如何影响数据完整性。在选择特定的事务隔离级别时，理解这些现象对于做出正确决策至关重要。</p><h4 id="_6-3-2-1-脏写" tabindex="-1"><a class="header-anchor" href="#_6-3-2-1-脏写"><span>6.3.2.1 脏写</span></a></h4><p>脏写是指两个并发事务被允许同时修改同一行数据。如前所述，所有更改都会应用到实际的数据库对象结构上，这意味着第二个事务会直接覆盖第一个事务尚未提交的更改。</p><figure><img src="/assets/image-12-DJRNEY2K.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>如果这两笔事务都提交成功，其中一笔事务会悄无声息地覆盖另一笔事务，导致更新丢失。另一个问题是，如果第一笔事务想要回滚，数据库引擎就必须选择以下几种处理方式之一：</p><p>如果两个事务都提交，其中一个事务会悄无声息地覆盖另一个事务的更改，导致更新丢失。另一个问题是，当第一个事务想要回滚时，数据库引擎必须选择以下操作路径之一：</p><ul><li>它可以将行恢复到之前的版本（即第一个事务更改之前的版本），但这会覆盖第二个事务尚未提交的更改。</li><li>它可以承认存在一个较新的版本（由第二个事务创建），但如果第二个事务也需要回滚，那么它的先前版本将成为第一个事务尚未提交的更改。</li></ul><p>如果数据库引擎不阻止脏写，就无法保证回滚的有效性。由于在缺乏可靠回滚的情况下无法实现原子性，因此所有数据库系统都必须阻止脏写。</p><p>尽管SQL标准没有提及这种现象，但即使是最低的隔离级别（读未提交）也能阻止它。</p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>关于脏写：</p><p><a href="https://www.cnblogs.com/heyu/articles/14598223.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/heyu/articles/14598223.html</a></p></div><h4 id="_6-3-2-2-脏读" tabindex="-1"><a class="header-anchor" href="#_6-3-2-2-脏读"><span>6.3.2.2 脏读</span></a></h4><p>如前所述，所有数据库更改都会应用于实际的数据结构（内存缓冲区、数据块、索引）。当一个事务被允许读取其他并发事务尚未提交的更改时，就会发生脏读。<br> 基于尚未提交的值做出业务决策是危险的，因为未提交的更改可能会被回滚。</p><figure><img src="/assets/image-13-DN8iKjib.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>这种异常情况仅在“读未提交”（Read Uncommitted）隔离级别下允许发生，由于其对数据完整性造成严重影响，大多数数据库系统都提供更高的默认隔离级别。</p><p>为了防止脏读，数据库引擎必须对所有其他并发事务隐藏未提交的更改。每个事务都可以看到自己的更改，否则“读自己写入的数据”的一致性保证就会被破坏。</p><p>如果底层数据库使用两阶段锁定（2PL），则未提交的行会受到写锁的保护，从而阻止其他并发事务在这些记录提交之前读取它们。</p><p>当底层数据库使用多版本并发控制（MVCC）时，数据库引擎可以使用已记录每个未提交记录先前版本的撤销日志（undo log），在其他并发事务查询中恢复先前的值。大多数数据库系统都会优化恢复先前值的过程，从而降低其对整体应用程序性能的影响。</p><p>读取未提交数据（Read Uncommitted）很少用到（仅限于非严格的报表查询，在这些查询中可以接受脏读），因此读取已提交数据（Read Committed）通常是实际应用中最低的隔离级别。</p><h4 id="_6-3-2-3-不可重复读" tabindex="-1"><a class="header-anchor" href="#_6-3-2-3-不可重复读"><span>6.3.2.3 不可重复读</span></a></h4><p>如果一个事务读取数据库中的一行数据时没有对新获取的记录加共享锁，那么在第一个事务结束之前，另一个并发事务可能会修改该行数据。</p><p>“当当前事务根据给定数据库行的初始值做出业务决策时，这种现象就会出现问题（例如，客户可能会根据库存数量值订购产品，而该值可能不再是正整数）。</p><p>大多数数据库系统已转向多版本并发控制（MVCC）模型，不再强制要求使用共享锁来防止不可重复读。通过验证当前行版本，如果先前获取的记录在此期间发生了更改，则可以中止该事务。</p><p>可重复读（Repeatable Read）和可串行化（Serializable）隔离级别默认可以防止这种异常。在读已提交（Read Committed）隔离级别下，如果显式获取共享锁（例如，使用 SELECT FOR SHARE），也可以避免不可重复读（模糊读）。</p><p>一些ORM框架（例如 JPA/Hibernate）提供应用程序级别的可重复读。任何检索到的实体对象的第一个快照都会缓存在当前运行的持久化上下文中。任何后续查询返回同一数据库行时，都将使用之前缓存的同一个对象。这样，即使在读已提交隔离级别下，也可以防止模糊读。</p><h4 id="_6-3-2-4-幻读" tabindex="-1"><a class="header-anchor" href="#_6-3-2-4-幻读"><span>6.3.2.4 幻读</span></a></h4><p>如果一个事务基于满足给定谓词的一组行做出业务决策，但在没有范围锁的情况下，另一个并发事务可能会插入一条符合该谓词的记录。</p><p>SQL 标准规定，如果两次连续的查询执行返回不同的结果，则会发生幻读，这是因为并发事务在两次查询之间修改了记录范围。虽然提供一致性读取是可串行化的必要条件，但这还不够。例如，一个买家可能会购买一件产品，却不知道在他获取商品列表后不久就出现了更好的报价。</p><p>基于 2PL 的可串行化隔离级别通过使用谓词锁来防止幻读。另一方面，MVCC 数据库引擎通过返回一致的快照来解决幻读异常。但是，并发事务仍然可以修改之前读取的记录范围。即使 MVCC 数据库引擎检查事务调度，其结果也并非总是与基于 2PL 的实现相同。例如，当第二个事务执行插入操作而没有读取与第一个事务相同的记录范围时，就会出现这种情况。在这种特定情况下，某些 MVCC 数据库引擎不会回滚第一个事务。</p><h4 id="_6-3-2-5-读取偏差" tabindex="-1"><a class="header-anchor" href="#_6-3-2-5-读取偏差"><span>6.3.2.5 读取偏差</span></a></h4><p>读取偏差是一种鲜为人知的异常现象，它涉及对多个数据库表的约束。在以下示例中，应用程序要求帖子（post）和帖子详情（post_details）同步更新。每当帖子记录发生更改时，其关联的帖子详情必须记录进行当前修改的用户。</p><figure><img src="/assets/image-14-D_mO2RLv.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>在选择帖子和帖子详情行的过程中，第二个事务悄悄介入并成功更新了这两条记录。第一个事务看到的是帖子行的旧版本和关联帖子详情的最新版本。由于这种读取​​偏差，第一个事务误以为该帖子是由 Bob 更新的，但实际上，它是 Alice 更新的旧版本。</p><p>与不可重复读类似，有两种方法可以避免这种现象：</p><ul><li><p>第一个事务可以对每次读取都获取共享锁，从而阻止第二个事务更新这些记录。</p></li><li><p>在验证提交约束时（使用可重复读或可序列化隔离级别的 MVCC 实现时），第一个事务可以中止。</p></li></ul><p>TODO：事务中止的效果是什么</p><h4 id="_6-3-2-6-写倾斜" tabindex="-1"><a class="header-anchor" href="#_6-3-2-6-写倾斜"><span>6.3.2.6 写倾斜</span></a></h4><p>与读倾斜类似，这种现象涉及对两个不同表进行不相关的写入操作，而这两个表又被约束为必须作为一个整体进行更新。每当帖子行发生更改时，客户端都必须更新 post_details 表，并记录进行更改的用户。</p><figure><img src="/assets/image-16-CPFFbMe5.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>Alice 和 Bob 都选择了帖子及其关联的 post_details 记录。如果允许写倾斜，Alice 和 Bob 可以分别更新这两个记录，从而违反约束。</p><p>与不可重复读一样，有两种方法可以避免这种现象：</p><p>第一个事务可以对这两个条目都获取共享锁，从而阻止第二个事务更新这些记录。</p><p>数据库引擎可以检测到另一个事务已更改这些记录，因此它可以强制第一个事务回滚（在可重复读或可串行化隔离级别的 MVCC 实现下）。</p><h4 id="_6-3-2-7-更新丢失" tabindex="-1"><a class="header-anchor" href="#_6-3-2-7-更新丢失"><span>6.3.2.7 更新丢失</span></a></h4><p>当一个事务读取一行数据，而另一个事务在该事务完成之前修改了该行数据时，就会发生更新丢失现象。在下面的示例中，Bob 的更新会被 Alice 静默覆盖，而 Alice 并不知道该记录已被更新。</p><figure><img src="/assets/image-15-CurN88zb.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>这种异常可能会对数据完整性造成严重后果（例如，买家可能会在不知情的情况下购买价格已更改的商品），尤其因为它会影响到“读已提交”（Read Committed）隔离级别，而这正是许多数据库系统的默认隔离级别。</p><p>传统上，“可重复读”（Repeatable Read）隔离级别可以防止更新丢失，因为共享锁可以阻止并发事务修改已读取的记录。而在 MVCC（多版本并发控制）机制下，第二个事务可以进行修改，但当数据库引擎检测到行版本不匹配时（在第一个事务提交期间），第一个事务将被中止。</p><p>大多数 ORM 工具（例如 Hibernate）都提供应用程序级别的乐观锁，它会在每次修改记录时自动集成行版本。如果行版本不匹配，更新计数将为零，因此应用程序可以回滚当前事务，因为当前的数据快照已过期。</p><h3 id="_6-3-3-隔离级别" tabindex="-1"><a class="header-anchor" href="#_6-3-3-隔离级别"><span>6.3.3 隔离级别</span></a></h3><p>如前所述，Serializable 是唯一能够提供真正 ACID 事务交错的隔离级别。然而，可串行化并非没有代价，因为锁定会引入争用，进而限制并发性和可伸缩性。即使在多版本并发控制模型中，可串行化也可能需要中止太多受各种现象影响的事务。</p><p>为此，SQL-92 标准引入了多种隔离级别，数据库客户端可以选择在并发性和数据正确性之间进行权衡。每个隔离级别都根据它必须阻止的最小现象数量来定义，因此 SQL 标准引入了以下事务隔离级别：</p><figure><img src="/assets/image-17-CanCKbAS.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>如果没有显式设置，JDBC 驱动程序将使用默认隔离级别，可以使用 DatabaseMetaData 对象的 getDefaultTransactionIsolation() 方法进行查看：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> level </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> connection</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getMetaData</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getDefaultTransactionIsolation</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>可以使用 Connection 对象的 setTransactionIsolation(int level) 方法更改默认隔离级别。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">connection</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setTransactionIsolation</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">Connection</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">TRANSACTION_SERIALIZABLE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>尽管 ACID 属性意味着可串行化调度，但大多数关系数据库系统使用的默认隔离级别较低：</p><p>读已提交 (Oracle、SQL Server、PostgreSQL)<br> 可重复读 (MySQL)</p></div><p>以下各节将详细介绍每种事务隔离级别，并演示特定数据库系统实际阻止的现象列表。</p><h4 id="_6-3-3-1-未提交读" tabindex="-1"><a class="header-anchor" href="#_6-3-3-1-未提交读"><span>6.3.3.1 未提交读</span></a></h4><figure><img src="/assets/image-18-CrGXJNcG.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Oracle</p><p>Oracle 不允许脏读，因此最低隔离级别是“读已提交”。</p><p>如果客户端尝试在当前连接上设置“未提交读”隔离级别，JDBC 驱动程序甚至会抛出异常。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>SQL Server</p><p>“未提交读”仅防止脏写，允许所有其他现象发生。使用“未提交读”时，不会对特定的 SQL 修改操作施加排他锁，因此即使在提交之前，其他并发事务也可以访问未提交的更改。如果可以接受脏读的风险，避免排他锁可以加快报表查询速度，尤其是在扫描大量数据时。</p><p>对于基于锁的并发控制机制，如果脏读的风险远小于锁定数据库表中大部分数据的风险，则值得考虑使用“未提交读”。由于 MVCC 避免了读写锁和写读锁，因此允许脏读可能不会带来显著的性能提升。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>PostgreSQL<br> 与 Oracle 类似，PostgreSQL 不允许脏读，最低隔离级别为 Read Committed。</p><p>选择 Read Uncommitted 时，JDBC 驱动程序会默默地回退到 Read Committed。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>MySQL<br> 尽管使用 MVCC，但 InnoDB 实现了 Read Uncommitted，因此允许脏读。<br> 作为一项优化措施，每个查询都无需重建当前扫描记录的先前已提交版本（使用回滚段）（以防这些记录最近被修改过）。</p></div><h4 id="_6-3-3-2-read-committed" tabindex="-1"><a class="header-anchor" href="#_6-3-3-2-read-committed"><span>6.3.3.2 Read Committed</span></a></h4><p>Read Committed 是最常见的隔离级别之一，它在多个关系数据库系统或各种并发控制模型中表现一致。</p><p>许多数据库系统选择 Read Committed 作为默认隔离级别，因为它在防止脏写和脏读等严重异常的同时，提供了最佳性能。<br> 但是，性能是有代价的，因为 Read Committed 允许许多可能导致数据损坏的异常情况。</p><figure><img src="/assets/image-19-BM2_cFuP.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Oracle</p><p>每个语句都有一个开始时间戳，用于创建相对于该特定时间点的数据库快照。这样，写入方仍然可以更新当前选定的记录，而数据库可以简单地重构查询开始时可用的先前版本。后续查询执行可能会返回不同的行版本，因此允许出现不可重复读。</p><p>当两个事务尝试更新同一条记录时，第一个事务会锁定该记录以防止脏写。第二个事务必须等待第一个事务释放锁（提交或回滚），并且会根据最新数据重新评估语句的过滤条件。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>PostgreSQL<br> 与 Oracle 类似，每个查询都会看到当前正在运行的查询开始时的数据库快照。由于不使用共享锁来保护先前读取的记录不被修改，因此 Read Committed 允许出现多种数据异常。</p><p>排他锁可以防止写写冲突，因此当两个事务更新同一条记录时，第二个事务会等待第一个事务释放其锁。当第二个事务恢复执行时，如果过滤条件仍然有效，它可能会覆盖第一个事务的修改，从而导致更新丢失。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>MySQL</p><p>查询时快照用于隔离语句与其他并发事务。当显式获取共享锁或排他锁，或发出更新或删除语句（这些语句会获取排他锁以防止脏写）时，如果选定的行通过唯一搜索条件（例如主键）进行过滤，则可以将锁应用于关联的索引条目。</p><p>在 5.7 版本之前，如果修改语句使用范围过滤器并且搜索条件利用了唯一索引扫描，则数据库可以使用间隙锁或下一键锁（因此也可以防止幻读）。Read Committed 不支持基于语句的复制，因此应用程序必须使用基于行的二进制日志记录。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>SQL Server<br> 默认情况下，SQL 语句使用共享锁来防止其他事务修改当前获取的记录。锁会在查询执行完成后释放。激活 Read Committed Snapshot Isolation 后，数据库不再使用共享锁，每个查询都会选择查询开始时的行版本。</p></div><p>6.3.3.3 可重复读</p><p>可重复读是隔离级别中合规性最低的一种，其实现细节会影响到它所能防止的并发问题：</p><figure><img src="/assets/image-20-dUYgmK2R.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Oracle<br> Oracle 完全不支持可重复读隔离级别，如果客户端尝试显式设置该级别，JDBC 驱动程序将抛出异​​常。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>SQL Server</p><p>对于客户端读取的每一行，当前事务都会获取一个共享锁，阻止任何其他事务同时修改该行。共享锁会在事务提交或回滚时释放。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>PostgreSQL</p><p>PostgreSQL 使用快照隔离（Snapshot Isolation）来实现可重复读，因此不仅可以防止脏读，还可以防止幻读。PostgreSQL 的 MVCC 实现不使用锁，而是允许冲突发生，但会中止任何不再满足事务保证的事务。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>MySQL</p><p>每个事务只能看到事务开始时的行状态。这可以防止不可重复读，但仍然允许丢失更新和写倾斜。</p></div><p>6.3.3.4 可序列化 Serializable</p><p>可序列化旨在提供一种事务调度机制，即使语句交错执行，其结果也应等同于串行执行。</p><p>即使并发控制机制是基于锁的，或者管理多个记录版本，它也必须防止所有异常情况，以确保事务的可序列化。仅仅防止 SQL 标准中提到的所有异常（脏读、不可重复读和幻读）是不够的，可序列化还必须防止更新丢失、读取偏差和写入偏差。</p><p>实际上，并发控制的实现细节往往会暴露出来，并非所有关系型数据库系统都能提供真正可序列化的隔离级别（某些数据完整性异常仍然可能发生）。</p><figure><img src="/assets/image-21-CaKY4oYU.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Oracle<br> Serializable 隔离级别实际上是快照隔离并发控制机制的一种 MVCC 实现。与 PostgreSQL 的 Repeatable Read 隔离级别类似，Oracle 无法防止写入偏差，这意味着它无法提供真正可序列化的事务。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>SQL Server<br> Serializable 隔离级别基于 2PL，因此可以防止所有异常现象。基于 MVCC 的快照隔离与 Oracle 的 Serializable 和 PostgreSQL 的 Repeatable Read 隔离级别类似，因此它允许写入偏差。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>PostgreSQL<br> 为了克服快照隔离的局限性，PostgreSQL 开发了可序列化快照隔离 (SSI)，它提供了真正的可序列化事务。由于 SSI 仍然是 MVCC 实现，PostgreSQL 会监控事务调度并检测可能的可序列化异常。</p><p>当前的实现可能会检测到误报，即使某些事务实际上并未破坏事务的可序列化性，也可能会被中止。只有精确可序列化快照隔离 (PSSI) 模型才能消除所有误报，但由于性能开销过高，数据库实现者最终选择了 SSI。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>MySQL<br> Serializable 隔离级别是在 Repeatable Read 的基础上实现的，不同之处在于，每个被选中的记录都会被共享锁保护。这种基于锁的方法使 MySQL 能够防止写入偏差现象，而这种现象在许多快照隔离实现中普遍存在。</p></div><h2 id="_6-4-持久性" tabindex="-1"><a class="header-anchor" href="#_6-4-持久性"><span>6.4 持久性</span></a></h2><p>购买机票时，款项会从银行账户中扣除，并为购票者预留座位。假设在购票后，航空公司预订系统立即崩溃，那么即使系统重启后，所有之前处理的交易也必须保持有效。如果系统不强制执行此要求，已预订的机票可能会丢失，购票者可能会面临账户被扣款但却没有机票的情况。</p><p>持久性确保所有已提交的事务更改都是永久性的。</p><p>持久性保证了系统的可恢复性，在某种程度上类似于回滚机制。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>那么撤销日志呢（undo log）？</p><p>为了支持事务回滚并在多版本并发控制（MVCC）系统中重建先前版本，数据库系统会将当前修改（包括未提交的更改）记录在撤销日志中。但是，可恢复性只需要已提交的更改，而且由于过时的撤销段可能会被频繁回收，因此仅靠撤销日志不足以实现可恢复性。</p><p>事务提交后，数据库会将所有当前更改持久化到一个仅追加的顺序数据结构中，该结构通常称为重做日志（redo log）。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Oracle<br> 重做日志由多个重做记录组成，每个记录包含更改向量，用于捕获实际的数据块更改。<br> 出于性能考虑，重做记录存储在缓冲区中，日志写入器会将内存中的记录刷新到当前活动的重做日志文件中。在任何给定时间，Oracle 至少有两个重做文件，但只有一个文件处于活动状态并可用于收集日志缓冲区条目。事务提交后，数据库会刷新缓冲区，更改也会被持久化。</p><p>如果缓冲区已满，Oracle 会刷新缓冲区以及所有未提交的更改，如果相关事务回滚，这些未提交的更改将被删除。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>SQL Server<br> 与 Oracle 不同，SQL Server 将撤销日志和重做日志合并到一个称为事务日志的单一数据结构中。默认情况下，当事务提交时，所有相关的事务日志条目都会在控制权返回给客户端之前写入磁盘。</p><p>SQL Server 2014 添加了可配置的持久性支持。日志条目写入磁盘的操作可以延迟执行，从而提高 I/O 利用率并降低事务响应时间。如果系统崩溃，所有尚未写入磁盘的日志条目都将从内存中丢失。因此，只有在可以容忍数据丢失的情况下，才适合使用异步写入模式。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>PostgreSQL<br> 语句更改记录在预写日志 (WAL) 中。日志条目缓存在内存中，并在每次事务提交时写入磁盘。</p><p>由于可以在恢复期间从 WAL 恢复其状态，因此无需为每个事务都将缓存的数据页和索引条目写入磁盘（从而优化了 I/O 利用率）。从 9.1 版本开始，PostgreSQL 支持可配置的持久性，因此 WAL 也可以异步写入。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>MySQL<br> 与单个事务关联的所有重做日志条目都存储在迷你事务缓冲区中，并一次性写入全局重做缓冲区。全局缓冲区在“提交”期间写入磁盘。默认情况下，有两个日志文件交替使用。</p><p>默认情况下，写入操作是同步进行的，但可以通过 innodb_flush_log_at_trx_commit 参数切换到异步模式。</p></div><p>由于数据持久性对于业务运营至关重要，因此最好坚持使用同步刷新机制。只有当业务需求允许数据丢失且重做日志刷新确实成为性能瓶颈时，延迟持久性保证才是一个可行的选择。</p><h2 id="_6-5-只读事务" tabindex="-1"><a class="header-anchor" href="#_6-5-只读事务"><span>6.5 只读事务</span></a></h2><p>JDBC Connection 定义了 setReadOnly(boolean readOnly) 方法，该方法可用于提示驱动程序对即将进行的只读事务应用一些数据库优化。不应在事务执行过程中调用此方法，因为数据库系统无法将读写事务转换为只读事务（事务必须从一开始就设置为只读）。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Oracle<br> 根据 JDBC 驱动程序文档，数据库服务器不支持只读事务优化。即使将 Connection 的只读状态设置为 true，仍然允许执行修改语句，限制此类语句的唯一方法是执行以下 SQL 命令：</p><p>connection.setAutoCommit(false);<br> try(CallableStatement statement = connection.prepareCall(<br> &quot;BEGIN SET TRANSACTION READ ONLY; END;&quot;)) {<br> statement.execute();<br> }</p><p>SET TRANSACTION READ ONLY 命令必须在禁用自动提交状态后运行，否则它仅对该特定语句生效。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>SQL Server</p><p>与 Oracle 类似，只读 Connection 状态不会传播到数据库引擎，禁用 SQL 修改的唯一方法是使用单独的帐户，该帐户仅限于查看数据。</p><p>设置 ApplicationIntent=ReadOnly 连接属性并不能阻止 JDBC 驱动程序在只读 Connection 上执行修改语句。此属性的目的是将读写连接和只读连接路由到副本节点。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>PostgreSQL<br> 如果在只读状态设置为 true 的 Connection 上执行修改语句，则会抛出异常。</p><p>数据库引擎会优化只读事务，因此可以降低可序列化隔离级别下的误报率，并允许使用可延迟的可序列化快照。<br> 执行 SET TRANSACTION SERIALIZABLE READ ONLY DEFERRABLE 时会激活可延迟快照。当前事务必须等待可用的安全快照，该快照可以执行而不会因非可序列化异常而被中止。如果默认的读写可序列化事务在访问大量数据时存在问题，则可延迟快照可能是长时间运行事务的更好选择。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>MySQL</p><p>如果在 Connection 设置为只读状态时执行修改语句，JDBC 驱动程序将抛出异​​常。 InnoDB 可以优化只读事务，因为它无需生成事务ID，而只读事务也不需要事务ID。</p></div><h3 id="_6-5-1-只读事务路由" tabindex="-1"><a class="header-anchor" href="#_6-5-1-只读事务路由"><span>6.5.1 只读事务路由</span></a></h3><p>设置数据库复制环境对于实现高可用性（从节点可以替代崩溃的主节点）和流量分流都非常有用。在主从复制拓扑结构中，主节点接受读写事务和只读事务，而从节点仅处理只读流量。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Oracle<br> Oracle ADG（Active Data Guard）允许企业应用程序将读写流量分发到主节点，并将只读事务分发到备用数据库。WebLogic Server GridLink 数据源在 Oracle ADG 之上提供了故障转移和负载均衡功能。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>SQL Server<br> 必须配置数据库可用性组以使用只读路由，在这种情况下，重定向基于 ApplicationIntent 连接属性。这意味着应用程序需要为读写连接和只读连接分别配置不同的数据源，并且事务路由必须在应用程序服务层启动。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>PostgreSQL<br> JDBC 驱动程序定义了两个用于负载均衡的连接属性：loadBalanceHosts（默认禁用）和 targetServerType（master 或 preferSlave）。<br> 要启用事务路由，应用程序必须使用不同的数据源自行进行路由。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>MySQL</p><p>com.mysql.jdbc.ReplicationDriver 支持在主从拓扑结构上进行事务路由，路由决策基于连接的只读状态。</p></div><p>即使 JDBC 驱动程序不支持主从路由，应用程序也可以使用多个 DataSource 实例来实现。这种设计不能依赖于底层 Connection 的只读状态，因为路由必须在获取数据库连接之前进行。</p><figure><img src="/assets/image-22-BShFEofm.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>如果事务管理器支持声明式只读事务，则可以根据当前事务的只读偏好来决定路由。否则，必须在每个服务层组件中手动进行路由，因此只读事务会使用只读的 DataSource 或只读的 JPA 持久化上下文。</p><h2 id="_6-6-事务边界" tabindex="-1"><a class="header-anchor" href="#_6-6-事务边界"><span>6.6 事务边界</span></a></h2><p>每个数据库语句都在数据库事务的上下文中执行，即使客户端没有显式设置事务边界。虽然可能存在单语句事务（通常是只读查询），但当工作单元包含多个 SQL 语句时，数据库应该将它们全部封装在一个工作单元中。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>默认情况下，每个连接都以自动提交模式启动，每个语句都在单独的事务中执行。</p><p>不幸的是，这种模式不适用于多语句事务，因为它将原子性边界从逻辑工作单元转移到了每个单独的语句。</p><p>应尽可能避免使用自动提交模式，即使对于单语句事务，也最好显式标记事务边界。</p></div><p>在以下示例中，一笔款项在两个银行账户之间进行转账。账户余额必须始终保持一致，因此如果一个账户被扣款，另一个账户必须同时存入相同金额的款项。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Connection</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> connection </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> dataSource</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getConnection</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    PreparedStatement</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> transferStatement </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> connection</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">prepareStatement</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">        &quot;UPDATE account SET balance = ? WHERE id = ?&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    )</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    transferStatement</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setLong</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">negateExact</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(cents));</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    transferStatement</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setLong</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, fromAccountId);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    transferStatement</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">executeUpdate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    transferStatement</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setLong</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, cents);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    transferStatement</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setLong</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, toAccountId);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    transferStatement</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">executeUpdate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于启用了自动提交模式，如果第二条语句执行失败，只有该语句所做的更改可以回滚，而第一条语句已经提交，无法撤销。</p><p>因此，必须禁用默认的自动提交模式，并手动管理事务。只有当所有语句都成功执行时，事务才会提交；如果任何语句执行失败，则会触发回滚。考虑到这一点，前面的示例应该重写如下：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Connection</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> connection </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> dataSource</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getConnection</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    connection</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setAutoCommit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">false</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">PreparedStatement</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> transferStatement </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> connection</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">prepareStatement</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">        &quot;UPDATE account SET balance = ? WHERE id = ?&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    )</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        transferStatement</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setLong</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">negateExact</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(cents));</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        transferStatement</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setLong</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, fromAccountId);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        transferStatement</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">executeUpdate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        transferStatement</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setLong</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, cents);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        transferStatement</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setLong</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, toAccountId);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        transferStatement</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">executeUpdate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        connection</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">commit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">SQLException</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> e</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        connection</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">rollback</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        throw</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>细心的读者可能会注意到，前面的示例违反了单一职责原则，因为数据访问对象（DAO）方法混合了事务管理和数据访问逻辑。事务管理是一个横切关注点，因此很适合将其移至单独的通用库中。这样，事务管理逻辑就集中在一个地方，并且可以从 DAO 方法中删除许多重复的代码。提取事务管理逻辑的一种方法是使用模板方法模式：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> transact</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Consumer</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">Connection</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> callback) {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    Connection</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> connection </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        connection </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> dataSource</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getConnection</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        callback</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">accept</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(connection);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        connection</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">commit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Exception</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> e</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (connection </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">                connection</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">rollback</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">SQLException</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> ex</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">                throw</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> DataAccessException</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(e)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        throw</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (e </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">instanceof</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> DataAccessException </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">?</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            (DataAccessException) e </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> DataAccessException</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(e))</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">finally</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(connection </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">                connection</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">close</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">SQLException</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> e</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">                throw</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> DataAccessException</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(e)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有了这个工具，前面的示例可以简化为：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">transact</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">((</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Connection</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> connection) </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">PreparedStatement</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> transferStatement </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> connection</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">prepareStatement</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">        &quot;UPDATE account SET balance = ? WHERE id = ?&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    )</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        transferStatement</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setLong</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">negateExact</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(cents));</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        transferStatement</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setLong</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, fromAccountId);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        transferStatement</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">executeUpdate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        transferStatement</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setLong</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, cents);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        transferStatement</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setLong</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, toAccountId);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        transferStatement</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">executeUpdate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">SQLException</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> e</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        throw</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> DataAccessException</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(e)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">})</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然比第一个代码片段有所改进，但将数据访问逻辑和事务管理分开仍然不够。</p><p>事务边界仍然很僵化，而且，要在单个数据库事务中包含多个数据访问方法，就必须将 Connection 对象作为参数传递给每个 DAO 方法。</p><p>声明式事务可以更好地解决这个问题，它打破了数据访问逻辑和事务管理代码之间的紧密耦合。事务边界通过元数据（例如注解）进行标记，并由一个独立的事务管理器抽象负责协调事务逻辑。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Java EE 和 JTA</p><p>声明式事务对于分布式事务而言至关重要。Java EE（企业版）最初出现时，应用服务器同时托管 Web 应用程序和中间件集成服务，这意味着 Java EE 容器需要协调多个数据源（DataSource）甚至 JMS（Java 消息服务）队列。</p><p>JTA（Java 事务 API）遵循 X/Open XA 架构，为 Java EE 的分布式事务需求提供支持。</p></div><h3 id="_6-6-1-分布式事务" tabindex="-1"><a class="header-anchor" href="#_6-6-1-分布式事务"><span>6.6.1 分布式事务</span></a></h3><p>本地事务和全局事务的区别在于，前者使用单个资源管理器，而后者则操作多个异构资源管理器。ACID 保证仍然适用于每个单独的资源，但必须使用全局事务管理器来协调分布式事务的结果。</p><p>所有事务性资源适配器都由全局事务管理器注册，该管理器决定何时允许资源提交或回滚。Java EE 管理的资源可以通过 JNDI（Java 命名和目录接口）或 CDI（上下文和依赖注入）访问。</p><p>Spring 提供了一个事务管理抽象层，可以配置为使用本地事务（JDBC 或 RESOURCE_LOCAL JPA）或通过独立的 JTA 事务管理器使用全局事务。依赖注入机制将托管资源自动注入到 Spring Bean 中。</p><p>6.6.1.1 两阶段提交</p><p>JTA 使用两阶段提交 (2PC) 协议来协调资源的原子提交，该协议分为两个阶段：准备阶段和提交阶段。</p><figure><img src="/assets/image-23-8jbdgflG.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>在准备阶段，资源管理器会执行所有必要的操作，为即将到来的提交做好准备。只有当所有资源管理器都成功确认准备阶段后，事务管理器才会进入提交阶段。如果某个资源未确认准备阶段，事务管理器将回滚所有当前参与者。</p><p>如果所有资源管理器都确认提交阶段，则全局事务将成功结束。</p><p>如果某个资源提交失败（或超时），事务管理器将必须在后台线程中重试此操作，直到成功或报告该事件以进行手动干预。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>单阶段提交 (1PC) 优化：由于 Java EE 仅使用 JTA 事务，额外的数据库往返通信带来的协调开销可能会在高吞吐量应用环境中影响性能。当事务仅涉及一个资源适配器（指定单个资源管理器）时，事务管理器可以跳过准备阶段，直接执行提交或回滚阶段。通过这种优化，分布式事务的行为类似于 JDBC 连接管理本地事务的方式。</p><p>XAResource.commit(Xid xid, boolean onePhase) 方法接受一个布尔标志，事务管理器会将该标志设置为 true，以提示关联的资源适配器启动 1PC 优化。</p></div><h3 id="_6-6-2-声明式事务" tabindex="-1"><a class="header-anchor" href="#_6-6-2-声明式事务"><span>6.6.2 声明式事务</span></a></h3><p>事务边界通常与服务层相关联，服务层使用一个或多个 DAO 来实现业务逻辑。事务在服务层事务边界内从一个组件传播到另一个组件。</p><figure><img src="/assets/image-24-DZhyWD9K.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>声明式事务模型同时受到 Java EE 和 Spring 的支持。事务边界通过类似的传播策略进行控制，这些策略定义了在最外层组件（当前调用堆栈中）与当前组件（等待被调用）之间的边界处，事务边界如何被继承或中断。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>传播</p><p>为了配置 EJB 组件的事务传播策略，Java EE 定义了 @TransactionAttribute 注解。自 Java EE 7 起，即使是非 EJB 组件，如果添加了 @Transactional 注解，也可以参与到事务上下文中。</p><p>在 Spring 中，事务传播（与其他事务属性一样）可以通过 @Transactional 注解进行配置。</p></div><p>表 6.6：事务传播策略</p><table><thead><tr><th>传播行为</th><th>Java EE</th><th>Spring</th><th>描述</th></tr></thead><tbody><tr><td>REQUIRED</td><td>是</td><td>是</td><td>默认传播策略。仅在当前线程未关联事务上下文时创建新事务</td></tr><tr><td>REQUIRES_NEW</td><td>是</td><td>是</td><td>挂起当前事务（如果存在），并创建新事务</td></tr><tr><td>SUPPORTS</td><td>是</td><td>是</td><td>当前存在事务则加入，否则以非事务方式运行</td></tr><tr><td>NOT_SUPPORTED</td><td>是</td><td>是</td><td>挂起当前事务（如果存在），并以非事务方式执行</td></tr><tr><td>MANDATORY</td><td>是</td><td>是</td><td>必须在已有事务上下文中执行，否则抛出异常</td></tr><tr><td>NESTED</td><td>否</td><td>是</td><td>当前存在事务时在嵌套事务中执行，否则创建新事务（仅Spring支持）</td></tr><tr><td>NEVER</td><td>是</td><td>是</td><td>必须在非事务上下文中执行，当前存在事务时抛出异常</td></tr></tbody></table><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>声明式异常处理</p><p>由于事务逻辑封装了底层服务和数据访问逻辑调用链，因此异常处理也必须以声明方式进行配置。默认情况下，Java EE 和 Spring 都会在遇到系统异常（任何 RuntimeException）时回滚事务，并在遇到应用异常（受检异常）时提交事务。</p><p>在 Java EE 中，可以使用 @ApplicationException 注解自定义回滚策略。</p><p>Spring 允许每个事务通过列出触发事务失败的异常类型来定制回滚策略。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>声明式只读事务</p><p>Java EE 不支持以声明方式标记只读事务。</p><p>Spring 提供了事务只读属性，该属性可以传播到底层 JPA 提供程序（以优化 EntityManager 的刷新机制）和当前关联的 JDBC 连接。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>声明式隔离级别</p><p>Java EE 不支持可配置的隔离级别，因此所有数据库连接的隔离级别都由底层 DataSource 定义。</p><p>Spring 在使用 JpaTransactionManager 时支持事务级别的隔离级别。对于 JTA 事务，JtaTransactionManager 遵循 Java EE 标准，不允许覆盖默认隔离级别。作为一种变通方法，Spring 框架提供了扩展点，应用程序开发人员可以自定义默认行为并实现一种机制，以基于事务设置隔离级别。</p></div><h2 id="_6-7-应用级事务" tabindex="-1"><a class="header-anchor" href="#_6-7-应用级事务"><span>6.7 应用级事务</span></a></h2><p>到目前为止，本书主要关注数据库事务，以确保 ACID 特性。然而，从应用程序的角度来看，业务工作流程可能跨越多个物理数据库事务，在这种情况下，数据库的 ACID 保证就不再足够了。一个逻辑事务可能包含多个 Web 请求，包括用户的思考时间，因此可以将其视为一个长时间的交互过程。</p><p>在下面的示例中，Alice 和一个后台进程正在同时修改同一条数据库记录。</p><figure><img src="/assets/image-25-Daf4JFwM.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>由于 Alice 的逻辑事务包含两个独立的 Web 请求，每个请求都对应一个独立的数据库事务，因此如果没有额外的并发控制机制，即使是最强的隔离级别也无法防止更新丢失的问题。</p><p>将数据库事务跨越多个 Web 请求是不可行的，因为锁会在用户思考期间一直被持有，从而影响系统的可扩展性。即使使用 MVCC，维护先前版本（这可能导致版本图变得非常庞大）的成本也会不断增加，从而影响性能和并发性。应用级事务需要应用级的并发控制机制。</p><p>HTTP 本质上是无状态的，而且出于诸多原因，无状态应用程序比有状态应用程序更容易扩展。然而，应用程序级别的事务不能是无状态的，否则后续请求就无法从之前的请求中断处继续执行。在多个 Web 请求之间保持状态可以构建会话上下文，从而提供应用程序级别的可重复读取保证。</p><p>在下图中，Alice 使用了有状态的会话上下文，但在没有记录版本控制系统的情况下，仍然可能丢失更新。</p><figure><img src="/assets/image-26-Y1BQepGn.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>在 Alice 不知情的情况下，批处理程序重置了产品数量。Alice 以为产品版本没有改变，于是尝试购买一件商品，导致之前的产品数量减少了一件。最终，爱丽丝的操作覆盖了批处理程序的修改，数据完整性遭到破坏。</p><p>因此，应用程序级别的可重复读并不能完全解决问题（这个论点也适用于数据库隔离级别）。为了防止更新丢失，并发控制机制变得必不可少。</p><h3 id="_6-7-1-悲观锁和乐观锁" tabindex="-1"><a class="header-anchor" href="#_6-7-1-悲观锁和乐观锁"><span>6.7.1 悲观锁和乐观锁</span></a></h3><p>隔离级别隐含着锁机制，无论是物理锁（例如 2PL）还是数据异常检测（MVCC）。为了协调状态变更，应用层并发控制使用显式锁，显式锁有两种类型：悲观锁和乐观锁。</p><h4 id="_6-7-1-1-悲观锁" tabindex="-1"><a class="header-anchor" href="#_6-7-1-1-悲观锁"><span>6.7.1.1 悲观锁</span></a></h4><p>如前所述，大多数数据库系统都提供了手动请求共享锁或排他锁的功能。这种并发控制被称为悲观锁，因为它假设冲突必然发生，因此必须采取相应的措施来防止冲突。</p><p>由于锁可以及时释放，因此在长时间会话的最后一个数据库事务中使用排他锁是合适的。这样，应用程序可以确保一旦获得锁，其他事务就无法干扰当前锁定的资源。</p><p>对关键记录加锁可以防止不可重复读、丢失更新以及读写偏差等现象。</p><h4 id="_6-7-1-2-乐观锁" tabindex="-1"><a class="header-anchor" href="#_6-7-1-2-乐观锁"><span>6.7.1.2 乐观锁</span></a></h4><p>乐观锁这个名称无疑是个误称（尽管相当普遍），因为它实际上根本不使用任何锁。一个更好的名称应该是乐观并发控制，因为它使用与悲观锁完全不同的方法来管理冲突。</p><p>MVCC 是一种乐观并发控制策略，因为它假设冲突不太可能发生，因此它不依赖于锁来控制对共享资源的访问。乐观并发机制检测异常，并中止那些不满足不变性的事务。</p><p>虽然数据库确切地知道在给定时间间隔内发布了哪些行版本，但应用程序需要维护事件的发生顺序。每个数据库行都必须有一个关联的版本，该版本由逻辑事务在本地递增。每个修改数据的 SQL 语句（更新或删除）都使用先前加载的版本作为假设，即该行在此期间没有被更改。</p><p>由于即使是最低的隔离级别也可以防止写写冲突，因此在任何给定时间只允许一个事务更新一个行版本。由于数据库已经提供了单调更新，因此行版本也可以单调递增，应用程序可以检测到何时更新的记录已过期。</p><p>乐观锁并发控制算法如下所示：</p><ul><li>当客户端读取特定行时，该行的版本号会与其他字段一起返回。</li><li>更新行时，客户端会根据之前加载的版本号来过滤当前记录。</li></ul><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  UPDATE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> product </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  SET</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (quantity, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">version</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> AND</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> version</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>如果更新语句的更新计数为零，则表示版本号在此期间已被其他操作递增，当前事务正在操作的是一个过时的记录版本。</li></ul><p>前面的示例可以进行调整，以利用这种乐观并发控制机制。这次，产品被赋予了版本号，并且Web应用程序和批处理程序的数据访问逻辑都使用行版本号来协调更新操作的顺序。</p><figure><img src="/assets/image-27-Qz5fk_6C.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>Alice和批处理程序都尝试以乐观的方式递增产品版本号。批处理程序可以成功更新产品数量，因为SQL语句的过滤条件与实际数据库记录的版本号匹配。</p><p>当Alice尝试更新产品时，数据库返回的更新计数为零，这样她就被告知在此期间发生了并发更新。</p><p>由于应用程序在收到记录版本过时的通知时可以中止当前事务，因此可以防止丢失更新的问题。</p><h1 id="二、jpa-和-hibernate" tabindex="-1"><a class="header-anchor" href="#二、jpa-和-hibernate"><span>二、JPA 和 Hibernate</span></a></h1><h1 id="_7-jpa-和-hibernate-的重要性" tabindex="-1"><a class="header-anchor" href="#_7-jpa-和-hibernate-的重要性"><span>7. JPA 和 Hibernate 的重要性</span></a></h1><p>尽管 JDBC 很好地提供了一个通用的 API，隐藏了特定于数据库供应商的通信协议，但它仍然存在以下缺点：</p><ul><li><p>即使对于简单的任务，API 也非常冗长。</p></li><li><p>从数据访问层的角度来看，批处理操作并不透明，需要使用与非批处理语句不同的特定 API。</p></li><li><p>缺乏对显式锁定和乐观并发控制的内置支持。</p></li><li><p>对于本地事务，数据访问与事务管理语义纠缠在一起。</p></li><li><p>获取关联关系需要额外的处理，才能将 ResultSet 转换为领域模型或 DTO（数据传输对象）图。</p></li></ul><p>虽然 ORM（对象关系映射）工具的主要目标是自动将对象状态转换转换为 SQL 语句，但本章旨在演示 Hibernate 如何解决上述所有 JDBC 的缺点。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Java 持久化历史</p><p>EJB 1.1 版本通过可扩展的企业组件（称为实体 Bean）提供了更高级别的持久化抽象。<br> 尽管这种设计在理论上看起来不错，但实际上，基于 RMI 的重量级实现从性能角度来看是灾难性的。EJB 2.0 对本地接口的支持也未能挽救实体 Bean 的流行度，由于其高复杂性和特定于供应商的实现细节，大多数项目最终选择了 JDBC。</p><p>Hibernate的诞生源于使用实体Bean开发模型所带来的种种挫折。作为一个开源项目，Hibernate迅速获得了广泛的欢迎，并很快成为事实上的Java持久化框架。</p><p>为了回应所有与实体Bean持久化相关的批评，Java社区进程（JCP）提出了一种轻量级的基于POJO的方法，并由此诞生了JDO规范。</p><p>尽管JDO与数据源无关，能够与关系型数据库、NoSQL数据库甚至平面文件一起工作，但它从未真正普及。因此，Java社区进程决定EJB3将基于一个新的规范，该规范受到Hibernate和TopLink的启发，最终JPA（Java Persistence API）成为标准的Java持久化技术。</p><p>由此可见，持久化是一个非常复杂的主题，它需要对数据库和数据访问使用模式有深入的了解。</p></div><p>7.1 阻抗不匹配</p><p>当通过面向对象程序操作关系型数据库时，两种不同的数据表示方式就会产生冲突。</p><p>在关系型数据库中，数据存储在表中，关系代数定义了数据关联的形成方式。另一方面，面向对象编程（OOP）语言允许对象同时拥有状态和行为，并且允许双向关联。</p><p>协调这两种截然不同的方法所带来的负担造成了很大的困扰，并且长期以来一直困扰着企业系统。</p><figure><img src="/assets/image-28-BrI9T65S.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>上图描绘了数据访问层需要关联的两种不同模式。数据库模式由SQL标准规范驱动，而领域模型也具有面向对象的模式表示。</p><p>领域模型封装了业务逻辑规范，并捕获了数据结构以及控制业务需求的各种行为。面向对象编程（OOP）有助于领域建模，许多现代企业系统都是基于面向对象编程语言实现的。</p><p>由于底层数据存储在关系型数据库中，因此领域模型必须适应数据库模式和基于 SQL 的通信协议。ORM 设计模式有助于弥合这两种不同的数据表示形式之间的差距，并消除它们之间的技术鸿沟。每个数据库行都与一个领域模型对象（在 JPA 术语中称为实体）相关联，因此 ORM 工具可以将实体状态转换转换为 DML 语句。</p><p>从应用程序开发的角度来看，这非常方便，因为操作领域模型关系比通过底层 SQL 语句来理解业务逻辑要容易得多。</p><h2 id="_7-2-jpa-与-hibernate" tabindex="-1"><a class="header-anchor" href="#_7-2-jpa-与-hibernate"><span>7.2 JPA 与 Hibernate</span></a></h2><p>JPA 仅仅是一个规范。它描述了客户端操作的接口以及标准的对象关系映射元数据（Java 注解或 XML 描述符）。除了 API 定义之外，JPA 还解释了（尽管并非详尽无遗）JPA 提供程序应该如何实现这些规范。JPA 随着 Java EE 平台本身的发展而发展（Java EE 6 包含 JPA 2.0，Java EE 7 引入了 JPA 2.1）。</p><p>在 JPA 规范首次发布时，Hibernate 已经是一个功能齐全的 Java ORM 实现。尽管它实现了 JPA 规范，但 Hibernate 仍然保留了其原生 API，以实现向后兼容性并支持非标准功能。</p><p>尽管最好遵循 JPA 标准，但实际上，许多 JPA 提供程序都提供了针对高性能数据访问层需求的附加功能。为此，Hibernate 提供了以下非 JPA 兼容功能：</p><ul><li>扩展标识符生成器（hi/lo、pooled、pooled-lo）</li><li>透明的预编译语句批处理</li><li>可自定义的 CRUD（@SQLInsert、@SQLUpdate、@SQLDelete）语句</li><li>静态/动态实体/集合过滤器（例如 @FilterDef、@Filter、@Where）</li><li>将属性映射到 SQL 片段（例如 @Formula）</li><li>不可变实体（例如 @Immutable）</li><li>更多刷新模式（例如 FlushMode.MANUAL、FlushMode.ALWAYS）</li><li>通过给定实体的自然键查询二级缓存</li><li>实体级缓存并发策略（例如 Cache(usage = CacheConcurrencyStrategy.READ_WRITE)）</li><li>通过 HQL 进行版本化批量更新</li><li>从乐观锁检查中排除字段（例如 @OptimisticLock(excluded = true)）</li><li>无版本乐观锁（例如 OptimisticLockType.ALL、OptimisticLockType.DIRTY）</li><li>支持跳过（不等待）悲观锁请求</li><li>支持 Java 8 日期和时间以及 stream()</li><li>支持多租户</li></ul></div><!----><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="update-time"><span class="vp-meta-label">上次编辑于: </span><span class="vp-meta-info" data-allow-mismatch="text">2025/12/1 01:36:46</span></div><div class="contributors"><span class="vp-meta-label">贡献者: </span><!--[--><!--[--><span class="vp-meta-info" title="email: liangfenglam@163.com">RaymondLam1</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a class="route-link auto-link prev" href="/tech-week/2025/2025-06-24.html" aria-label="2025-06-24 Tech Time" iconsizing="both"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->2025-06-24 Tech Time</div></a><a class="route-link auto-link next" href="/tech-week/2025/%E5%A4%A7%E6%A8%A1%E5%9E%8B.html" aria-label="大模型" iconsizing="both"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">大模型<!----></div></a></nav><div id="comment" class="giscus-wrapper input-top vp-comment" vp-comment style="display:block;"><div style="display: flex;
align-items: center;
justify-content: center;
height: 96px"><span style="--loading-icon: url(&quot;data:image/svg+xml;utf8,%3Csvg xmlns=&#39;http://www.w3.org/2000/svg&#39; preserveAspectRatio=&#39;xMidYMid&#39; viewBox=&#39;25 25 50 50&#39;%3E%3CanimateTransform attributeName=&#39;transform&#39; type=&#39;rotate&#39; dur=&#39;2s&#39; keyTimes=&#39;0;1&#39; repeatCount=&#39;indefinite&#39; values=&#39;0;360&#39;%3E%3C/animateTransform%3E%3Ccircle cx=&#39;50&#39; cy=&#39;50&#39; r=&#39;20&#39; fill=&#39;none&#39; stroke=&#39;currentColor&#39; stroke-width=&#39;4&#39; stroke-linecap=&#39;round&#39;%3E%3Canimate attributeName=&#39;stroke-dasharray&#39; dur=&#39;1.5s&#39; keyTimes=&#39;0;0.5;1&#39; repeatCount=&#39;indefinite&#39; values=&#39;1,200;90,200;1,200&#39;%3E%3C/animate%3E%3Canimate attributeName=&#39;stroke-dashoffset&#39; dur=&#39;1.5s&#39; keyTimes=&#39;0;0.5;1&#39; repeatCount=&#39;indefinite&#39; values=&#39;0;-35px;-125px&#39;%3E%3C/animate%3E%3C/circle%3E%3C/svg%3E&quot;);
--icon-size: 48px;
display: inline-block;
width: var(--icon-size);
height: var(--icon-size);
background-color: currentcolor;
-webkit-mask-image: var(--loading-icon);
mask-image: var(--loading-icon);
"></span></div></div><!----><!--]--></main><!--]--><!----></div><!--]--><!--[--><!----><!--[--><!--]--><!--]--><!--]--></div>
    <script type="module" src="/assets/app-B5Vu5nrn.js" defer></script>
  </body>
</html>
