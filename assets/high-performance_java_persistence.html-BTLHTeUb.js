import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,e as i,o as p}from"./app-CJaVf8x8.js";const n="/assets/image-BP9yjLjw.png",r="/assets/image-1-CmsH8igx.png",s="/assets/image-2-NRIQMYGn.png",l="/assets/image-3-CxRzlUn1.png",c="/assets/image-4-3cqTWpX_.png",o={};function h(d,a){return p(),t("div",null,a[0]||(a[0]=[i('<h1 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h1><p>在企业系统中，设计合理的数据库访问层可以对整体应用程序性能产生重大影响。根据 AppDynamics3 的数据，超过一半的应用程序性能瓶颈源于数据库。数据分布在各种结构（表行、索引节点）中，数据库记录可以被多个并发用户读取和写入。从并发的角度来看，这是一个极具挑战性的任务，为了最大限度地发挥持久层的作用，数据访问逻辑必须与底层数据库系统相匹配。</p><figure><img src="'+n+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>典型的关系数据库管理系统（RDBMS）数据访问层需要掌握多种技术，而整个企业解决方案的强度取决于团队中最薄弱的技能。在深入到更高抽象层（例如对象关系映射（ORM）框架）之前，最好先攻克底层技术。</p><h2 id="数据库服务器和连接层" tabindex="-1"><a class="header-anchor" href="#数据库服务器和连接层"><span>数据库服务器和连接层</span></a></h2><p>数据库手册并非仅供数据库管理员使用。在不了解数据库工作原理的情况下与其交互，就像驾驶赛车却不接受任何驾驶培训一样。熟悉 SQL 标准和数据库特有的功能，能够决定应用程序的运行速度是高性能还是慢如蜗牛。对数据库可移植性的担忧可能会导致人们因为某些功能在不同数据库系统之间无法互换而放弃使用它们。实际上，数据库层运行缓慢的情况比将一个正在运行的系统移植到新的数据库解决方案更为常见。</p><p>所有数据访问框架都依赖 JDBC（Java 数据库连接）API 与数据库服务器通信。JDBC 提供了许多性能优化技术，旨在缩短事务响应时间并处理更多流量。因此，本书的第一部分专门介绍 JDBC 和数据库基础知识，涵盖数据库连接管理、语句批处理、结果集获取和数据库事务等主题。</p><h2 id="应用数据访问层" tabindex="-1"><a class="header-anchor" href="#应用数据访问层"><span>应用数据访问层</span></a></h2><p>许多企业应用场景中都证明了某些数据访问模式的有效性。Martin Fowler 的《企业应用架构模式》是每位企业应用开发人员的必读之作。除了对象关系映射 (ORM) 模式之外，大多数 ORM 框架还采用了诸如工作单元 (Unit of Work)、身份映射 (Identity Map)、延迟加载 (Lazy Loading)、嵌入值 (Embedded Value)、实体继承 (Entity Inheritance) 或乐观锁和悲观锁等技术。</p><h3 id="orm框架" tabindex="-1"><a class="header-anchor" href="#orm框架"><span>ORM框架</span></a></h3><p>ORM工具可以提升应用程序的开发速度，但其学习曲线无疑十分陡峭。要解决将关系数据与应用程序领域模型桥接起来的固有复杂性，唯一的方法就是完全理解所使用的ORM框架。</p><p>有时，即使是参考文档也可能不够，当遇到性能相关问题时，熟悉源代码是不可避免的。JPA（Java持久化API）在数据写入方面表现出色，因为所有DML（数据操作语言）语句都会在持久化模型更改时自动更新，从而加快迭代开发过程。</p><p>本书第二部分介绍了各种Hibernate特有的优化技术，例如标识符生成器、高效的实体获取、状态转换、应用程序级事务和实体缓存。</p><h3 id="本地查询构建框架" tabindex="-1"><a class="header-anchor" href="#本地查询构建框架"><span>本地查询构建框架</span></a></h3><p>JPA 和 Hibernate 从来不是用来替代 SQL 的，并且在任何非平凡的企业应用中，本地查询都是不可避免的。虽然 JPA 可以抽象 DML 语句和常见的实体检索查询，但在读取和处理数据时，没有什么可以胜过本地 SQL。</p><p>JPQL（Java 持久化查询语言）抽象了大多数关系型数据库支持的常见 SQL 语法。因此，JPQL 无法利用窗口函数、公共表表达式、派生表或 PIVOT。</p><p>与 JPA 不同，jOOQ（Java 面向对象查询）提供了类型安全的 API，它支持底层数据库系统提供的任何数据库特定查询功能。正如 Criteria API 在动态生成实体查询时能防止 SQL 注入攻击一样，jOOQ 在构建本地 SQL 语句时也提供了相同的安全保障。</p><p>因此，本书的第三部分是关于高级查询的。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>关于数据库性能基准测试</p><p>本书中穿插了一些基准测试，旨在展示特定性能优化带来的相对收益。基准测试结果始终取决于底层硬件、操作系统和数据库服务器配置、数据库大小以及并发模式。因此，绝对值不如相对优化收益重要。实际上，最相关的基准测试结果是针对实际生产系统进行的测试。</p><p>为了防止读者将不同数据库进行比较，并基于某些特定用例的基准测试得出错误的结论，数据库名称已进行混淆处理，分别以 DB_A、DB_B、DB_C 和 DB_D 表示。本书中使用的所有示例的源代码均可在 GitHub 上找到。</p></div><h1 id="jdbc-和数据库基础知识" tabindex="-1"><a class="header-anchor" href="#jdbc-和数据库基础知识"><span>JDBC 和数据库基础知识</span></a></h1><h1 id="_1-性能与扩展" tabindex="-1"><a class="header-anchor" href="#_1-性能与扩展"><span>1. 性能与扩展</span></a></h1><p>企业应用程序需要尽可能快速地存储和检索数据。在应用程序性能管理中，响应时间和吞吐量是两个最重要的指标。响应时间越短，应用程序的响应速度就越快。因此，响应时间是衡量性能的指标。扩展性是指在增加系统负载的同时保持较低的响应时间，因此，吞吐量是衡量可扩展性的指标。</p><p>1.1 响应时间和吞吐量</p><p>由于本书侧重于高性能数据访问，因此被测系统的边界位于事务管理器级别。</p><p>事务响应时间是指完成一个事务所需的时间，因此它包含以下时间段：</p><p>• 获取数据库连接的时间</p><p>• 通过网络发送所有数据库语句所需的时间</p><p>• 执行所有传入语句所需的时间</p><p>• 将结果集发送回数据库客户端所需的时间</p><p>• 在释放数据库连接之前，由于应用程序级计算而导致事务空闲的时间</p><figure><img src="'+r+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>吞吐量定义为完成传入负载的速率。在数据库上下文中，吞吐量可以计算为在给定时间间隔内执行的事务数量。</p><figure><img src="'+s+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>根据这个定义，我们可以得出结论：通过缩短事务执行时间，系统可以处理更多请求。</p><p>在单数据库连接测试中，测得的吞吐量将成为进一步基于并发性改进的基准。</p><figure><img src="'+l+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>理想情况下，如果系统呈线性扩展，增加数据库连接数将带来成比例的吞吐量提升。然而，由于数据库资源争用以及维护多个并发数据库会话间数据一致性的成本，相对吞吐量提升并非呈线性关系，而是呈曲线关系。通用可扩展性定律 (USL)¹ 可以近似表示最大相对吞吐量（系统容量）与负载生成器（数据库连接数）之间的关系。</p><figure><img src="'+c+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>• C - 给定并发级别的相对吞吐量增益<br> • α - 争用系数（数据处理例程的可串行化部分）<br> • β - 一致性系数（在所有并发数据库会话中保持一致性的成本）。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>在 PostgreSQL 9.2 版本之前，预编译语句的规划和编译完全在准备阶段完成，因此执行计划是在没有实际绑定参数值的情况下生成的。虽然这种策略旨在节省数据库资源，但它对数据倾斜非常敏感。从 PostgreSQL 9.2 版本开始，准备阶段仅解析和重写语句，而优化和规划阶段则延迟到执行阶段。这样，重写的语法树会根据实际绑定参数值进行优化，从而生成最优的执行计划。</p><p>对于单次执行，普通语句只需要一次数据库往返，而预编译语句则需要两次（一次准备请求和一次执行调用）。为了避免网络开销，默认情况下，JDBC PreparedStatement 会在一次数据库请求中完成准备和执行两个阶段。</p><p>客户端预编译语句必须至少运行 5 次，驱动程序才能将其转换为服务器端语句。默认执行次数由 prepareThreshold 参数指定，该参数可通过连接属性或驱动程序特定的 API 进行配置。</p><p>经过多次执行后，如果性能对绑定参数值不敏感，优化器可能会将执行计划转换为通用计划并缓存以供重用。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>MySQL 在准备语句时，MySQL 解析器会生成一个语法树，并通过解析机制对其进行进一步验证和预优化。该语法树会经历若干数据不敏感的转换，最终输出为一个永久树。自 MySQL 5.7.4a 起，所有永久转换（例如重连接顺序或子查询优化）都在准备阶段完成，因此执行阶段仅应用数据敏感的转换。MySQL 不缓存执行计划，因此每个语句的执行都会针对当前的绑定参数值进行优化，从而避免数据倾斜问题。</p><p>由于一些未解决的问题，自 5.0.5b 版本起，MySQL JDBC 驱动程序仅模拟服务器端预处理语句。要切换到服务器端预处理语句，必须将 useServerPrepStmts 和 cachePrepStmts 连接属性都设置为 true。</p><p>启用此功能之前，最好查看最新的 Connector/J 发行说明，并确认此功能可以安全使用。</p></div><h2 id="_4-4-客户端语句缓存" tabindex="-1"><a class="header-anchor" href="#_4-4-客户端语句缓存"><span>4.4 客户端语句缓存</span></a></h2>',42)]))}const f=e(o,[["render",h],["__file","high-performance_java_persistence.html.vue"]]),_=JSON.parse('{"path":"/tech-week/2025/high-performance_java_persistence.html","title":"Java 持久化","lang":"zh-CN","frontmatter":{"title":"Java 持久化","category":["技术"],"tag":["专栏"]},"headers":[{"level":2,"title":"数据库服务器和连接层","slug":"数据库服务器和连接层","link":"#数据库服务器和连接层","children":[]},{"level":2,"title":"应用数据访问层","slug":"应用数据访问层","link":"#应用数据访问层","children":[{"level":3,"title":"ORM框架","slug":"orm框架","link":"#orm框架","children":[]},{"level":3,"title":"本地查询构建框架","slug":"本地查询构建框架","link":"#本地查询构建框架","children":[]}]},{"level":2,"title":"4.4 客户端语句缓存","slug":"_4-4-客户端语句缓存","link":"#_4-4-客户端语句缓存","children":[]}],"git":{"createdTime":1762154451000,"updatedTime":1762842997000,"contributors":[{"name":"RaymondLam1","username":"RaymondLam1","email":"liangfenglam@163.com","commits":3,"url":"https://github.com/RaymondLam1"}]},"readingTime":{"minutes":8.45,"words":2534},"filePathRelative":"tech-week/2025/high-performance_java_persistence.md","localizedDate":"2025年11月3日","excerpt":"\\n<p>在企业系统中，设计合理的数据库访问层可以对整体应用程序性能产生重大影响。根据 AppDynamics3 的数据，超过一半的应用程序性能瓶颈源于数据库。数据分布在各种结构（表行、索引节点）中，数据库记录可以被多个并发用户读取和写入。从并发的角度来看，这是一个极具挑战性的任务，为了最大限度地发挥持久层的作用，数据访问逻辑必须与底层数据库系统相匹配。</p>\\n<figure><figcaption>alt text</figcaption></figure>\\n<p>典型的关系数据库管理系统（RDBMS）数据访问层需要掌握多种技术，而整个企业解决方案的强度取决于团队中最薄弱的技能。在深入到更高抽象层（例如对象关系映射（ORM）框架）之前，最好先攻克底层技术。</p>"}');export{f as comp,_ as data};
