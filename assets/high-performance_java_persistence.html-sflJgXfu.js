import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as p,e as a,o as i}from"./app-Bvg61dhW.js";const n="/assets/image-BP9yjLjw.png",r="/assets/image-1-CmsH8igx.png",s="/assets/image-2-NRIQMYGn.png",l="/assets/image-3-CxRzlUn1.png",o="/assets/image-4-3cqTWpX_.png",c="/assets/image-5-BgLuBFU3.png",d="/assets/image-6-DeODYfFW.png",h="/assets/image-7-CSsGn13z.png",S="/assets/image-8-CndHLqWi.png",_="/assets/image-9-BqeWTD1T.png",m={};function g(f,e){return i(),p("div",null,e[0]||(e[0]=[a('<h1 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h1><p>在企业系统中，设计合理的数据库访问层可以对整体应用程序性能产生重大影响。根据 AppDynamics3 的数据，超过一半的应用程序性能瓶颈源于数据库。数据分布在各种结构（表行、索引节点）中，数据库记录可以被多个并发用户读取和写入。从并发的角度来看，这是一个极具挑战性的任务，为了最大限度地发挥持久层的作用，数据访问逻辑必须与底层数据库系统相匹配。</p><figure><img src="'+n+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>典型的关系数据库管理系统（RDBMS）数据访问层需要掌握多种技术，而整个企业解决方案的强度取决于团队中最薄弱的技能。在深入到更高抽象层（例如对象关系映射（ORM）框架）之前，最好先攻克底层技术。</p><h2 id="数据库服务器和连接层" tabindex="-1"><a class="header-anchor" href="#数据库服务器和连接层"><span>数据库服务器和连接层</span></a></h2><p>数据库手册并非仅供数据库管理员使用。在不了解数据库工作原理的情况下与其交互，就像驾驶赛车却不接受任何驾驶培训一样。熟悉 SQL 标准和数据库特有的功能，能够决定应用程序的运行速度是高性能还是慢如蜗牛。对数据库可移植性的担忧可能会导致人们因为某些功能在不同数据库系统之间无法互换而放弃使用它们。实际上，数据库层运行缓慢的情况比将一个正在运行的系统移植到新的数据库解决方案更为常见。</p><p>所有数据访问框架都依赖 JDBC（Java 数据库连接）API 与数据库服务器通信。JDBC 提供了许多性能优化技术，旨在缩短事务响应时间并处理更多流量。因此，本书的第一部分专门介绍 JDBC 和数据库基础知识，涵盖数据库连接管理、语句批处理、结果集获取和数据库事务等主题。</p><h2 id="应用数据访问层" tabindex="-1"><a class="header-anchor" href="#应用数据访问层"><span>应用数据访问层</span></a></h2><p>许多企业应用场景中都证明了某些数据访问模式的有效性。Martin Fowler 的《企业应用架构模式》是每位企业应用开发人员的必读之作。除了对象关系映射 (ORM) 模式之外，大多数 ORM 框架还采用了诸如工作单元 (Unit of Work)、身份映射 (Identity Map)、延迟加载 (Lazy Loading)、嵌入值 (Embedded Value)、实体继承 (Entity Inheritance) 或乐观锁和悲观锁等技术。</p><h3 id="orm框架" tabindex="-1"><a class="header-anchor" href="#orm框架"><span>ORM框架</span></a></h3><p>ORM工具可以提升应用程序的开发速度，但其学习曲线无疑十分陡峭。要解决将关系数据与应用程序领域模型桥接起来的固有复杂性，唯一的方法就是完全理解所使用的ORM框架。</p><p>有时，即使是参考文档也可能不够，当遇到性能相关问题时，熟悉源代码是不可避免的。JPA（Java持久化API）在数据写入方面表现出色，因为所有DML（数据操作语言）语句都会在持久化模型更改时自动更新，从而加快迭代开发过程。</p><p>本书第二部分介绍了各种Hibernate特有的优化技术，例如标识符生成器、高效的实体获取、状态转换、应用程序级事务和实体缓存。</p><h3 id="本地查询构建框架" tabindex="-1"><a class="header-anchor" href="#本地查询构建框架"><span>本地查询构建框架</span></a></h3><p>JPA 和 Hibernate 从来不是用来替代 SQL 的，并且在任何非平凡的企业应用中，本地查询都是不可避免的。虽然 JPA 可以抽象 DML 语句和常见的实体检索查询，但在读取和处理数据时，没有什么可以胜过本地 SQL。</p><p>JPQL（Java 持久化查询语言）抽象了大多数关系型数据库支持的常见 SQL 语法。因此，JPQL 无法利用窗口函数、公共表表达式、派生表或 PIVOT。</p><p>与 JPA 不同，jOOQ（Java 面向对象查询）提供了类型安全的 API，它支持底层数据库系统提供的任何数据库特定查询功能。正如 Criteria API 在动态生成实体查询时能防止 SQL 注入攻击一样，jOOQ 在构建本地 SQL 语句时也提供了相同的安全保障。</p><p>因此，本书的第三部分是关于高级查询的。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>关于数据库性能基准测试</p><p>本书中穿插了一些基准测试，旨在展示特定性能优化带来的相对收益。基准测试结果始终取决于底层硬件、操作系统和数据库服务器配置、数据库大小以及并发模式。因此，绝对值不如相对优化收益重要。实际上，最相关的基准测试结果是针对实际生产系统进行的测试。</p><p>为了防止读者将不同数据库进行比较，并基于某些特定用例的基准测试得出错误的结论，数据库名称已进行混淆处理，分别以 DB_A、DB_B、DB_C 和 DB_D 表示。本书中使用的所有示例的源代码均可在 GitHub 上找到。</p></div><h1 id="jdbc-和数据库基础知识" tabindex="-1"><a class="header-anchor" href="#jdbc-和数据库基础知识"><span>JDBC 和数据库基础知识</span></a></h1><h1 id="_1-性能与扩展" tabindex="-1"><a class="header-anchor" href="#_1-性能与扩展"><span>1. 性能与扩展</span></a></h1><p>企业应用程序需要尽可能快速地存储和检索数据。在应用程序性能管理中，响应时间和吞吐量是两个最重要的指标。响应时间越短，应用程序的响应速度就越快。因此，响应时间是衡量性能的指标。扩展性是指在增加系统负载的同时保持较低的响应时间，因此，吞吐量是衡量可扩展性的指标。</p><p>1.1 响应时间和吞吐量</p><p>由于本书侧重于高性能数据访问，因此被测系统的边界位于事务管理器级别。</p><p>事务响应时间是指完成一个事务所需的时间，因此它包含以下时间段：</p><p>• 获取数据库连接的时间</p><p>• 通过网络发送所有数据库语句所需的时间</p><p>• 执行所有传入语句所需的时间</p><p>• 将结果集发送回数据库客户端所需的时间</p><p>• 在释放数据库连接之前，由于应用程序级计算而导致事务空闲的时间</p><figure><img src="'+r+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>吞吐量定义为完成传入负载的速率。在数据库上下文中，吞吐量可以计算为在给定时间间隔内执行的事务数量。</p><figure><img src="'+s+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>根据这个定义，我们可以得出结论：通过缩短事务执行时间，系统可以处理更多请求。</p><p>在单数据库连接测试中，测得的吞吐量将成为进一步基于并发性改进的基准。</p><figure><img src="'+l+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>理想情况下，如果系统呈线性扩展，增加数据库连接数将带来成比例的吞吐量提升。然而，由于数据库资源争用以及维护多个并发数据库会话间数据一致性的成本，相对吞吐量提升并非呈线性关系，而是呈曲线关系。通用可扩展性定律 (USL)¹ 可以近似表示最大相对吞吐量（系统容量）与负载生成器（数据库连接数）之间的关系。</p><figure><img src="'+o+`" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>• C - 给定并发级别的相对吞吐量增益<br> • α - 争用系数（数据处理例程的可串行化部分）<br> • β - 一致性系数（在所有并发数据库会话中保持一致性的成本）。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>在 PostgreSQL 9.2 版本之前，预编译语句的规划和编译完全在准备阶段完成，因此执行计划是在没有实际绑定参数值的情况下生成的。虽然这种策略旨在节省数据库资源，但它对数据倾斜非常敏感。从 PostgreSQL 9.2 版本开始，准备阶段仅解析和重写语句，而优化和规划阶段则延迟到执行阶段。这样，重写的语法树会根据实际绑定参数值进行优化，从而生成最优的执行计划。</p><p>对于单次执行，普通语句只需要一次数据库往返，而预编译语句则需要两次（一次准备请求和一次执行调用）。为了避免网络开销，默认情况下，JDBC PreparedStatement 会在一次数据库请求中完成准备和执行两个阶段。</p><p>客户端预编译语句必须至少运行 5 次，驱动程序才能将其转换为服务器端语句。默认执行次数由 prepareThreshold 参数指定，该参数可通过连接属性或驱动程序特定的 API 进行配置。</p><p>经过多次执行后，如果性能对绑定参数值不敏感，优化器可能会将执行计划转换为通用计划并缓存以供重用。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>MySQL 在准备语句时，MySQL 解析器会生成一个语法树，并通过解析机制对其进行进一步验证和预优化。该语法树会经历若干数据不敏感的转换，最终输出为一个永久树。自 MySQL 5.7.4a 起，所有永久转换（例如重连接顺序或子查询优化）都在准备阶段完成，因此执行阶段仅应用数据敏感的转换。MySQL 不缓存执行计划，因此每个语句的执行都会针对当前的绑定参数值进行优化，从而避免数据倾斜问题。</p><p>由于一些未解决的问题，自 5.0.5b 版本起，MySQL JDBC 驱动程序仅模拟服务器端预处理语句。要切换到服务器端预处理语句，必须将 useServerPrepStmts 和 cachePrepStmts 连接属性都设置为 true。</p><p>启用此功能之前，最好查看最新的 Connector/J 发行说明，并确认此功能可以安全使用。</p></div><h2 id="_4-4-客户端语句缓存" tabindex="-1"><a class="header-anchor" href="#_4-4-客户端语句缓存"><span>4.4 客户端语句缓存</span></a></h2><p>缓存语句不仅对数据库端有益，JDBC 驱动程序也可以重用已构建的语句对象。客户端语句缓存的主要目标可以概括如下：</p><p>• 减少客户端语句处理，从而缩短事务响应时间。<br> • 通过回收语句对象及其关联的数据库特定元数据来节省应用程序资源。</p><p>在高性能 OLTP 应用中，事务往往非常短，因此即使响应时间略有减少，也能对整体事务吞吐量产生影响。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Oracle 隐式语句缓存</p><p>与服务器端计划缓存不同，客户端缓存仅限于数据库连接。由于 SQL 字符串会成为缓存条目键，因此 PreparedStatement 和 CallableStatement 语句更容易被重用。因此，Oracle JDBC 驱动程序仅支持这两种语句类型的缓存。启用缓存（默认禁用）后，驱动程序会返回一个逻辑语句，因此当客户端关闭连接时，该逻辑语句会返回缓存。</p><p>从开发角度来看，存在隐式语句缓存机制以及显式缓存机制。两种缓存选项共享相同的驱动程序存储空间，需要根据当前应用程序的需求进行配置。</p><p>隐式缓存只能存储语句元数据，这些元数据在每次执行之间不会改变。虽然可以为每个连接单独设置，但在数据源级别进行配置更为方便（所有连接继承相同的缓存属性）。</p><p>connectionProperties.put(&quot;oracle.jdbc.implicitStatementCacheSize&quot;, Integer.toString(cacheSize));<br> dataSource.setConnectionProperties(connectionProperties);</p><p>设置 implicitStatementCacheSize 也会启用缓存。默认情况下，所有正在执行的语句都会被隐式缓存，但这可能并非理想之选（某些偶尔执行的查询可能会清除其他频繁执行的语句）。为了控制语句缓存策略，JDBC 定义了 isPoolable() 和 setPoolable(boolean poolable) 语句方法：</p><p>if (statement.isPoolable()) {<br> statement.setPoolable(false);<br> }</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Oracle 显式语句缓存</p><p>显式缓存是可配置的，并通过 Oracle 特定的 API 管理。在使用它之前，必须使用底层的 OracleConnection 引用启用并调整其大小。</p><pre><code>    OracleConnection oracleConnection = (OracleConnection) connection;
    oracleConnection.setExplicitCachingEnabled(true);
    oracleConnection.setStatementCacheSize(cacheSize);
</code></pre><p>在使用显式缓存时，数据访问会控制哪些语句可以被缓存，因此不再需要使用 setPoolable(boolean poolable) 方法。以下示例演示了如何利用显式缓存机制。</p><pre><code>    PreparedStatement statement = oracleConnection
            .getStatementWithKey(SELECT_POST_REVIEWS_KEY);
    if (statement == null)
        statement = connection.prepareStatement(SELECT_POST_REVIEWS);
    try {
        statement.setInt(1, 10);
        statement.execute();
    } finally {
        ((OraclePreparedStatement) statement).closeWithKey(SELECT_POST_REVIEWS_KEY);
    }
</code></pre><p>显式缓存依赖于两种主要操作，可以总结如下：</p><ol><li>getStatementWithKey(String key) 方法从缓存中加载语句。如果未找到条目，则必须使用标准 JDBC API 手动创建 PreparedStatement</li><li>closeWithKey(String key) 方法将语句推回到池中。</li></ol><p>特定于供应商的 API 将数据访问代码与 Oracle 特定的 API 绑定，这会阻碍可移植性，并且在兼容多种数据库系统时需要更复杂的数据访问逻辑。</p><p>除了缓存元数据之外，显式缓存还存储执行状态和数据。尽管重用更多的客户端构造可能进一步提高性能，但这种策略存在将先前和当前执行上下文混合的风险，因此建议谨慎使用。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>SQL Server</p><p>虽然 Microsoft SQL Server JDBC 驱动程序定义了 disableStatementPooling 属性，但截至撰写本文时（4.2 版本），语句缓存无法启用。另一方面，jTDS（开源的 JDBC 3.0 实现）提供基于每个连接的语句缓存。作为 JDBC 4.0 特定的 API，setPoolable(boolean poolable) Statement 方法在 1.3.1 版本的 jTDS 中未实现。缓存的默认大小为 500 条目，也可以调整。</p><pre><code>    ((JtdsDataSource) dataSource).setMaxStatements(cacheSize);
</code></pre><p>即便 jTDS 一直专注于性能，与 Microsoft 驱动程序相比，缺乏稳定的发布计划仍是一个主要缺点。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>PostgreSQL</p><p>自 PostgreSQL JDBC 驱动 9.4-1202a 版本起，客户端的语句会被缓存，并且其关联的服务器端语句键即使在初始 PreparedStatement 关闭后也会被保留。只要当前连接缓存中包含指定的 SQL 语句，客户端的 PreparedStatement 和服务器端对象都可以被重用。setPoolable(boolean poolable) 方法无效，并且无法在每个语句的基础上禁用缓存。语句缓存由以下连接属性控制：• preparedStatementCacheQueries - 每个数据库连接缓存的语句数量。值为 0 时禁用缓存，并且在 PreparedStatement 关闭后，服务器端准备语句将不再可用。默认值为 256。• preparedStatementCacheSizeMiB - 语句缓存有上限内存，默认值为 5 MB。值为 0 时禁用缓存。这些属性既可以作为连接参数设置，也可以作为 DataSource 属性设置：</p><pre><code>    ((PGSimpleDataSource) dataSource).setPreparedStatementCacheQueries(cacheSize);
    ((PGSimpleDataSource) dataSource).setPreparedStatementCacheSizeMiB(cacheSizeMb);
</code></pre></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>MySQL</p><p>语句缓存与数据库连接相关，并适用于所有正在执行的语句。在 5.1.36 版本的 Connector/J 驱动程序中，setPoolable(boolean poolable) 方法只能禁用服务器端语句的缓存，客户端语句不受此设置影响。客户端语句缓存可以使用以下属性进行配置：<br> • cachePrepStmts - 启用客户端语句缓存以及服务器端语句有效性检查。默认情况下，语句缓存是禁用的。<br> • prepStmtCacheSize - 为每个数据库连接缓存的语句数量。默认缓存大小为 25。• prepStmtCacheSqlLimit - 允许缓存的 SQL 语句的最大长度。默认最大值为 256。</p><p>这些属性既可以作为连接参数设置，也可以在 DataSource 级别设置：</p><pre><code>    ((MysqlDataSource) dataSource).setCachePrepStmts(true);
    ((MysqlDataSource) dataSource).setPreparedStatementCacheSize(cacheSize);
    ((MysqlDataSource) dataSource).setPreparedStatementCacheSqlLimit(maxLength);
</code></pre></div><h1 id="_5-结果集获取" tabindex="-1"><a class="header-anchor" href="#_5-结果集获取"><span>5 结果集获取</span></a></h1><p>在讨论了 SQL 语句优化（批处理和缓存）之后，现在是时候关注查询处理的响应部分了。与仅返回受影响行数的 INSERT、UPDATE 和 DELETE 语句不同，JDBC SELECT 查询返回的是一个 ResultSet。</p><p>数据库执行器接收执行计划并将数据提取到结果集中。行可以一次性提取，也可以在数据库客户端请求时提取。</p><p>SQL 标准通过以下属性定义了结果集和游标描述符：</p><p>• 可滚动性（结果集的迭代方向）</p><p>• 敏感性（何时提取数据）</p><p>• 可更新性（适用于游标，允许客户端在遍历结果集时修改记录）</p><p>• 可持有性（结果集在事务生命周期中的作用范围）。</p><p>遵循标准规范，JDBC ResultSet 支持以上所有属性。</p><table><thead><tr><th>属性名称</th><th>描述</th></tr></thead><tbody><tr><td>TYPE_FORWARD_ONLY</td><td>结果集只能从第一个元素到最后一个元素进行迭代。这是默认的滚动性值。</td></tr><tr><td>TYPE_SCROLL_INSENSITIVE</td><td>结果集在加载时会生成一个快照，可以向前和向后迭代。</td></tr><tr><td>TYPE_SCROLL_SENSITIVE</td><td>结果集在迭代过程中按需获取，没有任何方向限制。</td></tr><tr><td>CONCUR_READ_ONLY</td><td>结果集只是一个静态数据投影，不允许行级操作。这是默认的可更改性值。</td></tr><tr><td>CONCUR_UPDATABLE</td><td>可以使用光标位置更新或删除记录，甚至插入新记录。</td></tr><tr><td>CLOSE_CURSORS_AT_COMMIT</td><td>当当前事务结束时，结果集将被关闭。</td></tr><tr><td>HOLD_CURSORS_OVER_COMMIT</td><td>即使当前事务已提交，结果集仍保持打开状态。</td></tr></tbody></table><h2 id="_5-1-结果集的可滚动性" tabindex="-1"><a class="header-anchor" href="#_5-1-结果集的可滚动性"><span>5.1 结果集的可滚动性</span></a></h2><p>JDBC 结果集可以使用应用程序级游标进行遍历。因此，数据获取机制隐藏在迭代器 API 之后，从而将应用程序代码与数据检索策略解耦。一些数据库驱动程序会在客户端预取整个结果集，而其他实现则会按需检索一批数据。</p><p>默认情况下，结果集使用仅向前遍历的应用程序级游标，该游标只能从第一个位置遍历到最后一个位置一次。虽然这对于大多数应用程序来说已经足够，但 JDBC 也提供了可滚动游标，因此允许行级指针自由定位（可以沿任意方向遍历每个记录）。</p><p>两种可滚动结果集的主要区别在于它们的选择性。不敏感游标提供当前结果集的静态视图，因此数据需要在迭代之前完全获取。敏感游标允许动态获取结果集，以便反映并发更改。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Oracle</p><p>由于数据库引擎不支持可滚动结果集，JDBC 驱动程序通过客户端缓存机制模拟滚动结果集。因此，结果集不宜过大，否则很容易耗尽客户端应用程序的内存。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>SQL Server</p><p>支持所有三种游标类型。不敏感滚动会生成服务器端数据库快照，客户端分批获取该快照。敏感滚动使用服务器端可更新窗口，并且仅在当前处理窗口内同步更改。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>PostgreSQL<br> 默认情况下，结果集会被完整获取并缓存在客户端。仅支持前向滚动和不敏感滚动。对于大型结果集，一次性获取所有记录可能会给数据库服务器资源和客户端内存带来巨大压力。为此，PostgreSQL 允许将结果集与数据库游标关联，以便按需获取记录。</p><p>PreparedStatement statement = connection.prepareStatement(</p><p>&quot;SELECT title FROM post WHERE id BETWEEN ? AND ?&quot;</p><p>);</p><p>statement.setFetchSize(100);</p><p>只有前向只读结果集类型才能利用数据库端游标，并且语句提取大小必须设置为正整数值。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>MySQL<br> 即使显式指定了前向只读结果集，也仅支持不敏感滚动类型。默认情况下，驱动程序会检索整个结果集并将其缓存在客户端。</p><p>如果语句类型同时是前向只读和只读，并且提取大小值设置为 Integer.MIN_VALUE，则可以流式传输大型结果集。这样，在迭代结果集时，每一行都会被单独提取，这可能会导致多次数据库往返。此外，在流关闭之前，连接无法执行任何其他语句。</p><p>PreparedStatement statement = connection.prepareStatement(</p><p>“SELECT title FROM post WHERE id BETWEEN ?” AND ?”</p><p>);</p><p>statement.setFetchSize(Integer.MIN_VALUE);</p><p>另一种方法是将 useCursorFetchb Connection 属性设置为 true，然后将 Statement 的提取大小设置为一个正整数值，表示一次需要提取的记录数。</p><p>statement.setFetchSize(100);</p></div><h2 id="_5-2-结果集的可变更性" tabindex="-1"><a class="header-anchor" href="#_5-2-结果集的可变更性"><span>5.2 结果集的可变更性</span></a></h2><p>默认情况下，结果集只是底层数据投影的只读视图。受数据库游标的启发，JDBC 标准提供了可更新的结果集，因此数据访问逻辑可以在迭代应用程序级游标的同时修改记录。</p><p>将读取和写入逻辑混合到单个数据库事务中，让人联想到两层架构，在两层架构中，即使在用户思考时间内持有结果集也是常见且可以接受的。</p><p>对于 Web 应用程序，请求应该尽可能短，并且大多数应用程序级事务跨越多个 Web 请求。前一个请求可能使用只读数据库事务来获取数据并将其呈现给用户，而后一个请求可能使用读写事务来应用数据修改。在这种情况下，可更新的结果集几乎没有用处，尤其是在多个请求中保持其打开状态（以及底层数据库连接）会严重影响应用程序的可扩展性。</p><p>以下测试用例验证了只读且仅向前的游标是否比敏感且可更新的游标性能更好。该测试执行 10000 条语句，获取 100 篇帖子及其详细信息和 1000 条相关评论。</p><figure><img src="`+c+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>所有受测数据库系统在使用仅前向和只读结果集时均表现出轻微的性能提升。</p><h2 id="_5-3-结果集保持性" tabindex="-1"><a class="header-anchor" href="#_5-3-结果集保持性"><span>5.3 结果集保持性</span></a></h2><p>JDBC 3.0 版本增加了对结果集保持性的支持，与滚动性和更新性不同，其默认值取决于具体的实现。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Oracle<br> 默认且唯一支持的保持性值为 HOLD_CURSORS_OVER_COMMIT。尝试将此设置更改为任何其他值都会引发异常。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>SQL Server<br> 默认情况下，即使当前事务已提交或回滚，结果集仍保持打开状态。SQL Server 也支持 CLOSE_CURSORS_AT_COMMIT 设置。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>PostgreSQL<br> 与其他数据库系统不同，其默认保持性值为 CLOSE_CURSORS_AT_COMMIT，但驱动程序也支持 HOLD_CURSORS_OVER_COMMIT 设置。</p></div><p>:::<br> MySQL<br> 默认且唯一支持的保持性值为 HOLD_CURSORS_OVER_COMMIT。</p><p>在典型的企业应用中，数据库连接会在事务之间重复使用，因此在事务结束后保留​​结果集存在风险。根据底层数据库系统和游标类型的不同，结果集可能会占用系统资源，出于可扩展性的考虑，这些资源需要尽快释放。</p><p>虽然并非所有数据库引擎都支持 <code>CLOSE_CURSORS_AT_COMMIT</code> 选项，但只需关闭所有已获取的结果集及其关联的 <code>Statement</code> 对象即可达到相同的效果。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><h2 id="_5-4-提取大小" tabindex="-1"><a class="header-anchor" href="#_5-4-提取大小"><span>5.4 提取大小</span></a></h2><p>JDBC ResultSet 充当应用程序级游标，因此每次遍历语句时，结果都必须从数据库传输到客户端。传输速率由语句提取大小控制。</p><p>statement.setFetchSize(fetchSize);</p><p>自定义提取大小可以提示驱动程序在单次数据库往返中需要检索的行数。</p><p>默认值为 0，这意味着每个数据库都可以选择其驱动程序特定的提取策略。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Oracle</p><p>由于 JDBC 驱动程序的内存模型，默认提取大小设置为 10 条记录。Oracle 10i 和 11g 驱动程序在语句创建时预分配一个 byte[] 和一个 char[] 缓冲区，其长度由提取大小乘以每个选定列的最大内存占用量得出。VARCHAR2(N) 列最多可以容纳 N 个字节。将最大长度为 5 个字符的字段存储到 VARCHAR2(4000) 列中会在客户端预分配 4000 字节，这无疑会浪费内存。</p><p>通过重用现有缓冲区来避免内存分配，是采用语句缓存的一个非常重要的理由。只有在使用隐式语句缓存时，10i 和 11g 驱动程序才能从回收客户端内存缓冲区中获益。</p><p>12c 实现将缓冲区分配延迟到结果集准备好进行提取时。此驱动程序版本使用两个 byte[] 数组，并采用延迟分配的方式。与之前的版本相比，12c 的内存占用大大减少，因为驱动程序不再分配最大可能的数据存储空间，而是使用实际提取的数据大小。</p><p>尽管最佳提取大小取决于应用程序，并受数据大小和运行时环境并发拓扑结构的影响，但 Oracle JDBC 驱动程序规范建议将提取大小限制在最多 100 条记录。与其他任何性能优化一样，这些建议充其量只是参考，衡量应用程序性能才是找到合适提取大小的唯一可行方法。</p></div></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>SQL Server</p><p>SQL Server JDBC 驱动程序使用自适应缓冲，因此结果集会根据需要分批提取。因此，批次大小由驱动程序自动控制。</p><p>虽然默认情况下启用自适应缓冲，但它仅限于只读和前向游标。可滚动和可更新的结果集都基于单个数据块进行操作，该数据块的长度由当前语句的提取大小决定。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>PostgreSQL</p><p>整个结果集一次性加载到客户端内存中。默认的加载大小只需要一次数据库往返，但会增加驱动程序的内存消耗。通过更改加载大小，结果集会与数据库游标关联，从而允许按需加载数据。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>MySQL<br> 由于网络协议设计方面的考虑，加载整个结果集是最有效的数据检索策略。唯一的流式选项需要一次处理一行，数据库往返次数由预读缓冲区配置决定。</p></div><p>下图展示了四个数据库系统在加载 10,000 行数据时，随着只前进（forward-only）和只读(read-only)结果集加载大小的变化，响应时间的变化情况。</p><figure><img src="'+d+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>一次加载一行需要 10,000 次往返，网络开销会影响响应时间。最多 100 行时，提取大小在降低检索时间方面起着重要作用（只需 100 次往返），但超过这个点后，收益就不那么明显了。</p><h2 id="_5-5-结果集大小" tabindex="-1"><a class="header-anchor" href="#_5-5-结果集大小"><span>5.5 结果集大小</span></a></h2><p>设置合适的提取大小无疑可以加快结果集检索速度，前提是语句仅提取当前业务逻辑所需的数据。然而，不幸的是，尤其是在 ORM 工具广泛应用的情况下，语句经常会选择超出实际需要的数据。这个问题可能是由于选择了过多的行或列造成的，而这些数据随后会在数据访问层或业务层被丢弃。</p><p>5.5.1 行数过多</p><p>表往往会不断增长（尤其是在应用程序获得更多用户之后），随着时间的推移，即使是适中的结果集也可能很容易成为性能瓶颈。这些问题通常在生产系统中被发现，而此时应用程序代码早已发布。</p><p>用户界面能够容纳的信息量取决于视图允许显示的信息量。因此，如果结果集无法容纳在用户界面中，则提取整个结果集是低效的。分页或动态滚动是解决此问题的常用方法，而对数据集进行分区则变得不可避免。</p><p>限制结果集在批处理中也很常见。为了避免长时间运行的事务（这可能会给数据库的撤销/重做日志带来压力），并利用并行执行的优势，批处理处理器会将当前工作负载拆分成更小的作业。这样，一个批处理作业只需处理整个数据的一部分即可。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>当结果集大小受外部因素限制时，选择超出实际需要的数据是没有意义的。</p><p>如果不设置上限，结果集会随着底层表数据量成比例增长。庞大的结果集需要更多的时间来提取和传输。</p><p>因此，限制查询可以确保可预测的响应时间和数据库资源利用率。查询处理时间越短，行级锁释放得越快，数据访问层的可扩展性就越强。</p></div><p>限制结果集大小的方法主要有两种。</p><p>第一种也是最有效的策略是在 SQL 语句中包含行限制子句。这样，优化器就能更好地针对当前结果集大小生成最优执行计划（例如，选择索引扫描而不是表扫描）。</p><p>第二种方法是在 JDBC 语句级别配置最大行数。理想情况下，驱动程序可以调整语句，使其包含等效的结果集大小限制（作为 SQL 子句），但大多数情况下，它只是提示数据库引擎使用数据库游标。</p><h4 id="_5-5-1-1-sql-limit-子句" tabindex="-1"><a class="header-anchor" href="#_5-5-1-1-sql-limit-子句"><span>5.5.1.1 SQL LIMIT 子句</span></a></h4><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>SQL:2008</p><p>虽然 SQL:2008 增加了对限制结果集大小的支持，但只有从 Oracle 12ca、SQL Server 2012b 和 PostgreSQL 8.4c 开始才支持标准语法。</p><p>SELECT <a href="http://pc.id" target="_blank" rel="noopener noreferrer">pc.id</a> AS pc_id, p.title AS p_title</p><p>FROM post_comment pc</p><p>INNER JOIN post p ON <a href="http://p.id" target="_blank" rel="noopener noreferrer">p.id</a> = pc.post_id</p><p>ORDER BY pc_id</p><p>OFFSET ? ROWS</p><p>FETCH FIRST (?) ROWS ONLY</p><p>在 PostgreSQL 数据库中，用括号括起行数占位符是一种变通方法。在 SQL Server 中，无论是否使用括号，此方法都有效。</p><p>较旧的数据库版本或其他数据库系统（例如 MySQL 5.7）仍然依赖于特定于供应商的语法来限制结果集的大小。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Oracle</p><p>与其他关系型数据库不同，Oracle 没有用于限制查询结果集的保留关键字，但由于每条记录都分配有一个结果集条目顺序号（由 ROWNUM 虚拟列提供），因此限制结果集的语法如下：</p><p>SELECT *<br> FROM (<br> SELECT <a href="http://pc.id" target="_blank" rel="noopener noreferrer">pc.id</a> AS pc_id, p.title AS p_title<br> FROM post_comment pc<br> INNER JOIN post p ON <a href="http://p.id" target="_blank" rel="noopener noreferrer">p.id</a> = pc.post_id<br> ORDER BY pc_id<br> )<br> WHERE ROWNUM &lt;= ?</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>SQL Server</p><p>TOP 关键字一直是限制结果集大小的事实标准方法：</p><p>SELECT TOP (?) <a href="http://pc.id" target="_blank" rel="noopener noreferrer">pc.id</a> AS pc_id, p.title AS p_title<br> FROM post_comment pc<br> INNER JOIN post p ON <a href="http://p.id" target="_blank" rel="noopener noreferrer">p.id</a> = pc.post_id<br> ORDER BY pc_id</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>PostgreSQL 和 MySQL</p><p>LIMIT 关键字用于限制结果集的大小上限：</p><p>SELECT <a href="http://pc.id" target="_blank" rel="noopener noreferrer">pc.id</a> AS pc_id, p.title AS p_title<br> FROM post_comment pc<br> INNER JOIN post p ON <a href="http://p.id" target="_blank" rel="noopener noreferrer">p.id</a> = pc.post_id<br> ORDER BY pc_id<br> LIMIT ?</p></div><h4 id="_5-5-1-2-jdbc-最大行数" tabindex="-1"><a class="header-anchor" href="#_5-5-1-2-jdbc-最大行数"><span>5.5.1.2 JDBC 最大行数</span></a></h4><p>JDBC 规范定义了 <code>maxRows</code> 属性，用于限制当前语句的所有结果集 (ResultSet) 的数量。</p><p><code>statement.setMaxRows(maxRows);</code></p><p>与 SQL 构造不同，JDBC 的这种替代方案可以在所有驱动程序实现之间移植。</p><p>这在应用程序需要支持多个数据库系统时尤其方便。</p><p>根据 JDBC 文档，当达到最大阈值时，驱动程序应该丢弃多余的行。</p><p>从数据访问性能的角度来看，丢弃多余的行是一种糟糕的策略，因为它会浪费数据库资源（CPU、I/O、内存）以及网络带宽。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Oracle</p><p>当遍历 ResultSet 时，客户端游标会分块提取数据（fetch size 属性控制每个块中的记录数）。</p><p>每次新的批次检索后，系统会检查记录总数是否超过 maxRows 上限。如果达到该阈值，驱动程序将关闭网络流。</p><p>因此，maxRows 上限可以防止数据库和客户端驱动程序浪费资源来提取客户端不需要的记录。但是，如果 maxRows 值较小，当扫描的数据集较大时，优化器将不会使用索引。</p><p>SQL Server</p><p>当调用 Statement.setMaxRows(int maxRows) 方法时，驱动程序会调用 SET ROWCOUNT SQL 命令：</p><p>SET ROWCOUNT N</p><p>与 TOP 或 FETCH SQL 指令不同，ROWCOUNT 命令仅在执行阶段生效，不会影响执行计划的生成。因此，执行计划可能并未针对给定的结果集大小进行优化，所以可能会选择表扫描而不是索引。</p><p>SQL Server 文档建议使用 SQL 指令而不是 SET ROWCOUNT 命令。</p><p>PostgreSQL</p><p>JDBC 驱动程序会获取 maxRows 语句属性并将其与正在执行的查询一起发送。有了此信息，优化器可以选择一个针对给定结果集大小的执行计划，甚至可以避免一些耗时的操作，例如对整个投影进行排序。提取器也可以在提取所需数量的记录后立即关闭数据库游标，从而节省数据库和网络资源。</p><p>MySQL<br> maxRows 属性不会发送到数据库服务器，因此优化器和提取器都无法从中受益。虽然 JDBC 驱动程序通常会提取所有行，但通过设置结果集大小的上限，客户端可以节省一些网络开销。</p></div><h4 id="_5-5-1-3-少即是多" tabindex="-1"><a class="header-anchor" href="#_5-5-1-3-少即是多"><span>5.5.1.3 少即是多</span></a></h4><p>以下测试将演示限制结果集大小对性能的提升。测试数据集包含 10 万条帖子和 100 万条评论。在第一轮测试中，系统会获取整个结果集，响应时间与结果集的大小成正比。通过将结果集限制为 100 条记录（无论是使用 SQL 还是 JDBC 的 maxRows 设置），响应时间将显著降低。</p><figure><img src="'+h+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>测试结果证实了之前的假设，SQL 层限制被证明是限制结果集的最佳策略。maxRows 驱动程序的实现效果出乎意料地好，尤其是在考虑到 JDBC 规范中关于丢弃多余记录的规定时。获取大型结果集会给数据库资源带来巨大压力，这不仅会影响当前工作单元的处理时间，还会导致其他并发事务的处理时间延长，这是由于数据库资源不足造成的。</p><h3 id="_5-5-2-列数过多" tabindex="-1"><a class="header-anchor" href="#_5-5-2-列数过多"><span>5.5.2 列数过多</span></a></h3><p>获取过多行不仅会导致性能问题，提取过多列也会增加结果集的处理响应时间。下一个测试用例将使用以下两个语句之一，选择 100 篇帖子及其关联的 1000 条评论：</p><p>SELECT *<br> FROM post_comment pc<br> INNER JOIN post p ON <a href="http://p.id" target="_blank" rel="noopener noreferrer">p.id</a> = pc.post_id<br> INNER JOIN post_details pd ON <a href="http://p.id" target="_blank" rel="noopener noreferrer">p.id</a> = <a href="http://pd.id" target="_blank" rel="noopener noreferrer">pd.id</a></p><p>SELECT pc.version<br> FROM post_comment pc<br> INNER JOIN post p ON <a href="http://p.id" target="_blank" rel="noopener noreferrer">p.id</a> = pc.post_id<br> INNER JOIN post_details pd ON <a href="http://p.id" target="_blank" rel="noopener noreferrer">p.id</a> = <a href="http://pd.id" target="_blank" rel="noopener noreferrer">pd.id</a></p><p>下图展示了获取所有列与仅提取部分列投影的执行时间对比。</p><figure><img src="'+S+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>这种情况在 ORM 工具中更为常见，因为要完整填充实体，需要选择所有列。如果只选择少量实体，这可能不会造成明显影响，但对于大型结果集，这可能会演变成一个显著的性能问题。</p><p>如果业务需求仅需实体属性的子集，则获取额外的列将浪费数据库和应用程序资源（CPU、内存、I/O、网络）。</p><h1 id="_6-事务" tabindex="-1"><a class="header-anchor" href="#_6-事务"><span>6. 事务</span></a></h1><p>数据库系统必须允许对底层数据进行并发访问。然而，共享数据意味着读写操作必须同步，以确保数据完整性不受影响。</p><p>为了控制并发修改，Java 编程语言定义了 synchronized 关键字，其用途有二：</p><p>• 它可以限制对共享对象的访问（以保持不变性），从而确保在任何给定时间只有一个线程可以执行某个例程。</p><p>• 它将当前线程本地内存中的更改传播到所有正在运行的线程都可以访问的全局内存。</p><p>这种行为在其他并发编程环境中很常见，数据库系统也不例外。在关系数据库中，确保数据完整性的机制是在事务之上实现的。</p><p>事务是一组读写操作的集合，这些操作可以作为一个整体同时成功或失败。所有数据库语句都必须在事务上下文中执行，即使数据库客户端没有显式定义事务边界。</p><p>1981 年，Jim Gray 在他著名的论文《事务概念：优点和局限性》中首次定义了数据库事务的属性。这篇论文以及 SQL 标准的早期版本（SQL-86 和 SQL-89）都只使用了三个属性来定义数据库事务：原子性、一致性和持久性。</p><p>此后，事务研究以及其他关系数据库主题的研究一直在持续进行，因此 SQL-92 版本引入了隔离级别（IL）的概念。这四个特性被组合成著名的 ACID（原子性、一致性、隔离性和持久性）缩写，并很快成为关系数据库事务的代名词。</p><p>了解数据库事务的工作原理非常重要，原因有二：</p><ul><li>有效的数据访问（在追求高性能的同时，不应牺牲数据完整性）</li></ul><p>• 高效的数据访问（减少争用可以最大限度地缩短事务响应时间，从而提高吞吐量）。</p><p>接下来的章节将详细介绍与高性能数据处理相关的各项事务属性。</p><h2 id="_6-1-原子性" tabindex="-1"><a class="header-anchor" href="#_6-1-原子性"><span>6.1 原子性</span></a></h2><p>原子性是指将多个操作组合成一个要么全部成功要么全部失败的工作单元的特性，只有当所有单独的操作都成功时，该工作单元才能成功。因此，数据库必须能够回滚与每个已执行语句关联的所有操作。</p><figure><img src="'+_+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>写-写冲突</p><p>理想情况下，每个事务都应该有一个完全隔离的分支，以便在回滚时可以轻松丢弃。这类似于版本控制系统（例如 Git）实现分支的方式。如果发生冲突，虚拟控制系统会中止提交操作，客户端必须手动解决冲突。与版本控制系统工具不同，关系数据库引擎必须在没有任何人工干预的情况下管理冲突。</p><p>因此，数据库会防止写-写冲突，并且在任何给定时间只能有一个事务写入记录。</p></div><p>所有语句均针对实际数据结构（表、索引、内存缓冲区）执行，仅在提交时才实际生效。如果发生回滚，数据库必须将所有待处理的已更改数据还原到之前的状态。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Oracle</p><p>撤销表空间将先前的数据版本存储在撤销段中。回滚时，数据库引擎会搜索关联的撤销段，以恢复当前运行事务所更改的每个数据的先前映像。</p><p>SQL Server</p><p>事务日志存储有关当前运行事务及其关联修改的详细信息。回滚过程会向后扫描事务日志以查找关联的撤销记录。找到记录后，数据库引擎会恢复受影响数据的先前映像。</p><p>为防止事务日志被填满，必须定期截断日志。长时间运行的事务会延迟截断过程，因此这也是应尽可能避免长时间运行事务的另一个原因。</p><p>PostgreSQL<br> 与其他数据库系统不同，PostgreSQL 不使用专用的仅追加撤销日志。由于其多版本特性，每个数据库对象都维护着自己的版本历史记录。由于没有日志查找阶段，回滚过程变得更加轻量级，因为它只需要从一个版本切换到另一个版本。</p><p>缺点是旧版本占用的空间大小有限，因此必须重复利用。回收旧版本占用存储空间的过程称为 VACUUM 清理。</p><p>每个事务都有一个关联的 XIDa，新事务的 XID 必须大于所有先前事务的 XID。</p><p>事务 XID 是一个 32 位数字，因此可以容纳超过 40 亿个事务。在高性能应用程序中，事务的生命周期非常短，如果禁用 VACUUM 清理，则可能会达到此阈值。当 XID 计数器达到其最大值时，它会循环并从零重新开始计数。</p><p>在 XID 回绕之前发起的事务的标识符大于 XID 计数器重置之后发起的新事务的标识符。这种异常情况会导致系统将较旧的事务视为未来发起的事务，从而导致非常严重的数据完整性问题。</p><p>MySQL<br> 撤销日志存储在系统表空间的回滚段中。</p><p>每个撤销日志分为两个部分，一部分用于回滚，另一部分用于重建回滚前的映像。事务结束后，第一部分可以立即清除，而第二部分则需要保留一段时间，直到当前正在运行的查询或其他并发事务需要查看相关记录的先前版本为止。</p><p>在后台，MySQL 会运行一个清除进程，清理已删除记录占用的存储空间，并回收不再需要的撤销日志段。</p><p>长时间运行的事务会延迟清除过程的执行，导致撤销日志变得非常大，尤其是在写入密集型数据访问场景中。</p></div><h2 id="_6-2-一致性" tabindex="-1"><a class="header-anchor" href="#_6-2-一致性"><span>6.2 一致性</span></a></h2><p>修改事务可以看作是一种状态转换，它将数据库从一个有效状态转移到另一个有效状态。关系数据库模式确保所有主要修改（插入/更新/删除语句）以及次要修改（由触发器发出）都遵循底层数据结构的特定规则：</p><ul><li>列类型</li><li>列长度</li><li>列是否允许为空</li><li>外键约束</li><li>唯一键约束</li><li>自定义检查约束。</li></ul><p>一致性是指验证事务状态的变更，确保所有已提交的事务离开数据库时都处于正确的状态。如果违反了任何约束，整个事务将被回滚，所有修改都将被还原。</p><p>虽然应用程序必须在编写数据库语句之前验证用户输入，但应用程序级别的检查无法跨越其他并发请求，这些请求可能来自不同的 Web 服务器。当数据库是主要集成点时，严格模式的优势就更加明显了。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>MySQL</p><p>传统上，MySQL 的约束并非严格执行，数据库引擎会将无效值替换为预定义的默认值：</p><ul><li>超出范围的数值会被设置为 0 或最大值。</li><li>字符串值会被截断至最大长度。</li><li>允许使用错误的日期/时间值（例如 2015-02-30）。</li><li>NOT NULL 约束仅对单行 INSERT 语句强制执行。对于多行插入，空数值会被替换为 0，空字符串会被替换为 &#39;&#39;。</li></ul><p>自 5.0.2 版本起，如果数据库引擎配置为使用自定义 SQL 模式，则可以执行严格的约束：</p><p>SET GLOBAL sql_mode=&#39;POSTGRESQL,STRICT_ALL_TABLES&#39;;</p><p>由于服务器启动时 sql_mode 会重置，因此最好在 MySQL 配置文件中进行设置：</p><p>[mysqld]<br> sql_mode = POSTGRESQL,STRICT_ALL_TABLES”</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>CAP 定理中的一致性</p><p>根据 CAP 定理，当分布式系统遇到网络分区时，系统必须在一致性（所有更改立即应用于所有节点）和可用性（任何节点都可以接受请求）之间做出选择，而不能同时选择两者。虽然在 ACID 的定义中，一致性是指遵守约束，但在 CAP 定理的语境下，一致性指的是线性化，这是一种隔离性保证。</p></div><h2 id="_6-3-隔离" tabindex="-1"><a class="header-anchor" href="#_6-3-隔离"><span>6.3 隔离</span></a></h2><p>如果只有一个用户访问数据库，则不会出现数据冲突的风险。根据通用可扩展性定律，如果数据访问模式的顺序部分小于 100%，则数据库系统可以从并行化中获益。</p><p>通过提供多个并发连接，可以提高事务吞吐量，从而使数据库系统能够处理更多流量。然而，并行化也带来了额外的挑战，因为数据库必须以某种方式交错执行事务，以确保冲突不会损害数据完整性。当所有当前正在运行的事务操作的执行顺序与底层事务按顺序执行的结果相同时，则称这些事务操作的执行顺序是可串行化的。</p><p>因此，可串行化执行是唯一既不损害数据完整性又允许一定程度并行化的事务隔离级别。1981 年，Jim Gray 曾描述最大的航空公司和银行拥有 10,000 个终端和 100 个活跃事务，这解释了为什么在 SQL-92 之前，可串行化一直是事实上的事务隔离级别。</p><h3 id="_6-3-1-并发控制" tabindex="-1"><a class="header-anchor" href="#_6-3-1-并发控制"><span>6.3.1 并发控制</span></a></h3><p>为了管理数据冲突，多年来人们开发了多种并发控制机制。处理数据冲突主要有两种策略：</p><p>避免冲突（例如两阶段锁定）需要使用锁定来控制对共享资源的访问。</p><p>检测冲突（例如多版本并发控制）可以提供更好的并发性，但代价是降低了可串行性，并且可能接受各种数据异常。</p><h4 id="_6-3-1-1-两阶段锁定" tabindex="-1"><a class="header-anchor" href="#_6-3-1-1-两阶段锁定"><span>6.3.1.1 两阶段锁定</span></a></h4><p>1976 年，Kapali Eswaran 和 Jim Gray 等人发表了题为《数据库系统中的一致性和谓词锁的概念》的论文，该论文证明，如果所有事务都使用两阶段锁定 (2PL) 协议，则可以实现可串行化。</p><p>最初，所有数据库系统都采用 2PL 来实现可串行化事务，但随着时间的推移，许多厂商转向了 MVCC（多版本并发控制）架构。默认情况下，SQL Server 仍然使用锁定来实现可串行化隔离级别。</p><p>由于 2PL 保证了事务的可串行化，因此了解维护严格数据完整性对应用程序整体可扩展性和事务性能的影响至关重要。</p>',163)]))}const C=t(m,[["render",g],["__file","high-performance_java_persistence.html.vue"]]),O=JSON.parse('{"path":"/tech-week/2025/high-performance_java_persistence.html","title":"Java 持久化","lang":"zh-CN","frontmatter":{"title":"Java 持久化","category":["技术"],"tag":["专栏"]},"headers":[{"level":2,"title":"数据库服务器和连接层","slug":"数据库服务器和连接层","link":"#数据库服务器和连接层","children":[]},{"level":2,"title":"应用数据访问层","slug":"应用数据访问层","link":"#应用数据访问层","children":[{"level":3,"title":"ORM框架","slug":"orm框架","link":"#orm框架","children":[]},{"level":3,"title":"本地查询构建框架","slug":"本地查询构建框架","link":"#本地查询构建框架","children":[]}]},{"level":2,"title":"4.4 客户端语句缓存","slug":"_4-4-客户端语句缓存","link":"#_4-4-客户端语句缓存","children":[]},{"level":2,"title":"5.1 结果集的可滚动性","slug":"_5-1-结果集的可滚动性","link":"#_5-1-结果集的可滚动性","children":[]},{"level":2,"title":"5.2 结果集的可变更性","slug":"_5-2-结果集的可变更性","link":"#_5-2-结果集的可变更性","children":[]},{"level":2,"title":"5.3 结果集保持性","slug":"_5-3-结果集保持性","link":"#_5-3-结果集保持性","children":[]},{"level":2,"title":"5.5 结果集大小","slug":"_5-5-结果集大小","link":"#_5-5-结果集大小","children":[{"level":3,"title":"5.5.2 列数过多","slug":"_5-5-2-列数过多","link":"#_5-5-2-列数过多","children":[]}]},{"level":2,"title":"6.1 原子性","slug":"_6-1-原子性","link":"#_6-1-原子性","children":[]},{"level":2,"title":"6.2 一致性","slug":"_6-2-一致性","link":"#_6-2-一致性","children":[]},{"level":2,"title":"6.3 隔离","slug":"_6-3-隔离","link":"#_6-3-隔离","children":[{"level":3,"title":"6.3.1 并发控制","slug":"_6-3-1-并发控制","link":"#_6-3-1-并发控制","children":[]}]}],"git":{"createdTime":1762154451000,"updatedTime":1763430223000,"contributors":[{"name":"RaymondLam1","username":"RaymondLam1","email":"liangfenglam@163.com","commits":10,"url":"https://github.com/RaymondLam1"}]},"readingTime":{"minutes":38.59,"words":11576},"filePathRelative":"tech-week/2025/high-performance_java_persistence.md","localizedDate":"2025年11月3日","excerpt":"\\n<p>在企业系统中，设计合理的数据库访问层可以对整体应用程序性能产生重大影响。根据 AppDynamics3 的数据，超过一半的应用程序性能瓶颈源于数据库。数据分布在各种结构（表行、索引节点）中，数据库记录可以被多个并发用户读取和写入。从并发的角度来看，这是一个极具挑战性的任务，为了最大限度地发挥持久层的作用，数据访问逻辑必须与底层数据库系统相匹配。</p>\\n<figure><figcaption>alt text</figcaption></figure>\\n<p>典型的关系数据库管理系统（RDBMS）数据访问层需要掌握多种技术，而整个企业解决方案的强度取决于团队中最薄弱的技能。在深入到更高抽象层（例如对象关系映射（ORM）框架）之前，最好先攻克底层技术。</p>"}');export{C as comp,O as data};
