import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,e as n,o as i}from"./app-NlZ0LgdL.js";const p="/assets/image-BP9yjLjw.png",r="/assets/image-1-CmsH8igx.png",o="/assets/image-2-NRIQMYGn.png",c="/assets/image-3-CxRzlUn1.png",l="/assets/image-4-3cqTWpX_.png",s={};function d(h,e){return i(),a("div",null,e[0]||(e[0]=[n('<h1 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h1><p>在企业系统中，设计合理的数据库访问层可以对整体应用程序性能产生重大影响。根据 AppDynamics3 的数据，超过一半的应用程序性能瓶颈源于数据库。数据分布在各种结构（表行、索引节点）中，数据库记录可以被多个并发用户读取和写入。从并发的角度来看，这是一个极具挑战性的任务，为了最大限度地发挥持久层的作用，数据访问逻辑必须与底层数据库系统相匹配。</p><figure><img src="'+p+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>典型的关系数据库管理系统（RDBMS）数据访问层需要掌握多种技术，而整个企业解决方案的强度取决于团队中最薄弱的技能。在深入到更高抽象层（例如对象关系映射（ORM）框架）之前，最好先攻克底层技术。</p><h2 id="数据库服务器和连接层" tabindex="-1"><a class="header-anchor" href="#数据库服务器和连接层"><span>数据库服务器和连接层</span></a></h2><p>数据库手册并非仅供数据库管理员使用。在不了解数据库工作原理的情况下与其交互，就像驾驶赛车却不接受任何驾驶培训一样。熟悉 SQL 标准和数据库特有的功能，能够决定应用程序的运行速度是高性能还是慢如蜗牛。对数据库可移植性的担忧可能会导致人们因为某些功能在不同数据库系统之间无法互换而放弃使用它们。实际上，数据库层运行缓慢的情况比将一个正在运行的系统移植到新的数据库解决方案更为常见。</p><p>所有数据访问框架都依赖 JDBC（Java 数据库连接）API 与数据库服务器通信。JDBC 提供了许多性能优化技术，旨在缩短事务响应时间并处理更多流量。因此，本书的第一部分专门介绍 JDBC 和数据库基础知识，涵盖数据库连接管理、语句批处理、结果集获取和数据库事务等主题。</p><h2 id="应用数据访问层" tabindex="-1"><a class="header-anchor" href="#应用数据访问层"><span>应用数据访问层</span></a></h2><p>许多企业应用场景中都证明了某些数据访问模式的有效性。Martin Fowler 的《企业应用架构模式》是每位企业应用开发人员的必读之作。除了对象关系映射 (ORM) 模式之外，大多数 ORM 框架还采用了诸如工作单元 (Unit of Work)、身份映射 (Identity Map)、延迟加载 (Lazy Loading)、嵌入值 (Embedded Value)、实体继承 (Entity Inheritance) 或乐观锁和悲观锁等技术。</p><h3 id="orm框架" tabindex="-1"><a class="header-anchor" href="#orm框架"><span>ORM框架</span></a></h3><p>ORM工具可以提升应用程序的开发速度，但其学习曲线无疑十分陡峭。要解决将关系数据与应用程序领域模型桥接起来的固有复杂性，唯一的方法就是完全理解所使用的ORM框架。</p><p>有时，即使是参考文档也可能不够，当遇到性能相关问题时，熟悉源代码是不可避免的。JPA（Java持久化API）在数据写入方面表现出色，因为所有DML（数据操作语言）语句都会在持久化模型更改时自动更新，从而加快迭代开发过程。</p><p>本书第二部分介绍了各种Hibernate特有的优化技术，例如标识符生成器、高效的实体获取、状态转换、应用程序级事务和实体缓存。</p><h3 id="本地查询构建框架" tabindex="-1"><a class="header-anchor" href="#本地查询构建框架"><span>本地查询构建框架</span></a></h3><p>JPA 和 Hibernate 从来不是用来替代 SQL 的，并且在任何非平凡的企业应用中，本地查询都是不可避免的。虽然 JPA 可以抽象 DML 语句和常见的实体检索查询，但在读取和处理数据时，没有什么可以胜过本地 SQL。</p><p>JPQL（Java 持久化查询语言）抽象了大多数关系型数据库支持的常见 SQL 语法。因此，JPQL 无法利用窗口函数、公共表表达式、派生表或 PIVOT。</p><p>与 JPA 不同，jOOQ（Java 面向对象查询）提供了类型安全的 API，它支持底层数据库系统提供的任何数据库特定查询功能。正如 Criteria API 在动态生成实体查询时能防止 SQL 注入攻击一样，jOOQ 在构建本地 SQL 语句时也提供了相同的安全保障。</p><p>因此，本书的第三部分是关于高级查询的。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>关于数据库性能基准测试</p><p>本书中穿插了一些基准测试，旨在展示特定性能优化带来的相对收益。基准测试结果始终取决于底层硬件、操作系统和数据库服务器配置、数据库大小以及并发模式。因此，绝对值不如相对优化收益重要。实际上，最相关的基准测试结果是针对实际生产系统进行的测试。</p><p>为了防止读者将不同数据库进行比较，并基于某些特定用例的基准测试得出错误的结论，数据库名称已进行混淆处理，分别以 DB_A、DB_B、DB_C 和 DB_D 表示。本书中使用的所有示例的源代码均可在 GitHub 上找到。</p></div><h1 id="jdbc-和数据库基础知识" tabindex="-1"><a class="header-anchor" href="#jdbc-和数据库基础知识"><span>JDBC 和数据库基础知识</span></a></h1><h1 id="_1-性能与扩展" tabindex="-1"><a class="header-anchor" href="#_1-性能与扩展"><span>1. 性能与扩展</span></a></h1><p>企业应用程序需要尽可能快速地存储和检索数据。在应用程序性能管理中，响应时间和吞吐量是两个最重要的指标。响应时间越短，应用程序的响应速度就越快。因此，响应时间是衡量性能的指标。扩展性是指在增加系统负载的同时保持较低的响应时间，因此，吞吐量是衡量可扩展性的指标。</p><p>1.1 响应时间和吞吐量</p><p>由于本书侧重于高性能数据访问，因此被测系统的边界位于事务管理器级别。</p><p>事务响应时间是指完成一个事务所需的时间，因此它包含以下时间段：</p><p>• 获取数据库连接的时间</p><p>• 通过网络发送所有数据库语句所需的时间</p><p>• 执行所有传入语句所需的时间</p><p>• 将结果集发送回数据库客户端所需的时间</p><p>• 在释放数据库连接之前，由于应用程序级计算而导致事务空闲的时间</p><figure><img src="'+r+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>吞吐量定义为完成传入负载的速率。在数据库上下文中，吞吐量可以计算为在给定时间间隔内执行的事务数量。</p><figure><img src="'+o+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>根据这个定义，我们可以得出结论：通过缩短事务执行时间，系统可以处理更多请求。</p><p>在单数据库连接测试中，测得的吞吐量将成为进一步基于并发性改进的基准。</p><figure><img src="'+c+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>理想情况下，如果系统呈线性扩展，增加数据库连接数将带来成比例的吞吐量提升。然而，由于数据库资源争用以及维护多个并发数据库会话间数据一致性的成本，相对吞吐量提升并非呈线性关系，而是呈曲线关系。通用可扩展性定律 (USL)¹ 可以近似表示最大相对吞吐量（系统容量）与负载生成器（数据库连接数）之间的关系。</p><figure><img src="'+l+`" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>• C - 给定并发级别的相对吞吐量增益<br> • α - 争用系数（数据处理例程的可串行化部分）<br> • β - 一致性系数（在所有并发数据库会话中保持一致性的成本）。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>在 PostgreSQL 9.2 版本之前，预编译语句的规划和编译完全在准备阶段完成，因此执行计划是在没有实际绑定参数值的情况下生成的。虽然这种策略旨在节省数据库资源，但它对数据倾斜非常敏感。从 PostgreSQL 9.2 版本开始，准备阶段仅解析和重写语句，而优化和规划阶段则延迟到执行阶段。这样，重写的语法树会根据实际绑定参数值进行优化，从而生成最优的执行计划。</p><p>对于单次执行，普通语句只需要一次数据库往返，而预编译语句则需要两次（一次准备请求和一次执行调用）。为了避免网络开销，默认情况下，JDBC PreparedStatement 会在一次数据库请求中完成准备和执行两个阶段。</p><p>客户端预编译语句必须至少运行 5 次，驱动程序才能将其转换为服务器端语句。默认执行次数由 prepareThreshold 参数指定，该参数可通过连接属性或驱动程序特定的 API 进行配置。</p><p>经过多次执行后，如果性能对绑定参数值不敏感，优化器可能会将执行计划转换为通用计划并缓存以供重用。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>MySQL 在准备语句时，MySQL 解析器会生成一个语法树，并通过解析机制对其进行进一步验证和预优化。该语法树会经历若干数据不敏感的转换，最终输出为一个永久树。自 MySQL 5.7.4a 起，所有永久转换（例如重连接顺序或子查询优化）都在准备阶段完成，因此执行阶段仅应用数据敏感的转换。MySQL 不缓存执行计划，因此每个语句的执行都会针对当前的绑定参数值进行优化，从而避免数据倾斜问题。</p><p>由于一些未解决的问题，自 5.0.5b 版本起，MySQL JDBC 驱动程序仅模拟服务器端预处理语句。要切换到服务器端预处理语句，必须将 useServerPrepStmts 和 cachePrepStmts 连接属性都设置为 true。</p><p>启用此功能之前，最好查看最新的 Connector/J 发行说明，并确认此功能可以安全使用。</p></div><h2 id="_4-4-客户端语句缓存" tabindex="-1"><a class="header-anchor" href="#_4-4-客户端语句缓存"><span>4.4 客户端语句缓存</span></a></h2><p>缓存语句不仅对数据库端有益，JDBC 驱动程序也可以重用已构建的语句对象。客户端语句缓存的主要目标可以概括如下：</p><p>• 减少客户端语句处理，从而缩短事务响应时间。<br> • 通过回收语句对象及其关联的数据库特定元数据来节省应用程序资源。</p><p>在高性能 OLTP 应用中，事务往往非常短，因此即使响应时间略有减少，也能对整体事务吞吐量产生影响。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Oracle 隐式语句缓存</p><p>与服务器端计划缓存不同，客户端缓存仅限于数据库连接。由于 SQL 字符串会成为缓存条目键，因此 PreparedStatement 和 CallableStatement 语句更容易被重用。因此，Oracle JDBC 驱动程序仅支持这两种语句类型的缓存。启用缓存（默认禁用）后，驱动程序会返回一个逻辑语句，因此当客户端关闭连接时，该逻辑语句会返回缓存。</p><p>从开发角度来看，存在隐式语句缓存机制以及显式缓存机制。两种缓存选项共享相同的驱动程序存储空间，需要根据当前应用程序的需求进行配置。</p><p>隐式缓存只能存储语句元数据，这些元数据在每次执行之间不会改变。虽然可以为每个连接单独设置，但在数据源级别进行配置更为方便（所有连接继承相同的缓存属性）。</p><p>connectionProperties.put(&quot;oracle.jdbc.implicitStatementCacheSize&quot;, Integer.toString(cacheSize));<br> dataSource.setConnectionProperties(connectionProperties);</p><p>设置 implicitStatementCacheSize 也会启用缓存。默认情况下，所有正在执行的语句都会被隐式缓存，但这可能并非理想之选（某些偶尔执行的查询可能会清除其他频繁执行的语句）。为了控制语句缓存策略，JDBC 定义了 isPoolable() 和 setPoolable(boolean poolable) 语句方法：</p><p>if (statement.isPoolable()) {<br> statement.setPoolable(false);<br> }</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Oracle 显式语句缓存</p><p>显式缓存是可配置的，并通过 Oracle 特定的 API 管理。在使用它之前，必须使用底层的 OracleConnection 引用启用并调整其大小。</p><pre><code>    OracleConnection oracleConnection = (OracleConnection) connection;
    oracleConnection.setExplicitCachingEnabled(true);
    oracleConnection.setStatementCacheSize(cacheSize);
</code></pre><p>在使用显式缓存时，数据访问会控制哪些语句可以被缓存，因此不再需要使用 setPoolable(boolean poolable) 方法。以下示例演示了如何利用显式缓存机制。</p><pre><code>    PreparedStatement statement = oracleConnection
            .getStatementWithKey(SELECT_POST_REVIEWS_KEY);
    if (statement == null)
        statement = connection.prepareStatement(SELECT_POST_REVIEWS);
    try {
        statement.setInt(1, 10);
        statement.execute();
    } finally {
        ((OraclePreparedStatement) statement).closeWithKey(SELECT_POST_REVIEWS_KEY);
    }
</code></pre><p>显式缓存依赖于两种主要操作，可以总结如下：</p><ol><li>getStatementWithKey(String key) 方法从缓存中加载语句。如果未找到条目，则必须使用标准 JDBC API 手动创建 PreparedStatement</li><li>closeWithKey(String key) 方法将语句推回到池中。</li></ol><p>特定于供应商的 API 将数据访问代码与 Oracle 特定的 API 绑定，这会阻碍可移植性，并且在兼容多种数据库系统时需要更复杂的数据访问逻辑。</p><p>除了缓存元数据之外，显式缓存还存储执行状态和数据。尽管重用更多的客户端构造可能进一步提高性能，但这种策略存在将先前和当前执行上下文混合的风险，因此建议谨慎使用。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>SQL Server</p><p>虽然 Microsoft SQL Server JDBC 驱动程序定义了 disableStatementPooling 属性，但截至撰写本文时（4.2 版本），语句缓存无法启用。另一方面，jTDS（开源的 JDBC 3.0 实现）提供基于每个连接的语句缓存。作为 JDBC 4.0 特定的 API，setPoolable(boolean poolable) Statement 方法在 1.3.1 版本的 jTDS 中未实现。缓存的默认大小为 500 条目，也可以调整。</p><pre><code>    ((JtdsDataSource) dataSource).setMaxStatements(cacheSize);
</code></pre><p>即便 jTDS 一直专注于性能，与 Microsoft 驱动程序相比，缺乏稳定的发布计划仍是一个主要缺点。</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>PostgreSQL</p><p>自 PostgreSQL JDBC 驱动 9.4-1202a 版本起，客户端的语句会被缓存，并且其关联的服务器端语句键即使在初始 PreparedStatement 关闭后也会被保留。只要当前连接缓存中包含指定的 SQL 语句，客户端的 PreparedStatement 和服务器端对象都可以被重用。setPoolable(boolean poolable) 方法无效，并且无法在每个语句的基础上禁用缓存。语句缓存由以下连接属性控制：• preparedStatementCacheQueries - 每个数据库连接缓存的语句数量。值为 0 时禁用缓存，并且在 PreparedStatement 关闭后，服务器端准备语句将不再可用。默认值为 256。• preparedStatementCacheSizeMiB - 语句缓存有上限内存，默认值为 5 MB。值为 0 时禁用缓存。这些属性既可以作为连接参数设置，也可以作为 DataSource 属性设置：</p><pre><code>    ((PGSimpleDataSource) dataSource).setPreparedStatementCacheQueries(cacheSize);
    ((PGSimpleDataSource) dataSource).setPreparedStatementCacheSizeMiB(cacheSizeMb);
</code></pre></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>MySQL</p><p>语句缓存与数据库连接相关，并适用于所有正在执行的语句。在 5.1.36 版本的 Connector/J 驱动程序中，setPoolable(boolean poolable) 方法只能禁用服务器端语句的缓存，客户端语句不受此设置影响。客户端语句缓存可以使用以下属性进行配置：<br> • cachePrepStmts - 启用客户端语句缓存以及服务器端语句有效性检查。默认情况下，语句缓存是禁用的。<br> • prepStmtCacheSize - 为每个数据库连接缓存的语句数量。默认缓存大小为 25。• prepStmtCacheSqlLimit - 允许缓存的 SQL 语句的最大长度。默认最大值为 256。</p><p>这些属性既可以作为连接参数设置，也可以在 DataSource 级别设置：</p><pre><code>    ((MysqlDataSource) dataSource).setCachePrepStmts(true);
    ((MysqlDataSource) dataSource).setPreparedStatementCacheSize(cacheSize);
    ((MysqlDataSource) dataSource).setPreparedStatementCacheSqlLimit(maxLength);
</code></pre></div>`,50)]))}const g=t(s,[["render",d],["__file","high-performance_java_persistence.html.vue"]]),f=JSON.parse('{"path":"/tech-week/2025/high-performance_java_persistence.html","title":"Java 持久化","lang":"zh-CN","frontmatter":{"title":"Java 持久化","category":["技术"],"tag":["专栏"]},"headers":[{"level":2,"title":"数据库服务器和连接层","slug":"数据库服务器和连接层","link":"#数据库服务器和连接层","children":[]},{"level":2,"title":"应用数据访问层","slug":"应用数据访问层","link":"#应用数据访问层","children":[{"level":3,"title":"ORM框架","slug":"orm框架","link":"#orm框架","children":[]},{"level":3,"title":"本地查询构建框架","slug":"本地查询构建框架","link":"#本地查询构建框架","children":[]}]},{"level":2,"title":"4.4 客户端语句缓存","slug":"_4-4-客户端语句缓存","link":"#_4-4-客户端语句缓存","children":[]}],"git":{"createdTime":1762154451000,"updatedTime":1762910739000,"contributors":[{"name":"RaymondLam1","username":"RaymondLam1","email":"liangfenglam@163.com","commits":4,"url":"https://github.com/RaymondLam1"}]},"readingTime":{"minutes":13.09,"words":3928},"filePathRelative":"tech-week/2025/high-performance_java_persistence.md","localizedDate":"2025年11月3日","excerpt":"\\n<p>在企业系统中，设计合理的数据库访问层可以对整体应用程序性能产生重大影响。根据 AppDynamics3 的数据，超过一半的应用程序性能瓶颈源于数据库。数据分布在各种结构（表行、索引节点）中，数据库记录可以被多个并发用户读取和写入。从并发的角度来看，这是一个极具挑战性的任务，为了最大限度地发挥持久层的作用，数据访问逻辑必须与底层数据库系统相匹配。</p>\\n<figure><figcaption>alt text</figcaption></figure>\\n<p>典型的关系数据库管理系统（RDBMS）数据访问层需要掌握多种技术，而整个企业解决方案的强度取决于团队中最薄弱的技能。在深入到更高抽象层（例如对象关系映射（ORM）框架）之前，最好先攻克底层技术。</p>"}');export{g as comp,f as data};
