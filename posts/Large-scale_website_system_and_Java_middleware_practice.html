<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>大型网站系统与 Java 中间件实践 | Raymondlam1</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="XXX">
    
    <link rel="preload" href="/assets/css/0.styles.975cf9e9.css" as="style"><link rel="preload" href="/assets/js/app.990df87d.js" as="script"><link rel="preload" href="/assets/js/7.491a51aa.js" as="script"><link rel="preload" href="/assets/js/2.e6a59b38.js" as="script"><link rel="preload" href="/assets/js/1.d6963574.js" as="script"><link rel="preload" href="/assets/js/15.56e70929.js" as="script"><link rel="prefetch" href="/assets/js/10.797b224f.js"><link rel="prefetch" href="/assets/js/11.f1f1449d.js"><link rel="prefetch" href="/assets/js/14.b7d37254.js"><link rel="prefetch" href="/assets/js/16.02b63a7a.js"><link rel="prefetch" href="/assets/js/17.e533830f.js"><link rel="prefetch" href="/assets/js/18.05f03067.js"><link rel="prefetch" href="/assets/js/19.20d4f721.js"><link rel="prefetch" href="/assets/js/20.629f92a3.js"><link rel="prefetch" href="/assets/js/21.85f5ad32.js"><link rel="prefetch" href="/assets/js/22.d9ae4026.js"><link rel="prefetch" href="/assets/js/23.61401ff0.js"><link rel="prefetch" href="/assets/js/24.de1681d0.js"><link rel="prefetch" href="/assets/js/25.9be151bc.js"><link rel="prefetch" href="/assets/js/26.9c6ab290.js"><link rel="prefetch" href="/assets/js/27.43f4ed25.js"><link rel="prefetch" href="/assets/js/28.0c7d7629.js"><link rel="prefetch" href="/assets/js/29.0bc708b8.js"><link rel="prefetch" href="/assets/js/3.a9685e30.js"><link rel="prefetch" href="/assets/js/30.21dc9da5.js"><link rel="prefetch" href="/assets/js/31.d4183985.js"><link rel="prefetch" href="/assets/js/32.b7bfe177.js"><link rel="prefetch" href="/assets/js/33.db8e03f4.js"><link rel="prefetch" href="/assets/js/34.a5820a8c.js"><link rel="prefetch" href="/assets/js/35.26cd22f6.js"><link rel="prefetch" href="/assets/js/36.b9d310dc.js"><link rel="prefetch" href="/assets/js/37.ce82ed82.js"><link rel="prefetch" href="/assets/js/38.cdd78f3b.js"><link rel="prefetch" href="/assets/js/39.4b9b9318.js"><link rel="prefetch" href="/assets/js/4.1db959a2.js"><link rel="prefetch" href="/assets/js/40.a0b2b6f6.js"><link rel="prefetch" href="/assets/js/41.d2f51ba4.js"><link rel="prefetch" href="/assets/js/42.6e33e97d.js"><link rel="prefetch" href="/assets/js/43.e6285fac.js"><link rel="prefetch" href="/assets/js/44.55f58fe3.js"><link rel="prefetch" href="/assets/js/45.b785e32e.js"><link rel="prefetch" href="/assets/js/46.95d1e4ba.js"><link rel="prefetch" href="/assets/js/47.bc46e5fd.js"><link rel="prefetch" href="/assets/js/48.f9bd2fe7.js"><link rel="prefetch" href="/assets/js/49.6ef8250b.js"><link rel="prefetch" href="/assets/js/5.3b2f494c.js"><link rel="prefetch" href="/assets/js/50.6f7acc39.js"><link rel="prefetch" href="/assets/js/51.c35bcef8.js"><link rel="prefetch" href="/assets/js/6.e7dc2624.js"><link rel="prefetch" href="/assets/js/8.8e69ed5c.js"><link rel="prefetch" href="/assets/js/9.bba2517f.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.e6ae10a0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.975cf9e9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>Raymondlam1</h3> <p class="description" data-v-59e6cb88>XXX</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2025
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Raymondlam1</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      Raymondlam1 的博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/RaymondLam1" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><!----> <!----> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>14</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>0</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      Raymondlam1 的博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/RaymondLam1" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/" class="sidebar-heading clickable router-link-active"><span>很高兴认识你</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/" aria-current="page" class="sidebar-link">自我介绍</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>博客</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/posts/parallel_scavenge.html" class="sidebar-link">Parallel Scavenge 新生代算法究竟是“标记-复制”还是“标记-清理”算法</a></li><li><a href="/posts/JFR.html" class="sidebar-link">防痴呆记录-JFR</a></li><li><a href="/posts/finalize.html" class="sidebar-link">finalize 方法阻塞分析</a></li><li><a href="/posts/spring-boot.html" class="sidebar-link">Spring Boot ClassLoader</a></li><li><a href="/posts/wireshark-grpc.html" class="sidebar-link">Wireshark 抓包 grpc</a></li><li><a href="/posts/ant-design-swagger.html" class="sidebar-link">Ant Design Pro 集合 Swagger 的坑</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>读书笔记</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/posts/dubbo.html" class="sidebar-link">深度剖析 Apache Dubbo 核心技术内幕</a></li><li><a href="/posts/Large-scale_website_system_and_Java_middleware_practice.html" aria-current="page" class="active sidebar-link">大型网站系统与 Java 中间件实践</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/posts/other/2FA.html" class="sidebar-link">Github 2FA 验证</a></li><li><a href="/posts/other/vue_press_deploy.html" class="sidebar-link">Vuepress 博客 GitHub Action</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>大型网站系统与 Java 中间件实践</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2025
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">大型网站系统与 Java 中间件实践</h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>Raymondlam1</span></i> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>2024/10/9</span></i> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h2 id="第4章-服务框架"><a href="#第4章-服务框架" class="header-anchor">#</a> 第4章 服务框架</h2> <p>在本书接下来的几章中，我们将一起学习支撑大型网站的Java中间件产品的具体设计和实现。我们从解决应用服务化问题的服务框架开始说起。</p> <h3 id="_4-1-网站功能持续丰富后的困境与应对"><a href="#_4-1-网站功能持续丰富后的困境与应对" class="header-anchor">#</a> 4.1 网站功能持续丰富后的困境与应对</h3> <p>图4-1所示的是网站结构的一个示意图，很多网站都会经历或正处于这样的阶段。这个结构相对简单，网站的业务功能集中在几个大应用上，而且这些应用都直接访问底层的服务，例如数据库、缓存、分布式文件系统、搜索引擎等。</p> <p>应该说这样的结构很清晰并足够解决问题。笔者在加入淘宝的时候，淘宝网大概也是这样的结构，而且在当时很好地支撑了每日一亿元的成交额和百万笔的订单。随着压力的上升，我们更多想到的是增加应用服务器的数量，但是这给数据库的连接数带来了比较大的压力。此外，随着网站规模的扩大，开发人员逐渐增多，于是每个应用都在变得复杂、臃肿——在多个应用中会有重复的代码，甚至在一个应用中，由于多人维护加上平时小需求的快速开发，也有一些代码冗余。这样的状况影响了整体的研发效率，并且对稳定性也造成了一定的影响。</p> <p><img src="/assets/img/image-7.6b6128f3.png" alt="alt text"></p> <p>在这样的情况下，我们想到的一个方法，就是把应用拆小，保持每个应用都不那么大。具体有两种实现方案。</p> <p>图4-2所示的方案与我们当时的架构是一样的，是把随着时间推移而变得复杂、庞大的应用拆成了多个（图示是从4个拆成了6个）。这样做的好处是能够相对较快地完成，但是仍然存在一些问题。一方面是数据库的连接数的压力还在，另一方面是在这些系统之间会存在一些重复的代码。例如，在一个电子商务网站中，可能会把商品管理、交易管理等功能分在不同的系统中，而这两个系统都会调用与用户相关的功能，那么在图4-2所示结构下，这两个系统就需要将用户功能的相关代码分别写一遍，这就造成代码重复了。当然也有使用共享库的方式，但是应用起来不太方便。</p> <p><img src="/assets/img/image-8.cd25d6a9.png" alt="alt text"></p> <p>接下来看另外一个方案，如图4-3所示。</p> <p><img src="/assets/img/image-9.17dd4549.png" alt="alt text"></p> <p>这就是所谓的服务化方案，我们在原来的应用和底层的数据库、缓存系统、文件系统等系统之间增加了服务层。图4-3只是一个示意图，真正实施中的服务可能是多层的，服务之间也会有相互的访问，这是需要加以管理的，后面讲服务治理时会提到。</p> <p>上述两种方案笔者都实际遇到过。在最初的阶段一般会采用第一种方案，因为第一种方案在小范围实现的成本较低，并且整体上也非常容易把控，并没有引入很多新内容。此外在第一种方案中，应用和应用之间很少直接交互，更多的是通过URL跳转。而第二种方案，就是所谓的服务化方案，使得系统看起来更立体了，应用之间有了直接的访问。而这也会带来很多问题，诸如围绕应用和应用之间访问等问题，这些问题细化下去又包含了很多的方面，我们会在后面一一道来。</p> <p>服务化的方式也会带来很多好处，首先从结构上看，系统架构更为清晰了，比之前更立体了。从稳定性上看，一些散落在多个应用系统中的代码也变成了服务，并由专门的团队进行统一维护，这一方面可以提高代码质量，另一方面由于核心的相对稳定，修改和发布次数会减少，这也会提高稳定性。最后，更加底层的资源统一由服务层管理，结构更加清晰，也更利于提高效率。</p> <p>服务化的方式对于研发也会产生一些影响。以前的研发模式是由几个比较大的团队去负责几个很大的应用，然后这几个应用就构成了整个网站的应用。而随着服务化的进行，我们的应用数量会有飞速增长，加上有服务框架的支持，调用远程服务会变得简单，而系统内部的依赖关系会变得错综复杂。服务化的方式会让多个规模不大的团队专注在某个具体的服务或者应用上，以这种方式来应对和解决问题。</p> <h3 id="_4-2-服务框架的设计与实现"><a href="#_4-2-服务框架的设计与实现" class="header-anchor">#</a> 4.2 服务框架的设计与实现</h3> <p>本节我们来介绍支持服务化的服务框架的设计与实现。</p> <h4 id="_4-2-1-应用从集中式走向分布式所遇到的问题"><a href="#_4-2-1-应用从集中式走向分布式所遇到的问题" class="header-anchor">#</a> 4.2.1 应用从集中式走向分布式所遇到的问题</h4> <p>要把单层Web应用的结构改为多层的、有服务层的结构时，很多人不会直接做一个通用的服务框架，而是为当前要用的服务做一个RPC的功能，为服务使用者提供相关的客户端。事实上，当所提供服务的集群多于一个时，通用的服务框架就非常重要了。</p> <p>在没有服务化之前，应用都是通过本地调用的方式来使用其他组件的。服务化会使得原来的一些本地调用变为远程调用。对于这种改变，研发人员最关心的是提高易用性以及降低性能损失这两方面。</p> <p>我们先通过一张图来看一下服务框架要解决的问题，如图4-4所示。</p> <p><img src="/assets/img/image-10.472882fd.png" alt="alt text"></p> <p>从图4-4可以看出，将原来在单机的单个进程中的一个方法调用分散到两个节点上要经过好几个步骤。</p> <p>在做服务框架时，我们需要用到的最基础的知识是网络通信相关的知识，相信很多读者在学习编程时都对网络通信有浓厚的兴趣，会尝试Socket通信等相关的技术实现。这些是我们自己来做服务框架的基础，也是图4-4中通信部分的实现基础。</p> <p>单机单进程的方法（函数）调用其实就只需要把程序计数器指向相应的入口地址，而在多机之间，我们需要对调用的请求信息进行编码，然后传给远程的节点，解码后再进行真正的调用。这也是图4-4中提到的编码/解码过程。寻址路由是用来让调用方确定哪个实例被调用的，实例定位是指在被调用的机器上找到对应的实例来进行方法调用，从而实现功能。</p> <h4 id="_4-2-2-透过示例看服务框架原型"><a href="#_4-2-2-透过示例看服务框架原型" class="header-anchor">#</a> 4.2.2 透过示例看服务框架原型</h4> <p>细心的读者会发现图4-4并不完整，它只是体现了从一端到另外一端的请求，没有包括响应的处理，而且看起来调用端和服务端是不对称的。其实，服务框架应该是既包含调用端逻辑又包含服务端逻辑的一个实现，也就是说虽然我们在每次的请求中是分了调用端角色和服务端角色，但是从应用来看都是可以提供和调用服务的。这样描述可能有点抽象，下面我们用一个具体的例子来说明这个过程。</p> <h5 id="_4-2-2-1-单机方式"><a href="#_4-2-2-1-单机方式" class="header-anchor">#</a> 4.2.2.1 单机方式</h5> <p>假设我们需要提供一个计算器的功能。按照单机程序的做法，我们可以实现一个计算器的类，然后直接使用，代码大概如下：</p> <div class="language-java extra-class"><pre class="language-java"><code>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Calculator</span> <span class="token punctuation">{</span> 
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span> 
        <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> 
    
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minus</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span> 
        <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> 
    
<span class="token punctuation">}</span> 
</code></pre></div><p>接着是使用计算器的代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
        <span class="token class-name">Calculator</span> calculator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Calculator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>calculator<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre></div><p>关于计算器对象的构建方式，我们在这里是直接新建了一个（通过new的方式），而在一些更加正式的系统中，更多的是采用类似Spring IoC的方式将一个实例注入到具体使用的地方。具体的代码这里不再列出。</p> <h5 id="_4-2-2-2-实现远程服务的调用客户端"><a href="#_4-2-2-2-实现远程服务的调用客户端" class="header-anchor">#</a> 4.2.2.2 实现远程服务的调用客户端</h5> <p>我们接下来想看的就是，如果要把这个本地的计算器的方法调用变成一个远程服务，应该怎么办？</p> <p>在开始之前，我们先做一个简单的事情：把Calculator的接口抽象出来，然后把实现独立。也就是下面这段代码：</p> <div class="language-java extra-class"><pre class="language-java"><code>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Calculator</span> <span class="token punctuation">{</span> 
    <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    
    <span class="token keyword">int</span> <span class="token function">minus</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 
  
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CalculatorImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Calculator</span><span class="token punctuation">{</span> 
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span> 
        <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> 
    
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minus</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span> 
        <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> 
</code></pre></div><p>接下来我们从调用端开始看。</p> <p>首先，我们希望调用者使用计算器服务的方式与目前的用法一样。那么，我们需要重新实现Calculator这个接口。</p> <div class="language-java extra-class"><pre class="language-java"><code>
 <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span> 
        
     <span class="token comment">//获取可用服务地址列表 </span>
     <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> l <span class="token operator">=</span> <span class="token function">getAvailableServiceAddresses</span><span class="token punctuation">(</span><span class="token string">&quot;Caluctor.add&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        
     <span class="token comment">//确定要调用服务的目标机器 </span>
     <span class="token class-name">String</span> address <span class="token operator">=</span> <span class="token function">chooseTarget</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        
     <span class="token comment">//建立连接 </span>
     <span class="token class-name">Socket</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        
     <span class="token comment">//请求的序列化 </span>
     <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> request <span class="token operator">=</span> <span class="token function">genReqeust</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  
     <span class="token comment">//发送请求 </span>
     s<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        
     <span class="token comment">//接收结果 </span>
     <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> response <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">10240</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
        s<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  
     <span class="token comment">//解析结果 </span>
     <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">getResult</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  
     <span class="token keyword">return</span> result<span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 
</code></pre></div><p>为了说明问题，我们用伪代码（可能连伪代码都算不上）来说明关键的步骤。上面的这段代码是我们重新改写的Calculator接口的add方法的实现。</p> <p>我们分部分来看一下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//获取可用服务地址列表 </span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> l <span class="token operator">=</span> <span class="token function">getAvailableServiceAddresses</span><span class="token punctuation">(</span><span class="token string">&quot;Caluctor.add&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  
<span class="token comment">//确定要调用服务的目标机器 </span>
        <span class="token class-name">String</span> address <span class="token operator">=</span> <span class="token function">chooseTarget</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre></div><p>首先根据要调用的服务名称来获取提供服务的机器的地址列表，并且从可用的服务地址列表中选择一个要调用的目标机器。</p> <p>大家可以回忆一下第1章中控制器的部分，其中提到了在分布式系统中的几种控制方式，这段代码完成的就是类似的工作。如果我们采用的是在请求发起方和服务提供方中间有LVS或硬件负载均衡的方案，那么getAvailableServiceAddresses返回的就是LVS或硬件负载均衡的地址和端口，并且chooseTarget其实就会直接反馈这个地址端口号。</p> <p>如果我们使用名称服务的方式，那么在getAvailableServiceAddresses中返回的就是当前可用服务的地址列表。需要注意的是参数“Calculator.add”，我们就是用它的值来定位服务的，也就是用它来告诉名称服务要找的是哪个服务。一般来说，这个用来做key的服务名字会直接采用接口的全名，也就是说在实践中更多的是采用“org.vanadies.chapter4.Calculator”来作为要查找的服务名称，具体到如何对服务命名、服务的粒度如何，就需要读者在自己的实践当中来确定了。笔者习惯于使用“完整的类名+版本号”作为定位服务的key。从名称服务返回可用的服务列表后，会通过chooseTarget选择这次调用的具体目标，也就是在这个过程中完成了负载均衡的工作。</p> <p>在第1章讲控制器时，还提到了规则服务器的方式，这种方式和名称服务的方式很类似，只是特性略有不同，一般规则服务器的方式更多地运用在有状态的场景。像数据这种状态要求很高的场景，或者缓存这种尽量要有状态的场景，都会用到规则服务器的方式来解决寻址的问题。在无状态的服务场景中，则不太用规则服务器的方式来处理。</p> <p>上面提到了三种控制方式，笔者在实践中主要是用第二种方式，也就是在请求发起方和服务提供方之间直连的方式，没有再加入物理设备（必要的网络设备除外）。在这种方式下，原来在LVS或者硬件负载均衡上的工作被分摊到了服务框架和名称服务两个地方来完成。关于名称服务，我们会在第5章重点讲述，这里姑且先把它当做一个黑盒子吧。</p> <p>至此我们已经完成了对寻址和路由的介绍，接下来的事情应该是读者比较熟悉的了——我们需要构造请求的数据包，并进行通信。</p> <p>构造请求数据包其实就是把对象变为二进制数据，也就是常说的序列化（熟悉COM的读者应该知道这个过程就是marshalling），而使用Java的读者都知道，Java本身的序列化就可以把对象转为二进制数据，并且使用起来是非常简单的，我们可以直接使用Java序列化来完成编码的工作。</p> <p>接着就是通信本身。我们可以通过Socket来简单地做一个实现，把Java序列化以后的数据发送过去。</p> <p>这样我们就完成了一次调用的发起。请求数据发送结束后，需要等待远程服务的执行以及结果的返回，收到结果后，我们可以对数据进行Java反序列化（假设我们采用的是Java序列化），然后得到执行的结果。</p> <h5 id="_4-2-2-3-实现服务端"><a href="#_4-2-2-3-实现服务端" class="header-anchor">#</a> 4.2.2.3 实现服务端</h5> <p>接下来，我们需要大概看一下在服务实现端应该怎么做。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EventHandler</span> <span class="token punctuation">{</span> 
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Request</span> <span class="token punctuation">{</span> 
        <span class="token keyword">public</span> <span class="token class-name">Socket</span> socket<span class="token punctuation">;</span> 
        <span class="token keyword">public</span> <span class="token class-name">String</span> serviceName<span class="token punctuation">;</span> 
        <span class="token keyword">public</span> <span class="token class-name">String</span> serviceVersion<span class="token punctuation">;</span> 
        <span class="token keyword">public</span> <span class="token class-name">String</span> methodName<span class="token punctuation">;</span> 
        <span class="token keyword">public</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">;</span> 
        
    <span class="token punctuation">}</span> 
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">eventHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> requestData <span class="token operator">=</span> <span class="token function">receiveRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
            <span class="token class-name">Request</span> request <span class="token operator">=</span> <span class="token function">getRequest</span><span class="token punctuation">(</span>requestData<span class="token punctuation">)</span><span class="token punctuation">;</span> 
            
            <span class="token class-name">Object</span> service <span class="token operator">=</span> <span class="token function">getServiceByNameAndVersion</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span> serviceName<span class="token punctuation">,</span> request<span class="token punctuation">.</span>serviceVersion<span class="token punctuation">)</span><span class="token punctuation">;</span> 
            
            <span class="token class-name">Object</span> result <span class="token operator">=</span> <span class="token function">callService</span><span class="token punctuation">(</span>service<span class="token punctuation">,</span> request<span class="token punctuation">.</span>methodName<span class="token punctuation">,</span> request<span class="token punctuation">.</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span> 
            
            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data <span class="token operator">=</span> <span class="token function">genResult</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> 
            request<span class="token punctuation">.</span>socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token punctuation">}</span> 
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> 
</code></pre></div><blockquote><p>上面的代码属于伪代码。在服务端，我们必然会有一个真正实现计算器功能的类，这个类其实和之前单机单进程版本里面的实现是一样的，这里就不列出代码了。</p></blockquote> <p>我们真正关心的是如何处理好远程过来的请求以及如何调用这个具体的实现类（CalculatorImpl）。</p> <p>对于服务端，我们需要在启动后就进行监听，上面的代码没有列出这个部分的初始化过程。我们还是先看重点。</p> <p>重点在于我们需要持续地接收请求并进行处理，而且对于收到的数据也需要一个反序列化的过程以得到对象本身。而从Request对象的定义中可以看到我们最关心的几个元素，包括服务的名称、服务的版本号、需要调用的方法名称及参数，以及调用的连接。上面的代码以Socket对象说明。</p> <p>当我们拿到请求的对象后，需要在本地定位具体提供的服务，也就是上面代码里的getServiceByNameAndVersion，具体实现上，我们会有一个服务注册表，是根据名称和版本号对服务实例进行的管理。关于其中的对应关系，我们一般是在启动时构建初始值，并且提供运行时的修改，可以说是动态发布了服务。</p> <p>在得到具体的服务实例之后，接下来主要就是进行服务调用了，这一般是通过反射的方式来实现，即得到服务实例具体方法的执行结果后，把需要返回给调用方的结果序列化为二进制数据，并且通过网络写回给请求发送端。</p> <p>至此，我们看到了一次服务请求、处理、结果返回的过程。</p> <blockquote><p>当然，上面给出的代码主要是希望读者能够理解这个过程本身，而不是为了展示一个真实服务框架的代码。如果读者能够按照上文给出的思路把具体的代码完成，那么可以说一个自己的服务框架就算搭建好了。</p></blockquote> <h4 id="_4-2-3-服务调用端的设计与实现"><a href="#_4-2-3-服务调用端的设计与实现" class="header-anchor">#</a> 4.2.3 服务调用端的设计与实现</h4> <p>接下来，我们详细看一下服务调用端（也称为客户端）的具体设计与实现。先来整理一下刚才看到的服务请求过程中服务调用的工作，如图4-5所示。图4-5展示了从发送请求到收到响应的过程中，请求发送端所经过的主要环节。接下来我们对每个环节来进行具体介绍。</p> <p><img src="/assets/img/image-20241007221048162.e12ffad1.png" alt="image-20241007221048162"></p> <h5 id="_4-2-3-1-确定服务框架的使用方式"><a href="#_4-2-3-1-确定服务框架的使用方式" class="header-anchor">#</a> 4.2.3.1 确定服务框架的使用方式</h5> <p>我们的第一个问题是如何在客户端引入和使用服务框架。</p> <p>从前面的章节我们看到，进行远程服务调用时，可以采用中间放置代理服务器的方式，也可以通过正在介绍的直连的方式。要进行远程调用，就要求在调用端有一个客户端的程序来完成相关工作。</p> <blockquote><p>笔者在刚开始进行服务化时，需要同时把两个重要的业务变成远程服务，当时做得比较土：两个服务都有自己的客户端，并且采用的通信方式、协议、实现都不同——这在当时没有什么问题（当时其中一个系统是在做通用的方案，不过由于两个系统的改造同时进行，所以最后出来了两种实现），不过不是一个统一实现就相当于每个系统都要自己实现一遍，这样成本太高了。这也是我们需要一个服务框架的通用实现的原因。</p></blockquote> <ol><li>从代码角度看如何使用服务框架</li></ol> <p>客户端的引入或者说应用程序对于客户端的使用就是我们首先需要解决的问题。大多数使用Java来进行开发的系统都会用Spring来作为组件的容器，开发人员也都熟悉Spring的配置，所以通过Spring的方式引入是一个常见的方式。而作为服务框架，在请求发起端会提供通用的Bean，如同下面的例子。</p> <p>假设我们有一个计算器的服务，名字是org.vanadies.CalculatorImpl，那么在Spring中，我们通常这样进行配置：</p> <div class="language-xml extra-class"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>calculator<span class="token punctuation">&quot;</span></span>  <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.vanadies.CalculatorImpl<span class="token punctuation">&quot;</span></span> <span class="token punctuation">&gt;</span></span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>  
</code></pre></div><p>这是关于一个Spring Bean的最简单的配置，那么通过Spring引入服务框架进行远程调用的配置该怎么做呢？下面给出一个参考（实际情况会因做服务框架时所选择的实现方式而不同）：</p> <div class="language-xml extra-class"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>calculator<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.vanadies.ServiceFramework.ConsumerBean<span class="token punctuation">&quot;</span></span> <span class="token punctuation">&gt;</span></span> 
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>interfaceName<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> 
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>org.vanadies.Calculator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span> 
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span> 
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>version<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> 
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>1.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span> 
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span> 
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>group<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> 
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>Test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span> 
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>  
</code></pre></div><p>上面代码给出了一个简单版本的服务框架的配置，通过配置可以看到，我们实现了一个ConsumerBean，它是一个通用的对象，是完成本地和远程服务的桥梁。而且，因为Java有动态代理的支持，所以我们在完成远程调用时，使用一个通用的对象就可以解决问题了，而不需要像很多语言那样，需要通过类似IDL（Interface Description Language，接口描述语言）的方式定义，然后生成代理存根代码，再分别与调用端和被调用端一起编译。我们接着看一下配置的属性，对于一个具体的服务框架的实现，从落地到完善的过程中会有很多控制点，这些控制点可以作为属性来配置，也可以通过一些方式集中管理，这是后话。我们先看三个相对基础的属性</p> <ul><li><p>interfaceName</p> <blockquote><p>接口名称，通过名字可以知道这个属性设置的就是接口的名字。我们知道在面向对象的开发中都是通过接口（也包括对象）来调用相应的方法的，那么，在进行远程通信时ConsumerBean必须知道被调用的接口是哪一个，然后才能生成对这个接口的代理，以供本地调用，所以这是一个必备的属性。</p></blockquote></li> <li><p>group</p> <blockquote><p>分组。在这里讲这个属性可能稍微有点靠前，不过后面还会再进行较详细的解释。在这里讲分组属性的好处是，如果对同一个接口的远程服务有很多机器，我们可以把这些远程服务的机器归组，然后调用者可以选择不同的分组来调用，这样就可以将不同调用者对于同一服务的调用进行隔离了。</p></blockquote></li> <li><p>version</p> <p>版本号。设置了接口名称就具备了可以进行远程调用的最基础属性，不过在实际的场景中，接口是存在变化的可能性的，有的是因为实现代码本身重构的原因，也有的是因为业务的发展变化需要修改接口中已有方法的参数或者返回值，以满足新的要求。如果直接这样变化，那就要求所有使用的地方一起修改，一起升级，这在一个大型的分布式系统（网站）中代价是非常高的。解决这个问题的方式有两种，一是如果需要修改方法的参数或返回值，我们就新增一个方法，始终保持己有方法不变，不过这样的做法，会在过渡期间（新旧方法都有人用时）导致代码相对臃肿，并且新方法其实是不好起名字的；另一种方案就是通过版本号进行区分隔离，我们这里的版本号属性就是用来解决这个问题的。</p></li></ul> <p>前面列出的这三个属性是笔者根据自己做服务框架的经验选出来的比较基础的三个。在实际中，根据具体的需求，我们可能需要控制远程调用的超时，可能需要选择不同的调用方式（这在后面会讲到），可能需要对不同方法进行不同的控制等。</p> <ol start="2"><li>运行期服务框架与应用和容器的关系</li></ol> <p>通过上面的例子我们可以看到，服务框架的接入也就涉及了比较常规的Spring的方式，当然，你也可以通过代码的方式来实现。这看起来很简单，不过在实际中有两个很重要的问题需要解决，一是服务框架自身的部署方式问题，二是实现自己的服务框架所依赖的一些外部jar包与应用自身依赖的jar包之间的冲突问题。</p> <p>先来看第一个问题：服务框架自身的部署方式问题。一种方案是把服务框架作为应用的一个依赖包并与应用一起打包。通过这种方式，服务框架就变为了应用的一个库，并随应用启动。存在的问题是，如果要升级服务框架，就需要更新应用本身，因为服务框架是与应用打包放在一起的；并且服务框架没有办法接管classloader，也就不能做一些隔离以及包的实现替换工作。</p> <p>另外一种方案是把服务框架作为容器的一部分，这里是针对Web应用来说的，而Web应用一般用JBoss、Tomcat、Jetty等作为容器，我们就要遵循不同容器所支持的方法，把服务框架作为容器的一部分。例如，针对JBoss，我们可以通过MBean实现服务框架的启动，将其部署为一个sar包来为应用提供服务。然而有的情况下应用不需要容器（不是Web应用，或者不使用现有容器），那么，服务框架自身就需要变为一个容器来提供远程调用和远程服务的功能。</p> <p>通过图4-6至图4-8，我们能够比较好地看到服务框架与应用容器及应用的关系。图4-6所示是服务框架作为Web应用的一个依赖包的情况；图4-7所示是服务框架作为Web容器的扩展而存在的情况，也可以看到它与Web应用的关系；图4-8所示是不使用Web容器，把服务框架作为容器来部署应用的情况。</p> <p><img src="/assets/img/image-20241007222601664.37869728.png" alt="image-20241007222601664"></p> <p><img src="/assets/img/image-20241007222614308.f4909541.png" alt="image-20241007222614308"></p> <p><img src="/assets/img/image-20241007222628804.eba5de7d.png" alt="image-20241007222628804"></p> <p>接着我们来看一下Jar包冲突的问题。使用Java的读者都知道，通过Java做一个应用时，一般都会用到多个jar包，这些jar包可能是别人（第三方，一般是写公共的库）提供的，也可能是我们自己做的，而这些jar包本身可能又会用到（依赖）另一些jar包。那么，最终可能产生这样的情况：这些直接、间接依赖的jar包导致应用里面同一个jar包有不同的版本，例如打印日志使用log4j，可能就有1.1.14和1.2.9两个版本，这样就会产生冲突。</p> <p>ClassLoader是Java中一项非常关键的技术，它的结构如图4-9所示。我们看到用户自定义（User-Defined Class Loader）Class Loader的部分有多个，并且是有机会进行隔离的，而我们采用的也是类似的方式：将服务框架自身用的类与应用用到的类都控制在User-Defined Class Loader级别，这样就实现了相互间的隔离。Web容器对于多个Web应用的处理，以及OSGi对于不同Bundle的处理都采用了类似的方法。</p> <p><img src="/assets/img/image-20241007222855534.a76c799d.png" alt="image-20241007222855534"></p> <p>此外，我们在实际中还会遇到需要在运行时统一版本的情况，那就需要服务框架比应用优先启动，并且把一些需要统一的jar包放到User-Defined Class Loader所公用的“祖先”ClassLoader中。</p> <h5 id="_4-2-3-2-服务调用者与服务提供者之间通信方式的选择"><a href="#_4-2-3-2-服务调用者与服务提供者之间通信方式的选择" class="header-anchor">#</a> 4.2.3.2 服务调用者与服务提供者之间通信方式的选择</h5> <blockquote><p>到这里，我们大体介绍了服务框架与应用之间的集成和关系，以及引入服务框架的方式上需要注意的问题，并且也看到了服务框架的使用方式。应该说使用起来还是非常容易的，这也是服务框架的目标之一，即尽量把远程服务的使用做得和本地服务类似，当然没有办法一模一样，因为远程服务需要一些额外的属性配置，此外，考虑到网络及远程服务器的问题，在调用方法的异常处理上也有所不同。这些都是很细节的问题，就留给读者思考或在具体实现的过程中去应对了。</p></blockquote> <p>在具体的调用发起时其实是调用了ConsumerBean为具体接口产生的一个动态代理对象。该动态代理对象被调用后会进行如同服务请求方的（图4-5中所示的）处理，要完成寻址等工作。</p> <p>那么，我们接下来就看一下寻址路由相关的处理。</p> <p>我们使用服务框架是为了把本地对象之间的方法调用变为远程的过程调用（RPC，Remote Procedure Call），这就涉及了远程通信的问题。</p> <blockquote><p>相信很多学习计算机的读者在学会了基础的代码编写后，都对网络通信的开发很感兴趣，笔者也是这样的。</p></blockquote> <ol><li>远程通信遇到的问题</li></ol> <p>图4-10所示的问题是大家在做网络编程时需要解决的第一个问题，就是两台机器之间怎样通信的问题。很多人都写过类似远程Echo的例子或者是两台机器进行文本对话的例子，但在图4-10所示的两台机器连接的情况下，一般都是写死在程序中或者是输入了一个IP地址和端口号，这就是最初的路由寻址的过程。</p> <p><img src="/assets/img/image-20241007223250650.3a570189.png" alt="image-20241007223250650"></p> <p>而在实际当中，提供某种服务的机器一定是多台的，是一个集群，而且调用服务的机器也是集群，因此需要解决的是图4-11所示的问题，如下。</p> <p><img src="/assets/img/image-20241008090135428.c308aa39.png" alt="image-20241008090135428"></p> <ol start="2"><li>采用透明代理与调用者、服务提供者直连的解决方案</li></ol> <p>在前面，我们提到了有两种方式进行远程服务调用，第一种是通过中间的代理来解决，结构如图4-12所示。</p> <p><img src="/assets/img/image-20241008090457869.7723b0ad.png" alt="image-20241008090457869"></p> <p>这和第1章介绍的控制器的结构是一样的，它也是控制器在服务框架中的一个应用场景。而我们这里的服务框架的设计采用的是另一种控制方案，如图4-13所示。</p> <p><img src="/assets/img/image-20241008090840641.0fdb9ab9.png" alt="image-20241008090840641"></p> <p>图4-13展示了服务框架在系统中的位置，可以看到集群到集群间的远程调用中并没有在调用链路中放置一个物理的代理机器，而是采用了调用者和提供者直接建立连接的方式，并且引入了一个服务注册查找中心的服务。</p> <blockquote><p>我们在这里先不过多讨论具体通信的部分，暂且把服务注册查找中心当成一个黑盒子，先来重点看一下寻址和路由。</p></blockquote> <p>通过图4-13我们看到服务注册查找中心并不处在调用者和服务提供者之间，服务注册查找中心对于调用者来说，只是提供可用的服务提供者的列表，这有点像日常生活中类似114的查号服务。不过出于效率的考虑，我们并不是在每次调用远程服务前都通过这个服务注册查找中心来查找可用地址，而是把地址缓存在调用者本地，当有变化时主动从服务注册查找中心发起通知，告诉调用者可用的服务提供者列表的变化。</p> <p>当客户端拿到可用的服务提供者的地址列表后，如何为当次的调用进行选择就是路由要解决的问题了。我们在这里首先要考虑的就是集群的负载均衡。具体到负载均衡的实现上，随机、轮询、权重是比较常见的实现方式，其中权重方式一般是指动态权重的方式，可以根据响应时间等参数来进行计算。在服务提供者的机器能力对等的情况下，采用随机和轮询这两种方式比较容易实现；在被调用的服务集群的机器能力不对等的情况下，使用权重计算的方式来进行路由比较合适。关于具体的负载均衡的策略，可以参考硬件负载均衡设备以及LVS、HAProxy等替代硬件负载均衡设备的系统所支持的策略，不过需要注意的是，因为服务框架设计的结构不同，所以不是所有硬件负载均衡支持的策略都适用于我们这个方案。</p> <h5 id="_4-2-3-3-引入基于接口、方法、参数的路由"><a href="#_4-2-3-3-引入基于接口、方法、参数的路由" class="header-anchor">#</a> 4.2.3.3 引入基于接口、方法、参数的路由</h5> <p>介绍完基础的寻址和路由，我们再来深入研究一下基于接口、方法、参数的路由。在实际的场景中，一般会用接口作为服务的粒度，也就是说一个服务就是指一个接口的远程实现，当然某个接口所承载的职责需要根据具体的业务和系统来决定。一般情况下，在一个集群中会提供多个服务，而每个服务又有多个方法，因此除了前面介绍的基础的负载均衡策略外，我们还有更加细粒度地控制服务路由的需求。</p> <p>我们先通过图4-14来看一下具体结构。</p> <p><img src="/assets/img/image-20241008091227882.51326dc7.png" alt="image-20241008091227882"></p> <p>我们看到两组调用者集群（调用者1和调用者2）都依赖于服务提供者所提供的服务，这个服务提供者有两个服务——接口A和接口B，每个服务又分别提供了两个方法。从功能上来说，这个结构已经没有什么问题了，我们下面看一个实际的场景。</p> <p>在我们的实现中，服务提供者在执行调用者的请求时，内部的线程模型是一个线程对应一个请求，而总的线程数量有一个限制（一般采用线程池来管理所有的工作线程）。当系统运行时，如果并发请求量比较大，可能所有工作线程已经全部在工作了，如果这时又有新的请求进来就需要排队，当然，这些都是非常正常的逻辑。但是如果这个服务提供者的某个方法是一个很慢的方法，会出现什么情况呢？</p> <p>假设图4-14中接口A的方法1是一个比较慢的方法（即执行时间明显长于其他方法的执行时间，例如其他方法的执行时间在50ms左右，而这个方法需要5秒左右），而调用者对这两个接口的所有方法调用的频率相差不多，那就有可能出现所有线程都被这个接口A的方法1所占用的情况。从图4-15中能够更清楚地看到这个过程。</p> <p>在图4-15中，IA表示接口A，IB表示接口B，m1表示方法1，m2表示方法2，为了能够让读者看得更清楚，我们给每次请求加了一个编号，编号是针对同一个接口的同一个方法的，例如IA.m1_1表示在这个服务提供者机器上IA接口的m1方法的第一次调用。</p> <p><img src="/assets/img/image-20241008092407124.69904b1b.png" alt="image-20241008092407124"></p> <p>假设服务提供者的系统上有5个工作线程，并且到这个服务提供者机器上的请求是按照图4-15所示的顺序进来的（就是按照IA.m1→IA.m2→IB.m1→IB.m2的顺序），从图中我们可以很直观地看出来，因为IA.m1方法的执行时间非常长，所以我们的线程很快就都陷入了执行IA.m1方法的状态，之后再进来的请求就都需要排队等待，而且等待的时间是非常长的。该怎么办呢？</p> <p>从图4-15中可以看出来，之所以等待是因为我们的线程不够多了，那么我们可以增加线程数，不过单机可以设置的线程数总是有限的，因此可以考虑增加机器数，这样可以减少分到每个机器上的请求数。这种思路就是增加可执行的线程总数来保证在实际运行的过程中总是有可用线程提供服务，但是这种思路不太经济也不太可控。实际中计算需要的线程总数是很困难的事情，从系统可用性和经济性的角度考虑的话，控制这些慢的方法对正常情况的影响是比较合理的思路。第一种思路是增加资源保证系统的能力是超出需要的，第二种思路是隔离这些资源，从而使得快慢不同、重要级别不同的方法之间互不影响。</p> <p>从客户端的角度来说，控制同一个集群中不同服务的路由并进行请求的隔离是一种可行方案。也就是说，虽然集群中每台机器部署的代码是一样的，提供的服务也是一样的，但是通过路由的策略，我们让其中对于某些服务的请求到一部分机器，让另一些服务的请求到另一部分机器，则看起来是图4-16所示的结构。</p> <p><img src="/assets/img/image-20241008092744456.8eaf67ab.png" alt="image-20241008092744456"></p> <p>在图4-16中，我们采用的方案是通过客户端的路由把调用服务A的请求送到图中右上方的集群，把调用服务B的请求送到图中右下方的集群。而这两个集群的代码其实是完全一样的，是客户端的路由导致了请求的分流。在具体实现上，我们一般采用的方式是把路由规则进行集中管理（后面的章节会介绍规则集中管理的服务），在具体调用者端的服务框架上获取规则后进行路由的处理，具体来说是根据服务定位提供服务的那个集群的地址，然后与接口路由规则中的地址一起取交集，得到的地址列表再进行接下来的负载均衡算法，最终得到一个可用的地址去进行调用。</p> <p>讲到这里，读者会发现，基于接口的路由并没有解决接口A的方法1太慢所带来的问题，如果按照上面例子的假设，基于接口路由保证了接口B的方法1和方法2的调用不会受到接口A的方法1的影响，而接口A的方法2还是会受到接口A的方法1的影响。要解决这个问题，我们就需要把路由的规则做得更加细致一点，可以基于接口的具体方法来进行路由。该方式的原理与基于接口路由的原理是一样的，只是在通过接口定位到服务地址列表后，根据接口加方法名从规则中得到一个服务地址列表，再和刚才的地址列表取交集。支持方法的路由就可以解决这个例子中的问题了。</p> <p>沿着这个思路继续思考，既然可以基于接口、方法进行路由，那么还可以基于参数进行路由。基于参数进行路由的实现方式和上面的方法类似，而且代码并不难，但在具体应用中用得较少，因为一般到基于方法的路由就够用了。需要对一些特定参数进行特殊处理（例如针对不同用户的特别处理等）的情况才会使用基于参数的路由。</p> <h5 id="_4-2-3-4-多机房场景"><a href="#_4-2-3-4-多机房场景" class="header-anchor">#</a> 4.2.3.4 多机房场景</h5> <p>每个机房都有自己的容量上限，如果网站的规模非常大，那就需要多个机房了。机房之间的距离和分工决定了我们应该采用什么样的架构和策略，在这一小节中，我们主要讲距离比较近的同城机房的情况（远程的异地机房情况非常复杂，由于篇幅原因就不在此介绍了）。</p> <p>我们回忆一下4.2.3.2节中的一张结构图，如图4-17所示。</p> <p><img src="/assets/img/image-20241008093152768.2845060c.png" alt="image-20241008093152768"></p> <p>图4-17中只表述了调用者、服务提供者和服务注册查找中心之间的关系，没有显示机房的观念。如果我们在同城距离不太远的两个机房中部署应用和服务，会是什么样的结构呢？如图4-18所示。</p> <p><img src="/assets/img/image-20241008093231559.ea78d939.png" alt="image-20241008093231559"></p> <p>我们先不考虑服务注册查找中心的集群化处理，先来重点看一下调用者和服务提供者在多机房的情况。到现在为止，如果不做任何处理，服务注册查找中心会把服务提供者1的所有机器看做是一个集群，尽管它们分布在两个机房。这样，分布在两个机房的调用者1就会对等地看待分布在不同机房的服务提供者1的机器。同城机房之间一般都采用光纤直接连接，带宽足够大，延迟也可以接受，但是，如果能够避免跨机房调用，就能提升系统稳定性，把机房间的带宽用于必要的场景，将会是一个更好的实现。</p> <p>有两种方案可以实现这个想法，一是在服务注册查找中心做一些工作，通过它来甄别不同机房的调用者集群，给它们不同服务提供者的地址。另一种方式是这里要详细介绍的，即通过路由来完成，大概思路是，服务注册查找中心给不同机房的调用者相同的服务提供者列表，我们在服务框架内部进行地址过滤，过滤的原则（如何识别机房）一般是基于接口等路由规则进行集中配置管理。在具体实践中，一方面需要考虑两个甚至多个机房的部署能力是否对等，也就是说通过路由使服务都走本地的话，负载是否均衡。此外还有一个异常的情况需要考虑，即如果某个机房的服务提供者大面积不可用，而另外机房的服务提供者是正常运营并且有余量提供服务，那么应该如何让服务提供者大面积不可用的机房的调用者调用远程的服务呢，这是需要面对和解决的问题。</p> <p>在实际中，每个机房的网段是不同的，这可以帮助我们区分不同的机房。在多机房中还有一个可能遇到的问题：未必每个机房都是对称的（指既有服务调用者又有相应的服务提供者），尤其在机房很多时，这个问题会更加明显。这时，我们可以考虑采用虚拟机房的概念，也就是不以物理机房为单位来做路由，而是把物理上的多个机房看做一个逻辑机房来处理路由规则，当然，也有可能是把一个物理机房拆成多个逻辑机房，具体需要根据业务和应用的特点来做出处理。</p> <h5 id="_4-2-3-5-服务调用端的流控处理"><a href="#_4-2-3-5-服务调用端的流控处理" class="header-anchor">#</a> 4.2.3.5 服务调用端的流控处理</h5> <p>在具体工程实践中会有很多异常的情况，因此在处理完正常功能后，还有很多为了应对异常和可运维而需要做的事情。流量控制（简称流控）保证系统的稳定性，我们这里说的流控是加载到调用者的控制功能，是为了控制到服务提供者的请求的流量。</p> <p>一般来说，我们有两种方式的控制，一种是0-1开关，也就是说完全打开不进行流控；另一种是设定一个固定的值，表示每秒可以进行的请求次数，超过这个请求数的话就拒绝对远程的请求了。那些被流量控制拒绝的请求，可以直接返回给调用者，也可以进行排队。</p> <p>那么我们基于什么维度来进行控制呢？一般来说会从下面两个维度去考虑。</p> <ul><li>根据服务端自身的接口、方法做控制，也就是针对不同的接口、方法设置不同的阈值，这是为了使服务端的不同接口、方法之间的负载不相互影响。</li> <li>根据来源做控制，也就是对于同样的接口、方法，根据不同来源设置不同的限制，这一般用在比较基础的服务上，也就是在多个集群使用同样的服务时，根据请求来源的不同级别等进行不同的流控处理。</li></ul> <h5 id="_4-2-3-6-序列化与反序列化处理"><a href="#_4-2-3-6-序列化与反序列化处理" class="header-anchor">#</a> 4.2.3.6 序列化与反序列化处理</h5> <p>学完了路由和流控就意味着我们可以找到要调用的目标机器了。我们接着看一下协议适配和序列化的问题，也就是说我们要把调用远程服务的对象、参数等变为服务提供者可以理解、传输的数据了。</p> <p>先来看看序列化和反序列化。简单地说，序列化就是把内存对象变为二进制数据的过程，而反序列化就是把二进制数据变为内存中可用对象的过程。服务框架要把本地进程内部的方法调用变为远程的方法调用，首先需要把调用所需的信息从调用端的内存对象变为二进制数据，然后通过网络传到远程的服务提供端，再在服务提供端反序列化数据，得到调用的参数后进行相关调用。</p> <p>常见的序列化和反序列化的方式很多，对于Java而言，Java本身就提供了序列化和反序列化的方式，并且使用起来非常简单。这里有几点需要注意，一是Java序列化或反序列化时自身的性能问题以及跨语言的问题。如果在整个分布式系统中的调用者或者服务提供者要使用Java以外的语言来实现，那么序列化和反序列化的方式选择上就要支持跨语言。第二，序列化和反序列化的性能开销，以及不同方式的性能比较也是需要注意的一个点。第三，还需要注意序列化后的长度。也就是说我们需要在易用性、跨语言、性能、序列化后数据长度等方面综合进行考量。</p> <p>我们从两个方面来看协议的部分，一个是用于通信的数据报文的自定义协议，另一个是远程过程调用本身的协议。下面来看一个具体的例子。</p> <p>还是以之前计算器的例子为例，我们可以选择通过HTTP协议来完成通信过程的处理，那么HTTP协议就是我们选择的通信协议，而在服务调用中的具体协议，需要自己来定义，可以选择XML作为序列化的方式。我们可以这样定义请求和响应的格式。</p> <p>请求格式：</p> <div class="language-xml extra-class"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>request</span><span class="token punctuation">&gt;</span></span> 
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>service</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”xxx”</span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”yyy”</span><span class="token punctuation">&gt;</span></span> 
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>params</span><span class="token punctuation">&gt;</span></span> 
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”zzz</span><span class="token punctuation">&gt;</span></span> 
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param</span><span class="token punctuation">&gt;</span></span> 
         …… 
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>params</span><span class="token punctuation">&gt;</span></span> 
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>service</span><span class="token punctuation">&gt;</span></span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>request</span><span class="token punctuation">&gt;</span></span> 
</code></pre></div><p>响应格式：</p> <div class="language-xml extra-class"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>response</span><span class="token punctuation">&gt;</span></span> 
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span><span class="token punctuation">&gt;</span></span> 
      …… 
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">&gt;</span></span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>request</span><span class="token punctuation">&gt;</span></span> 
</code></pre></div><p>上面的定义中选择XML作为了序列化方式（我们还有其他选择，例如json或者一些二进制的表示方式）。通过XML定义的格式是在服务层面的协议，而在通信层面，我们可以采用HTTP协议，当然也可以通过自定义的协议来完成。</p> <p>这个例子是想给读者展示在整个远程过程调用中的通信协议、服务调用协议及序列化方式。在具体实践中，通信协议和服务调用协议的扩展性、向后兼容性是需要重点考虑的。因为在实践中服务会越来越多，调用者也会越来越多，服务框架在升级时无法保证在同一时刻把所有使用到的地方都进行升级，所以，协议上的扩展性、向后兼容性显得非常重要。在具体制定通信协议时，版本号、可扩展属性及发起方支持能力的介绍很重要。我们很难保证我们协议的扩展性可以支持未来所有的情况，所以显式地标明版本是很必要的做法，这样另一端可以根据具体版本号来进行相应的处理。可扩展的属性有些像键值对的定义，它能方便我们对协议的扩展，避免一增加属性就要修改版本的情况。表明自身服务能力的介绍是为了方便接收端根据请求端的能力来进行相应的处理，例如对于服务调用的具体返回结果的数据来说，如果调用端支持压缩，那么就可以返回被压缩后的数据，否则，服务端就一定不能对结果进行压缩，这个特点有点类似HTTP协议里的Accept-Encoding。</p> <h5 id="_4-2-3-7-网络通信实现选择"><a href="#_4-2-3-7-网络通信实现选择" class="header-anchor">#</a> 4.2.3.7 网络通信实现选择</h5> <p>介绍到这里，一个在调用端的服务请求已经到了网络通信这一层面了。我们在第1章的网络通信部分具体介绍过相关的基础概念，这里介绍具体服务框架中用到的一些技术点，并从服务框架的角度来看一下通信支持。</p> <p>在第1章中我们讲过的通信方式有BIO、NIO、AIO的模式，其中BIO采用的方式是阻塞IO的方式，一个连接需要消耗掉一个线程，这种方式的开发比较简单，但是消耗比较大。采用NIO是一个比较好的选择，是直接采用Java的NIO还是采用第三方封装好的组件，这需要实现者自己来选择。</p> <p>我们采用的是NIO的方式，所以客户端和服务器端的连接是可以复用的，而不是每一个请求独占一个连接。BIO与NIO的对比如下。</p> <p>图4-19展示的是使用BIO的方式，在调用端有三个请求进来，分别由三个线程处理，每个线程都使用独立的连接，在远端的提供者端有对应的三个线程来执行相应的服务。这种方式会使得调用者和提供者之间建立大量的连接，而且是阻塞的方式，连接并不能得到充分利用。</p> <p><img src="/assets/img/image-20241008225508140.20c9faf5.png" alt="image-20241008225508140"></p> <p>我们希望在调用者和提供者之间通过一个连接来进行多个并发请求的通信工作。这就好比公路，每条公路可以同时供多辆车使用，而不是一辆。通过NIO方式可以实现这一愿望（如图4-20所示）。我们需要引入IO线程来专门处理通信功能，因为使用的是非阻塞方式的IO，而需要对外提供的是类似阻塞的同步远程请求的方式，因此需要完成异步转同步的工作，还需要处理调用超时的情况，也需要对应用层发送的数据进行流量保护。</p> <p><img src="/assets/img/image-20241008225645720.f0f39127.png" alt="image-20241008225645720"></p> <p>图4-21是通过同步方式进行远程调用时使用NIO的示意图。可以看到这个方式明显比BIO方式复杂。</p> <p><img src="/assets/img/image-20241008225927773.6a2da4f3.png" alt="image-20241008225927773"></p> <p>从图4-21中可以看到我们增加了IO线程、数据队列、通信对象队列和定时任务4个部分。IO线程专门负责和SOCKET连接打交道，进行数据的收发。需要发送的数据都会进入数据队列，这样，每个请求线程就不需要直接和SOCKET连接打交道了，这也为复用SOCKET连接提供了可能。数据队列的长度是需要关注的方面，因为它可能会造成内存的溢出。通信对象队列是保存了多个线程使用的通信对象，这个通信对象主要是为了阻塞请求线程，请求线程把数据放入数据队列中后会生成一个通信对象，它会进入通信对象队列并且在通信对象队列上等待。通信对象用于唤醒请求线程。如果在远程调用超时前有执行结果返回，那么IO线程就会通知通信对象，通信对象则会结束请求线程的等待，并且把结果传给请求线程，以进行后续处理。此外，我们也有定时任务负责检查通信对象队列中的哪些通信对象已经超时了，然后这些通信对象会通知请求线程已经超时的事实。</p> <h5 id="_4-2-3-8-支持多种异步服务调用方式"><a href="#_4-2-3-8-支持多种异步服务调用方式" class="header-anchor">#</a> 4.2.3.8 支持多种异步服务调用方式</h5> <p>使用NIO能够完成连接复用以及对调用者的同步调用的支持，接下来我们再来详细介绍一下调用方式。除了同步调用外，我们还需要支持如下的几种调用方式。</p> <p>第一种方式是Oneway。Oneway是一种只管发送请求而不关心结果的方式。在NIO方式下使用Oneway的话，会比前面的同步调用简单很多，如图4-22所示。</p> <p><img src="/assets/img/image-20241008230805542.565b9ad8.png" alt="image-20241008230805542"></p> <p>可以看到Oneway方式非常简单，只需要把要发送的数据放入数据队列，然后就可以继续处理后续的任务了；而IO线程也只需要从数据队列中读到数据，然后通过SOCKET连接送出去就好了。Oneway方式不关心对方是否收到了数据，也不关心对方收到数据后做什么或有什么返回。这就基本等价于一个不保证可靠送达的通知。</p> <p>第二种方式是Callback。这种方式下请求方发送请求后会继续执行自己的操作，等对方有响应时进行一个回调，如图4-23所示。</p> <p><img src="/assets/img/image-20241008230938542.664a732d.png" alt="image-20241008230938542"></p> <p>从图4-23可以看到，请求者设置了回调对象，把数据写入数据队列后就继续自己的处理了。后面的IO线程的通信方式与之前看到的相同，只是当收到服务提供者的返回后，IO线程会通知回调对象，这时就执行回调的方法了。而如果需要支持超时，同样可以通过定时任务的方式来完成，如果已经超时却没有返回，那么同样需要执行回调对象的方法，只是要告知是已经超时没有结果。这里需要注意的一点是，如果我们不再引入新的线程，那么回调的执行要么是在IO线程中，要么是在定时任务的线程中了，我们还是建议用新的线程来执行回调，而不要因为回调本身的代码执行时间久等问题影响了IO线程或者定时任务。</p> <p>第三种方式是Future。笔者认为在Java中Future是一个非常便利的方式。我们还是先看一下图4-24。</p> <p><img src="/assets/img/image-20241008231140333.fbe085f1.png" alt="image-20241008231140333"></p> <p>使用Future方式，同样是先把Future放入队列，然后把数据放入队列，接着就在线程中进行处理，等到请求线程的其他工作处理结束后，就通过Future来获取通信结果并直接控制超时。IO线程仍然是从数据队列中得到数据后再进行通信，得到结果后会把它传给Future。</p> <p>第四种方式是可靠异步。可靠异步要保证异步请求能够在远程被执行，一般是通过消息中间件来完成这个保证的。</p> <p>到这里我们介绍了四种常见的异步远程通信方式，Oneway是一个单向的通知；Callback则是回调，是一种很被动的方式，Callback的执行不是在原请求线程中；而Future是一种能够主动控制超时、获取结果的方式，并且它的执行仍然在原请求线程中；可靠异步方式能保证异步请求在远程被执行。</p> <h5 id="_4-2-3-9-使用future方式对远程服务调用的优化"><a href="#_4-2-3-9-使用future方式对远程服务调用的优化" class="header-anchor">#</a> 4.2.3.9 使用Future方式对远程服务调用的优化</h5> <p>学习完同步调用、异步调用的多种实现，我们就已经掌握很完善的通信方式了。这里还需要向大家介绍一个实战中的注意点。</p> <p>在实际的工作中，会出现在一个请求中调用多个远程服务的情况，如图4-25所示。</p> <p><img src="/assets/img/image-20241008231328482.c2b88794.png" alt="image-20241008231328482"></p> <p>在图4-25中，一个请求处理需要调用三个远程服务（在实际中一般会远多于三个），各个服务的耗时已经在图中标出来了。另外在请求者自己的线程中还有20ms的数据处理时间。那么，要完成上图中的一次请求需要100ms（实际消耗的时间也取决于总线程数与CPU的核数，100ms中的大部分时间是在等待远程结果，20ms的数据处理是消耗纯CPU时间的）。我们可以思考一下华罗庚的《统筹方法》，试着改变一下这个线程的处理方式。我们先把图4-25中的场景更详细得表示出来，如图4-26所示。</p> <p><img src="/assets/img/image-20241008231401456.5c6e6c77.png" alt="image-20241008231401456"></p> <p>我们思考能否变成图4-27所示的样子，如下。</p> <p><img src="/assets/img/image-20241008231420950.f9089cd7.png" alt="image-20241008231420950"></p> <p>也就是说，我们仍然是按照调用顺序把服务的请求发送给服务A、服务B和服务C，与前面不同的是，请求发过去后并不直接等待执行结果，而是直到服务C的请求也发出去后再来统一等待服务A、服务B和服务C的执行结果，然后再接着进行本地的数据处理。如果改造成这样的话，整个线程的处理时间就会变为40ms+20ms=60ms，比原来的100ms减少40ms。当然，这里有一个前提，即所调用服务A、服务B、服务C之间并没有相互的依赖关系，举例来说就是调用服务B的时候，并不需要调用服务A所返回的信息。如果各服务之间存在依赖，那就只能等到前一个服务返回后才能进行后续的服务调用。我们之所以能够方便地使用并行调用优化，就是因为有Future方式的支持。并且因为底层使用的是NIO方式，所以并行方式并没有产生额外的开销，反而能使总体消耗时间缩短，在同样的线程数配置、同样硬件的情况下，会使得单位时间的处理能力得到明显提升（具体提升的幅度与单个请求内部远程调用的并行度有关）。</p> <p>接下来，请求通过网络到了服务端，并且在服务端执行有了返回，又通过网络模块得到返回结果，这时就需要进行通信协议解析、数据反序列化的工作了。需要注意的是反序列化工作使用什么线程的问题，一般是使用IO线程，不过这样会影响IO线程的工作效率；另一种方式是把反序列化工作从IO线程转移到其他线程去做，然后再把结果传到等待的请求线程。</p> <h4 id="_4-2-4-服务提供端的设计与实现"><a href="#_4-2-4-服务提供端的设计与实现" class="header-anchor">#</a> 4.2.4 服务提供端的设计与实现</h4> <p>我们通过4.2.3节把请求调用端的过程详细讲述了一遍，接下来我们一起看看服务提供端的情况，如图4-28所示。</p> <p><img src="/assets/img/image-20241009090230091.4640dc4d.png" alt="image-20241009090230091"></p> <h5 id="_4-2-4-1-如何暴露远程服务"><a href="#_4-2-4-1-如何暴露远程服务" class="header-anchor">#</a> 4.2.4.1 如何暴露远程服务</h5> <p>服务端的工作有两部分，一是对本地服务的注册管理，二是根据进来的请求定位服务并执行。我们先来看看服务注册的部分。</p> <p>我们从如何配置远程服务开始。还是用之前的Calculator举例，完整的代码就不重复列出了，下面是传统的配置Spring的一个bean的方式：</p> <div class="language-xml extra-class"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>calculator<span class="token punctuation">&quot;</span></span>  <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.vanadies.CalculatorImpl<span class="token punctuation">&quot;</span></span> <span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span> 
</code></pre></div><p>之前我们看到过在请求调用端的配置，这里来看看服务提供端的配置。</p> <div class="language-xml extra-class"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>calculator<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.vanadies.ServiceFramework.ProviderBean<span class="token punctuation">&quot;</span></span> <span class="token punctuation">&gt;</span></span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>interfaceName<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> 
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>org.vanadies.calculator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>target<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> 
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ref</span> <span class="token attr-name">bean</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>calculatorImpl/&gt; 
&lt;/property&gt; 
&lt;property name=<span class="token punctuation">&quot;</span></span><span class="token attr-name">version&quot;</span><span class="token punctuation">&gt;</span></span> 
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>1.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>group<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> 
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>Test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>calculatorImpl<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.vanadies.CalculatorImpl<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span> 
</code></pre></div><p>上面配置的写法是否似曾相识？与之前在请求调用端看到的配置非常类似和呼应，二者的不同之处有两点。首先，在服务提供端使用的是ProviderBean对象，而在调用请求端使用的是ConsumerBean对象，我们之前看到了ConsumerBean的大概职能和做法，后面会看到ProviderBean的职责。此外，在服务提供端增加了一个属性target，这个属性是要表明具体执行服务的SpringBean，因为ProviderBean本身并不执行具体服务，只是起到调用端代码存根的作用，所以我们需要知道真正执行服务的SpringBean是哪个。其他的例如interfaceName、version、group等属性，与请求调用端的同名属性的含义相同。</p> <p>现在来看看ProviderBean的职能。从前面的介绍我们知道，服务需要注册到服务注册查找中心后才能被服务调用者发现，所以，ProviderBean需要将自己所代表的服务注册到服务注册查找中心。另外，当请求调用端定位到提供服务的机器并且请求被送到提供服务的机器上后，在本机也需要有一个服务与具体对象的对应关系，ProviderBean也需要在本地注册服务和对应服务实例的关系。</p> <h5 id="_4-2-4-2-服务端对请求处理的流程"><a href="#_4-2-4-2-服务端对请求处理的流程" class="header-anchor">#</a> 4.2.4.2 服务端对请求处理的流程</h5> <p>前面我们看到了在服务调用端服务框架与容器、应用的关系，在服务提供端也是一样的情况。无论服务框架以什么方式与应用集成在一起，在启动时都需要监听服务端口。当服务注册都已完成，而且监听端口也准备好时，就只需等着服务调用端的请求进来了。</p> <p>服务端的通信部分同样也不能用BIO来实现，而要采用NIO的方式来实现。接收到请求后，通过协议解析及反序列化，我们可以得到请求发送端调用服务方法的具体信息，根据其中的服务名称、版本号找到本地提供服务的具体对象，然后再用传过来的参数调用相关对象的方法就可以了。</p> <p>之前在请求调用端重点介绍过路由的做法，其中提到了引入服务、方法、参数的路由，并且通过这样的方式解除了调用慢服务对于其他服务的影响。在服务提供端，我们有另外一种方法来解决这个问题。</p> <p>先看一下图4-29所示的流程，如下。</p> <p>这一流程会涉及两个具体问题，第一，在网络通信层，IO线程会进行通信的处理（一般是多个IO线程），在收到完整的数据包、完成协议解析得到序列化后的请求数据时，反序列化在什么线程进行是需要考虑的；第二，得到反序列化后的信息并定位服务后，调用服务在什么线程进行也是需要考虑的。一般来说，调用服务一定是在工作线程（非IO线程）进行的，而反序列化的工作则取决于具体实现，在IO线程或工作线程中进行的方式都有。</p> <p><img src="/assets/img/image-20241009092219206.61b09b70.png" alt="image-20241009092219206"></p> <h5 id="_4-2-4-3-执行不同服务的线程池隔离"><a href="#_4-2-4-3-执行不同服务的线程池隔离" class="header-anchor">#</a> 4.2.4.3 执行不同服务的线程池隔离</h5> <p>服务提供端的工作线程是一个线程池，路由到本地的服务请求会被放入这个线程池执行。如果客户端没有通过接口或方法进行路由，我们就可以在服务提供端进行控制，也就是进行服务端线程池隔离。具体的做法其实十分类似于请求调用方根据接口、方法、参数进行的路由。在服务提供端，工作线程池不是一个，而是多个，当定位到服务后，我们根据服务名称、方法、参数来确定具体执行服务调用的线程池是哪个。这样，不同线程池之间就是隔离的，不会出现争抢线程资源的情况。这就好像把服务提供者的机器隔离开一样，也就是会变成图4-30所示的样子。</p> <p><img src="/assets/img/image-20241009093507051.0cf2cf5c.png" alt="image-20241009093507051"></p> <h5 id="_4-2-4-4-服务提供端的流控处理"><a href="#_4-2-4-4-服务提供端的流控处理" class="header-anchor">#</a> 4.2.4.4 服务提供端的流控处理</h5> <p>将执行服务的线程池隔离会带来服务端稳定性的提升，而流控同样是保证服务端稳定性的重要方式。</p> <p>在服务提供者看来，不同来源的服务调用者、0-1的开关以及限制具体数值的QPS的方式都需要实现。并且在服务提供者这里，某个服务或者方法可以对不同服务调用者进行不同的对待。这样的做法就是对不同的服务调用者进行分级，确保优先级高的服务调用者被优先提供服务。这也是保证稳定性的策略。</p> <p>整个服务框架的功能可以分为服务调用者和服务提供者两方面，此外像序列化、协议、通信等是公用的功能。在具体实现上，是把这些功能都放在一起形成一个完整的服务框架，而不是分为服务调用者框架和服务提供者框架，因为某个服务调用者的服务提供者，可能是另一个服务提供者的服务调用者，它们是相对的。</p> <p>整个服务框架作为一个产品，可以让集中在单机内部的调用变为远程的服务化。在具体应用的使用场景中，一个完整的服务框架可能需要被改变一些行为，例如负载均衡的部分，默认是随机选择服务地址，在有些场景下就需要用权重。因此，服务框架必须做到模块化且可配置；此外，一些特殊的场景需要使用者来具体扩展服务框架的原有功能。这就要求服务框架被很好地模块化，且模块可替换，并留有一定的扩展点来扩展原有功能。</p> <h5 id="_4-2-5-服务升级"><a href="#_4-2-5-服务升级" class="header-anchor">#</a> 4.2.5 服务升级</h5> <p>前面小节介绍的内容都是服务框架非常必要的基础内容。一旦开始使用服务框架，就意味着有非常多的服务落地，也意味着必须要做服务的升级。对于服务的升级，会遇到两种情况。第一种情况是接口不变，只是代码本身进行完善。这样的情况处理起来比较简单，因为提供给使用者的接口、方法都没有变，只是内部的服务实现有变化。这种情况下，采用灰度发布的方式验证然后全部发布就可以了。第二种情况是需要修改原有的接口，这又分为以下两种情况。</p> <p>一是在接口中增加方法，这个情况比较简单，直接增加方法就行了。而且在这样的情况下，需要使用新方法的调用者就使用新方法，原来的调用者继续使用原来的方法即可。</p> <p>二是要对接口的某些方法修改调用的参数列表。这种情况相对复杂一些。我们有几种方式来应对：</p> <ul><li>对使用原来方法的代码都进行修改，然后和服务端一起发布。这从理论上说是个办法，但是不太可行，因为这要求我们同时发布多个系统，而且一些系统可能并不会从调整参数后的方法那里受益。</li> <li>通过版本号来解决。这是比较常用的方式，使用老方法的系统继续调用原来版本的服务，而需要使用新方法的系统则使用新版本的服务。</li> <li>在设计方法上考虑参数的扩展性。这是一个可行的方式，但是不太好，因为参数列表可扩展一般就意味着是采用类似Map的方式来传递参数，这样不直观，并且对参数的校验会比较复杂。</li></ul> <h3 id="_4-3-实战中的优化"><a href="#_4-3-实战中的优化" class="header-anchor">#</a> 4.3 实战中的优化</h3> <p>有了服务框架，集中式系统就会很方便地转变为分布式系统。但是有下面几个问题需要注意。</p> <p>1.服务的拆分</p> <p>要拆分的服务是需要为多方提供公共功能的，对于那些比较专用的实现，查出来它们是独立部署在远程机器上来提供服务的，这不仅没必要，还会增加系统的复杂性。</p> <p>2.服务的粒度</p> <p>这是一个很难量化回答的问题，只能说需要根据业务的实际情况来划分服务。</p> <p>3.优雅和实用的平衡</p> <p>服务化的架构看起来比较优雅，可毕竟多一次调用就比之前多走了一次网络，一些功能直接在服务调用者的机器上实现会更加合适、经济。例如我们看下面的一个例子，如图4-31所示。</p> <p><img src="/assets/img/image.a727a253.png" alt="alt text"></p> <p>服务提供者使用数据库进行数据的存储，使用缓存来缓解数据库的压力。服务提供者对外提供数据的读写服务，当然，里面还包含了一定的业务逻辑。服务调用者通过服务提供者提供的读写服务进行数据库的访问。</p> <p>这个结构看起来没什么问题，也比较优雅。但是深入分析一下就会发现，如果服务调用者读取数据的频率非常高的话，让服务调用者直接读取缓存会更合适。也就是说，我们需要做一个客户端，其中包含了服务提供者所提供服务的所有接口，并且有一定的代码逻辑。这个逻辑就是把读取缓存的逻辑直接放到服务调用者那里来执行，如果缓存读取成功就结束，否则就到服务提供者那里去进行读数据库、更新缓存的操作。其他写操作则还是直接由服务提供者来处理，如图4-32所示。</p> <p><img src="/assets/img/image-1.c1ce646b.png" alt="alt text"></p> <p>这样的结构看起来没有图4-31中的结构优雅，但是这是一个比较实用的方案。大部分对数据的请求直接走一次缓存就可以了，只有少部分没有命中缓存的数据读取需要走服务提供者，然后再到数据库进行读取并插入缓存。</p> <p>4.分布式环境中的请求合并</p> <p>这个问题和前一个问题类似，都是与优化有关的问题。我们知道，服务调用就是为了完成数据的读、写和计算。而在大型的分布式系统中，我们能否合并相关的读、写、计算任务，这是需要认真思考的问题，因为对于热点数据的处理，如果可以进行一些任务的合并处理，就会明显降低整个系统的负载。我们先看一个单机中的例子。在单机多线程的应用中可能会有一些操作比较消耗系统资源，如果能够进行一些合并的话，就会提升处理效率，我们看一个具体的例子，如图4-33所示。</p> <p><img src="/assets/img/image-2.f4584e8b.png" alt="alt text"></p> <p>假设要为单机写一个根据请求去读取数据并计算生成报表的应用，最简单的方式是把逻辑写好，然后做成线程安全的。在执行过程中，我们需要从远程读取大量数据，然后进行复杂的统计计算，最后生成报表。我们可以增加缓存来减少数据读取和计算的工作量，例如同样参数的报表，如果已经有请求计算过，那么之后的请求直接用结果就行了。缓存的有效时间根据业务的特性来决定。这是一种优化方法，再来看另一个思路，如图4-34所示。</p> <p>图4-34展示的线程执行逻辑为，解析完参数后，检查是否有其他线程在计算了，如果没有，则进行计算；如果已经有线程在计算相同的数据，就等待其他线程的计算结果。具体的实现上可以依赖Future方式。</p> <p><img src="/assets/img/image-3.d6f0efd9.png" alt="alt text"></p> <p>但是把这个思路移植到分布式的环境中时，会有新的问题要解决，如图4-35所示。</p> <p><img src="/assets/img/image-4.a353d509.png" alt="alt text"></p> <p>相对于单机的多线程，分布式环境会涉及多个节点。在单机中判断是否有同样任务在执行是很简单的，而在多机环境中，则需要由独立于服务调用者、服务提供者之外的节点来完成相关工作，也就是需要分布式的锁服务来控制。但是这是需要进行权衡的，因为在分布式系统中，如果每个请求都要走一次分布式的锁服务来进行控制，就会有额外的开销。另一个思路是，在服务调用端不是把请求随机分发给服务提供者，而是根据一定的规则把同样的请求发送到同一个服务提供者上，然后在服务提供者的机器上做单机控制，这样通过路由策略的选择，可以不引入分布式锁服务，减少了复杂性。此外，对于比较消耗系统资源的操作，不论是使用分布式锁服务，还是采用路由的方式把请求送到特定机器，在服务调用者上都可以进行单机多线程的控制。具体采用何种方式，需要根据具体场景来决定，而且需要数据的支持来做出最后的决定。</p> <h3 id="_4-4-为服务化护航的服务治理"><a href="#_4-4-为服务化护航的服务治理" class="header-anchor">#</a> 4.4 为服务化护航的服务治理</h3> <p>前面几节介绍了服务框架相关的设计和实战中的优化，我们接着介绍一下服务治理。服务治理是在系统采用服务框架后，为服务化保驾护航的功能集合。</p> <p>从集中式应用走向了分布式系统后，整个系统的结构和依赖会比之前复杂很多，而服务框架是串起整个系统的一个重要通路。我们将会有很多的服务提供者、服务调用者以及大量的服务，因此，对这些服务的治理是一个很重要的话题。我们重点看看服务治理应该完成什么样的工作，至于具体的实现方式则会因不同实现者而不同。</p> <p>我们可以将服务治理分为管理服务和查看服务这两个方面，也就相当于数据的写和读：管理需要我们去控制、操作整个分布式系统中的服务，而查看则是看运行时的状态或者一些具体信息、历史数据等。</p> <p>我们首先看一下服务查看具体包括哪些内容。</p> <ul><li>服务信息：服务最基本的信息。</li> <li>服务编码，即数字化的服务编码</li> <li>支持编码的注册</li> <li>根据编码定位服务信息</li> <li>服务质量：根据被调用服务的出错率、响应时间等数据对服务质量进行的评估。</li> <li>最好、最差的服务排行</li> <li>各个服务的质量趋势</li> <li>各种查询条件的支持</li> <li>服务容量：根据所提供服务的总能力以及当前所使用容量进行的评估，其中能力是指对于请求数量方面的支撑情况。</li> <li>服务容量与当前水位的展示</li> <li>历史趋势图</li> <li>根据水位的高低排序</li> <li>各种查询条件的支持</li> <li>服务依赖：根据服务被调用以及服务调用其他服务的情况，给出服务与其上下游服务的依赖关系，里面除了服务间定性的依赖关系外，还有定量的数据信息。</li> <li>依赖服务展示</li> <li>被依赖展示</li> <li>依赖变化</li> <li>服务分布：提供同样服务的机器的具体分布情况，主要是看跨机房的分布情况。</li> <li>服务在不同机房分布</li> <li>服务在不同机柜分布</li> <li>分布不均衡服务列表</li> <li>服务统计：服务运行时信息的统计。</li> <li>调用次数统计和排名</li> <li>出错次数统计和排名</li> <li>出错率统计和排名</li> <li>响应时间统计和排名</li> <li>响应时间趋势</li> <li>出错率趋势</li> <li>服务元数据：服务基本信息的查看。</li> <li>服务的方法和参数</li> <li>服务查询：提供根据各种条件来检索服务进而查看服务的各种信息的功能。</li> <li>服务的应用负责人、测试负责人</li> <li>服务所属的应用名称</li> <li>服务发布时间</li> <li>服务提供者的地址列表</li> <li>服务容量</li> <li>服务质量</li> <li>服务调用次数</li> <li>服务依赖</li> <li>服务版本及归组信息等</li> <li>服务报表：主要提供非实时服务的各种统计信息的报表，包括不同时间段的对比以及分时统计的信息。</li> <li>服务监视：提供对于服务运行时关键数据的采集、规则处理和告警。注意这里是服务监视而非监控，主要是完成对于服务运行数据的收集和处理，但不提供控制，通过监视发现问题后再在相应的服务管理中进行管理工作。服务监视只提供用于决策的数据基础，并且根据已定义的规则进行告警。</li></ul> <p>接着我们从服务管理的角度看一下有哪些事情要做。
服务上下线：前面看到服务是通过ProviderBean自动注册的，在治理中我们还需要控制服务的上下线。</p> <ul><li>针对一个服务所有机器的上线和下线操作</li> <li>针对指定机器的上线和下线操作</li> <li>DoubleCheck控制</li> <li>服务路由：是对服务路由策略的管理，就是之前看到的基于接口、方法、参数的路由的集中管理。</li> <li>路由管理界面支持</li> <li>路由信息更改前后对比和验证</li> <li>路由配置多版本管理和回滚</li> <li>DoubleCheck控制</li> <li>服务限流降级：对应的是之前介绍过的流控部分，服务降级是对服务对外流控的统一管理。当然，除了管理流控外，还集中管理了服务上的很多开关。例如，在服务调用或者执行的地方，除了限流还可以停止一些非重要功能的处理，以便主流程可以继续执行。
服务归组：是在集中的控制台调整服务的分组信息，对应我们在服务提供者的配置属性中看到的group属性，可以在集中的控制台对服务的分组直接进行管理。</li> <li>归组规则的多版本管理和回滚</li> <li>归组规则预览</li> <li>归组规则的影响范围和评估</li> <li>DoubleCheck控制</li> <li>服务线程池管理：是对于服务提供者的服务执行的工作线程池的管理。</li> <li>调用方的线程管理，主要是最大并发的管理</li> <li>服务端线程工作状况查询</li> <li>服务端针对不同服务的多个业务线程池的管理</li> <li>DoubleCheck控制</li> <li>服务授权：随着服务和服务调用者的增多，一些重要服务的使用是需要有授权和鉴权的支持的，服务授权就是针对服务调用者的授权管理。</li> <li>授权信息查询</li> <li>授权规则多版本支持和回滚</li> <li>DoubleCheck控制</li></ul> <h3 id="_4-5-服务框架与esb的对比"><a href="#_4-5-服务框架与esb的对比" class="header-anchor">#</a> 4.5 服务框架与ESB的对比</h3> <p>企业服务总线（ESB）也是系统在采用服务化时的一个重要支撑产品，这一节我们看一下本章所讲的服务框架与企业服务总线的对比。</p> <p>图4-36是ESB结构的一个简图。ESB的概念是从面向服务体系架构中（SOA）发展过来的，它是对多样系统中的服务调用者和服务提供者的解耦。ESB本身也可以解决服务化的问题，它提供了服务暴露、接入、协议转换、数据格式转换、路由等方面的支持。ESB与服务框架主要有两个差异，第一，服务框架是一个点对点的模型，而ESB是一个总线式的模型；第二，服务框架基本上是面向同构的系统，不会重点考虑整合的需求，而ESB会更多地考虑不同厂商所提供服务的整合。</p> <p><img src="/assets/img/image-5.3172b739.png" alt="alt text"></p> <h3 id="_4-6-总结"><a href="#_4-6-总结" class="header-anchor">#</a> 4.6 总结</h3> <p>到这里，服务框架的介绍就结束了。服务框架为我们的应用提供了从集中式系统转向分布式系统的基础支持（如图4-37所示）。有了服务框架的支持，我们可以很容易地对原来集中在一个应用中的各种代码、操作进行梳理，然后变为不同的服务调用者和服务提供者，而通过Spring使用服务框架的配置与使用单机的Spring Bean的配置差别不大，不过在具体的代码调试和问题定位上，分布式系统中还是比单机要麻烦，我们处理完服务框架、服务治理后，还需要针对自身的测试环境去完成一些相关的工作，以助于进行开发中的调试和问题定位。</p> <p><img src="/assets/img/image-6.b33410bd.png" alt="alt text"></p> <p>服务框架帮助我们完成了应用的架构变化，在第5章我们一起来看看引入中间件以后，应用对数据库进行访问方面的变化，也就是数据访问层。</p> <h2 id="第5章-数据访问层"><a href="#第5章-数据访问层" class="header-anchor">#</a> 第5章 数据访问层</h2> <p>第4章介绍的服务框架可以使应用从集中式走向分布式，解决了当网站功能越来越丰富时，单个应用越来越庞大的问题，使整个系统走向服务化的架构。随着数据量和访问量的上升，应用使用的数据库也会遇到问题，这就需要数据访问层出场了。</p> <h3 id="_5-1-数据库从单机到分布式的挑战和应对"><a href="#_5-1-数据库从单机到分布式的挑战和应对" class="header-anchor">#</a> 5.1 数据库从单机到分布式的挑战和应对</h3> <h4 id="_5-1-1-从应用使用单机数据库开始"><a href="#_5-1-1-从应用使用单机数据库开始" class="header-anchor">#</a> 5.1.1 从应用使用单机数据库开始</h4> <p>我们在构建网站时会使用数据库来作为数据管理的基础软件。使用不同的语言、在不同平台上的网站都有各自解决数据库访问问题的组件和方式，各种类似ODBC、JDBC的封装以及ORM的处理都已经比较成熟，我们在这一章里不会重点介绍这些内容。我们要讲的是在一个大型系统底层的数据量和访问量逐步增大的过程中，该系统将要面临的问题和相应的解决方案。</p> <p>使用数据库是存储、读取数据的一种选择，接下来我们主要介绍以数据库为基础时，数据访问层能够带给我们什么便利。而是否使用关系型数据库解决业务问题不是本章讨论的重点。</p> <p>我们还是从最简单的应用说起，如图5-1所示。我们基于Java技术构建网站，使用JDBC方式来连接数据库。在网站初期，这会运行得很好，所有的业务数据都可以放在一个数据库中来管理。</p> <p><img src="/assets/img/image-11.3ccf014d.png" alt="alt text"></p> <h4 id="_5-1-2-数据库垂直-水平拆分的困难"><a href="#_5-1-2-数据库垂直-水平拆分的困难" class="header-anchor">#</a> 5.1.2 数据库垂直/水平拆分的困难</h4> <p>随着网站业务的快速发展，数据量和访问量不断上升，数据库的压力越来越大。更换更好的硬件（Scale Up）是一种解决方案，而且在我们能付得起硬件费用并且没有到达硬件单机瓶颈时，这也是一个比较简单的解决方案。这有点像我们自己家中计算机的升级换代。但是数据和访问量的增长很容易就会超过单机的极限，我们需要找其他的方式来解决问题。</p> <p>在不靠升级硬件的情况下，能够想到的处理方案就是给现有数据库减压。减压的思路有三个，一是优化应用，看看是否有不必要的压力给了数据库（应用优化）；二是看看有没有其他办法可以降低对数据库的压力，例如引入缓存、加搜索引擎等；最后一种思路就是把数据库的数据和访问分到多台数据库上，分开支持，这也是我们的核心思路和逻辑。</p> <p>数据拆分有两种方式，一个是垂直拆分，一个是水平拆分。垂直拆分就是把一个数据库中不同业务单元的数据分到不同的数据库里面，水平拆分是根据一定的规则把同一业务单元的数据拆分到多个数据库中。先论是垂直拆分还是水平拆分，最后的结果都是将原来在一个数据库中的数据拆分到了不同的数据库中。所以原来单机数据库可以支持的特性现在就未必支持了。</p> <p>垂直拆分会带来如下影响：</p> <ul><li><p>单机的ACID保证被打破了。数据到了多机后，原来在单机通过事务来进行的处理逻辑会受到很大的影响。我们面临的选择是，要么放弃原来的单机事务，修改实现，要么引入分布式事务。</p></li> <li><p>一些Join操作会变得比较困难，因为数据可能已经在两个数据库中了，所以不能很方便地利用数据库自身的Join了，需要应用或者其他方式来解决。</p></li> <li><p>靠外键去进行约束的场景会受影响。</p></li></ul> <p>水平拆分会带来如下影响：</p> <ul><li>同样有可能有ACID被打破的情况。</li> <li>同样有可能有Join操作被影响的情况。</li> <li>靠外键去进行约束的场景会有影响。</li> <li>依赖单库的自增序列生成唯一ID会受影响。</li> <li>针对单个逻辑意义上的表的查询要跨库了。</li></ul> <p>可以看到，数据库的拆分给应用带来的影响还是比较明显的，这里面列出的只是其中一部分。在实践中，只要是操作数据被拆分到不同库中的情况，就都会受到影响，例如原来的一些存储过程、触发器等也需要改写才能完成相应的工作了。</p> <p>接下来，我们分析一下前面提到的具体问题及其应对。</p> <h4 id="_5-1-3-单机变为多机后-事务如何处理"><a href="#_5-1-3-单机变为多机后-事务如何处理" class="header-anchor">#</a> 5.1.3 单机变为多机后，事务如何处理</h4> <p>事务的支持对业务来说是一个非常重要的特性，数据库软件对单机的ACID的事务特性的支持是比较到位的，而一旦进行垂直或水平拆分后，我们所要面对的就是多个数据库的节点了，也就是分布式事务了，这是一个难题。</p> <h5 id="_5-1-3-1-了解分布式事务的知识"><a href="#_5-1-3-1-了解分布式事务的知识" class="header-anchor">#</a> 5.1.3.1 了解分布式事务的知识</h5> <p>分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于分布式系统的不同节点上。对于传统的单机上的事务，所有的事情都在这一台机器上完成，而在分布式事务中，会有多个节点参与。</p> <p>1.分布式事务模型与规范</p> <p>X/Open组织（即现在的The Open Group）提出了一个分布式事务的规范——XA。在看XA之前，我们先看一下X/Open组织定义的分布式事务处理模型——X/Open DTP模型（X/Open Distributed Transaction Processing Reference Model）。在X/Open DTP模型中定义了三个组件，即Application Program、Resource Manager和Transaction Manager，分别介绍如下。</p> <ul><li><p>Application Program（AP），即应用程序，可以理解为使用DTP模型的程序。它定义了事务边界，并定义了构成该事务的应用程序的特定操作。</p></li> <li><p>Resource Manager（RM），资源管理器，可以理解为一个DBMS系统，或者消息服务器管理系统。应用程序通过资源管理器对资源进行控制，资源必须实现XA定义的接口。资源管理器提供了存储共享资源的支持。</p></li> <li><p>Transaction Manager（TM），事务管理器，负责协调和管理事务，提供给AP应用程序编程接口并管理资源管理器。事务管理器向事务指定标识，监视它们的进程，并负责处理事务的完成和失败。事务分支标识（称为XID）由TM指定，以标识一个RM内的全局事务和特定分支。它是TM中日志与RM中日志之间的相关标记。两阶段提交或回滚需要XID，以便在系统启动时执行再同步操作（也称为再同步（resync）），或在需要时允许管理员执行试探操作（也称为手工干预）。</p></li></ul> <p>在这三个组件中，AP可以和TM、RM通信，TM和RM之间可以互相通信。DTP模型里面定义了XA接口，TM和RM通过XA接口进行双向的通信，如图5-2所示。</p> <p><img src="/assets/img/image-12.a09094cc.png" alt="alt text"></p> <p>从图5-2可以看到，AP和RM是一定需要的，而事务管理器TM是我们额外引入的。之所以要引入事务管理器，是因为在分布式系统中，两台机器理论上无法达到一致的状态，需要引入一个单点进行协调。事务管理器控制着全局事务，管理事务的生命周期，并协调资源。</p> <p>在DTP中还定义了其他几个概念，如下。</p> <ul><li>事务：一个事务是一个完整的工作单元，由多个独立的计算任务组成，这多个任务在逻辑上是原子的。</li> <li>全局事务：一次性操作多个资源管理器的事务就是全局事务。</li> <li>分支事务：在全局事务中，每一个资源管理器有自己独立的任务，这些任务的集合是这个资源管理器的分支任务。</li> <li>控制线程：用来表示一个工作线程，主要是关联AP、TM和RM三者的线程，也就是事务上下文环境。简单地说，就是用来标识全局事务和分支事务关系的线程。</li></ul> <p>我们看一下整体DTP的模型，如图5-3所示。</p> <p><img src="/assets/img/image-13.3355c751.png" alt="alt text"></p> <p>图5-3所示的是一个具体使用DTP模型的例子，解释如下。</p> <ul><li><p>AP与RM之间，可以使用RM自身提供的native API进行交互，这种方式就是使用RM的传统方式，并且这个交互不在TM的管理范围内。另外，当AP和RM之间需要进行分布式事务的时候，AP需要得到对RM的连接（此链接由TM管理），然后使用XA的native API来进行交互。</p></li> <li><p>AP与TM之间，该例子中使用的是TX接口，也是由X/Open所规范的。它用于对事务进行控制，包括启动事务、提交事务和回滚事务。</p></li> <li><p>TM与RM之间是通过XA接口进行交互的。TM管理了到RM的连接，并实现了两阶段提交。</p></li></ul> <p>2.两阶段提交</p> <p>我们接下来看一下两阶段提交协议，即2PC，Two Phase Commitment Protocol。之所以称为两阶段提交，是相对于单库的事务提交方式来说的。我们在单库上完成相关的数据操作后，就会直接提交或者回滚，而在分布式系统中，在提交之前增加了准备的阶段，所以称为两阶段提交。</p> <p>图5-4显示的就是第一阶段提交的情况，可以看到，参与操作的是事务管理器与两个资源。</p> <p><img src="/assets/img/image-14.4942925d.png" alt="alt text"></p> <p>图5-5所示的是第二阶段的情况。</p> <p><img src="/assets/img/image-15.3ae01609.png" alt="alt text"></p> <p>此外还会遇到的另外一种情况，就是在准备阶段有一个资源失败，那么在第二阶段的处理就是回滚所有资源，如图5-6和图5-7所示。</p> <p><img src="Large-scale_website_system_and_Java_middleware_practice.assets/image-16.png" alt="alt text"></p> <p><img src="Large-scale_website_system_and_Java_middleware_practice.assets/image-17.png" alt="alt text"></p> <p>前面对两阶段提交的介绍都是在理想状态下的情况。在实际当中，由于事务管理器自身的稳定性、可用性的影响，以及网络通信中可能产生的问题，出现的情况会复杂很多。此外，事务管理器在多个资源之间进行协调，它自身要进行很多日志记录的工作。网络上的交互次数的增多以及引入事务管理器的开销，是使用两阶段提交协议使分布式事务的开销增大的两个方面。</p> <p>因此，在进行垂直拆分或者水平拆分后，需要想清楚是否一定要引入两阶段的分布式事务，在必要的情况下才建议使用。</p> <blockquote><p>这里也列一下两阶段提交协议的参考资料的链接：
http://en.wikipedia.org/wiki/Two-phase_commit_protocol</p></blockquote> <h5 id="_5-1-3-2-大型网站一致性的基础理论-cap-base"><a href="#_5-1-3-2-大型网站一致性的基础理论-cap-base" class="header-anchor">#</a> 5.1.3.2 大型网站一致性的基础理论——CAP/BASE</h5> <p>分布式事务希望在多机环境下可以像单机系统那样做到强一致，这需要付出比较大的代价。而在有些场景下，接收状态并不用时刻保持一致，只要最终一致就行。我们这节一了解下CAP理论及其对于大型网站的意义。</p> <p>CAP理论是Eric Brewer在2000年7月份的PODC会议上提出的（可能提出这个理论的时间出乎很多读者的意料），CAP的涵义如下。</p> <p>Consistency：all nodes see the same data at the same time，即所有的节点在同一时间读到同样的数据。这就是数据上的一致性（用C表示），也就是当数据写入成功后，所有的节点会同时看到这个新的数据。</p> <p>Availability：a guarantee that every request receives a response about whether it was successful or failed，保证无论是成功还是失败，每个请求都能够收到一个反馈。这就是数据的可用性（用A表示），这里的重点是系统一定要有响应。</p> <p>Partition-Tolerance：the system continues to operate despite arbitrary message loss or failure of part of the system，即便系统中有部分问题或者有消息的丢失，但系统仍能够继续运行。这被称为分区容忍性（用P表示），也就是在系统的一部分出现问题时，系统仍能继续工作。</p> <p>但是，在分布式系统中并不能同时满足上面三项。图5-8更直观地解释了CAP理论，就是圆的总面积是不变的，我们不能同时增大C、A、P三者的面积，我们可以选择其中两个来提升，而另外一个则会受到损失。那么，在进行系统设计和权衡时，其实就是在选择CA、AP或是CP。</p> <ul><li>选择CA，放弃分区容忍性，加强一致性和可用性。这其实就是传统的单机数据库的选择。</li> <li>选择AP，放弃一致性，追求分区容忍性及可用性。这是很多分布式系统在设计时的选择，例如很多NoSQL系统就是如此。</li> <li>选择CP，放弃可用性，追求一致性和分区容忍性。这种选择下的可用性会比较低，网络的问题会直接让整个系统不可用。</li></ul> <p>从上面的分析可以看出，在分布式系统中，我们一般还是选择加强可用性和分区容忍性而牺牲一致性。当然，这里所讲的并不是不关心一致性，而是首先满足A和P，然后看如何解决C的问题。</p> <p>我们再来看看BASE模型，BASE涵义如下。</p> <ul><li>Basically Available：基本可用，允许分区失败。</li> <li>Soft state：软状态，接受一段时间的状态不同步。</li> <li>Eventually consistent：最终一致，保证最终数据的状态是一致的。</li></ul> <p>当我们在分布式系统中选择了CAP中的A和P后，对于C，我们采用的方式和策略就是保证最终一致，也就是不保证数据变化后所有节点立刻一致，但是保证它们最终是一致的。在大型网站中，为了更好地保持扩展性和可用性，一般都不会选择强一致性，而是采用最终一致的策略来实现。</p> <h5 id="_5-1-3-3-比两阶段提交更轻量一些的paxos协议"><a href="#_5-1-3-3-比两阶段提交更轻量一些的paxos协议" class="header-anchor">#</a> 5.1.3.3 比两阶段提交更轻量一些的Paxos协议</h5> <p>下面介绍Paxos协议，它是一个比两阶段提交要轻量的保证一致性的协议。</p> <p>在分布式系统中，节点之间的信息交换有两种方式，一种是通过共享内存共用一份数据；另一种是通过消息投递来完成信息的传递。而在分布式系统中，通过消息投递的方式会遇到很多意外的情况，例如网络问题、进程挂掉、机器挂掉、进程很慢没有响应、进程重启等情况，这就会造成消息重复、一段时间内部不可达等现象。Paxos协议是帮助我们解决分布式系统中一致性问题的一个方案。</p> <p>使用Paxos协议有一个前提，那就是不存在拜占庭将军问题。拜占庭位于现在土耳其的伊斯坦布尔，是东罗马帝国的首都。当时拜占庭罗马帝国国土辽阔，防御敌人的各个军队都分隔很远，将军与将军之间只能靠信差传消息。在战争时，拜占庭军队内所有将军和副官必须达成共识，决定出是否有赢的机会才去攻打敌人的阵营。但是，在军队内可能有叛徒或敌军的间谍，扰乱将军们的决定又扰乱整体军队的秩序，他们使得最终的决定结果并不代表大多数人的意见。这时，在已知有成员谋反的情况下，其余忠诚的将军应该如何不受叛徒的影响达成一致的协议？拜占庭将军问题就此形成。也就是说，拜占庭将军问题是一个没有办法保证可信的通信环境的问题，Paxos的前提是有一个可信的通信环境，也就是说信息都是准确的，没有被篡改。</p> <p>Paxos算法的提出过程是，虚拟了一个叫做Paxos的希腊城邦，并通过议会以决议的方式介绍Paxos算法。</p> <p>首先把议员的角色分为了Proposers、Acceptors和Learners，议员可以身兼数职，介绍如下。</p> <ul><li>Proposers，提出议案者，就是提出议案的角色。</li> <li>Acceptors，收到议案后进行判断的角色。Acceptors收到议案后要选择是否接受（Accept）议案，若议案获得多数Acceptors的接受，则该议案被批准（Chosen）。</li> <li>Learners，只能“学习”被批准的议案，相当于对通过的议案进行观察的角色。</li></ul> <p>在Paxos协议中，有两个名词介绍如下。</p> <ul><li>Proposal，议案，由Proposers提出，被Acceptors批准或否决。</li> <li>Value，决议，议案的内容，每个议案都是由一个{编号，决议}对组成。</li></ul> <p>在角色划分后，可以更精确地定义问题，如下所述：</p> <ul><li>决议（Value）只有在被Proposers提出后才能被批准（未经批准的决议称为“议案（Proposal）”）。</li> <li>在Paxos算法的执行实例中，一次只能批准（Chosen）一个Value。</li> <li>Learners只能获得被批准（Chosen）的Value。</li></ul> <p>对议员来说，每个议员有一个结实耐用的本子和擦不掉的墨水来记录议案，议员会把表决信息记在本子的背面，本子上的议案永远不会改变，但是背面的信息可能会被划掉。每个议员必须（也只需要）在本子背面记录如下信息：</p> <ul><li>LastTried[p]，由议员p试图发起的最后一个议案的编号，如果议员p没有发起过议案，则记录为负无穷大。</li> <li>PreviousVote[p]，由议员p投票的所有表决中，编号最大的表决对应的投票，如果没有投过票则记录为负无穷大。</li> <li>NextBallot[p]，由议员p发出的所有LastVote(b，v)消息中，表决编号b的最大值。</li></ul> <p>基本协议的完整过程如下。</p> <p>（1）议员p选择一个比LastTried[p]大的表决编号b，设置LastTried[p]的值为b，然后将NextBallot(b)消息发送给某些议员。
（2）从p收到一个b大于NextBallot[q]的NextBallot(b)消息后，议员q将NextBallot[q]设置为b，然后发送一个LastVote(b，v)消息给p，其中v等于PreviousVote[q]（b？NextBallot[q]的NextBallot(b)消息将被忽略）。
（3）在某个多数集合Q中的每个成员都收到一个LastVote(b，v)消息后，议员p发起一个编号为b、法定人数集为Q、议案为d的新表决。然后它会给Q中的每一个牧师发送一个BeginBallot(b，d)消息。
（4）在收到一个b=NextBallot[q]的BeginBallot(b，d)消息后，议员q在编号为b的表决中投出他的一票，设置PreviousVote[p]为这一票，然后向p发送Voted(b，q)消息。
（5）p收到Q中每一个q的Voted(b，q)消息后（这里Q是表决b的法定人数集合，b=LastTried[p]），将d（这轮表决的法令）记录到他的本子上，然后发送一条Success(d)消息给每个q。
（6）一个议员在接收到Success(d)消息后，将决议d写到他的本子上。</p> <p>从上面的介绍可以看出，Paxos不是那么容易理解的，不过总结一下核心的原则就是少数服从多数。</p> <p>大家会发现，如果系统中同时有人提议案的话，可能会出现碰撞失败，然后双方都需要增加议案的编号再提交的过程。而再次提交可能仍然存在编号冲突，因此双方需要再增加编号去提交。这就会产生活锁。</p> <p>解决的办法是在整个集群当中设一个Leader，所有的议案都由他来提，这样就可以避免这种冲突了。这其实是把提案的工作变为一个单点，而引发的新问题是如果这个Leader出问题了该如何处理，那就需要再选一个Leader出来。</p> <blockquote><p>以上对于Paxos的介绍只是一个非常基础的介绍，读者如果想对此有更深入的了解，可以阅读The Part-Time Parliament、Paxos Made Simple、Consensus on Transaction Commit、Cheap Paxos、Fast Paxos等论文，也可以参考维基百科上Paxos的资料，网址为-http://en.wikipedia.org/wiki/Paxos_(computer_science)。</p></blockquote> <h5 id="_5-1-3-4-集群内数据一致性的算法实例"><a href="#_5-1-3-4-集群内数据一致性的算法实例" class="header-anchor">#</a> 5.1.3.4 集群内数据一致性的算法实例</h5> <p>关于集群内数据的一致性，我们通过Quorum和Vector Clock算法来具体讲解一下，亚马逊Dynamo的论文中对Quorum和Vector Clock有比较详细的介绍。</p> <p>先来看Quorum，它是用来权衡分布式系统中数据一致性和可用性的，我们引入三个变量，如下。</p> <ul><li>N：数据复制节点数量。</li> <li>R：成功读操作的最小节点数。</li> <li>W：成功写操作的最小节点数。</li></ul> <p>如果W+R＞N，是可以保证强一致性的，而如果W+R＜N，是能够保证最终一致性的。</p> <p>根据前面的CAP理论，我们需要在一致性、可用性和分区容忍性方面进行权衡。例如，如果让W=N且R=1，就会大大降低可用性，但是一致性是最好的。</p> <p>Vector Clock的思路是对同一份数据的每一次修改都加上“&lt;修改者，版本号&gt;”这样一个信息，用于记录修改者的信息及版本号，通过这样的信息来帮助我们解决一些冲突。</p> <p>假设有如下场景：
Alice、Ben、Catby和Dave四人约定下周要一起聚餐，四个人通过邮件商量聚餐的时间。</p> <div class="language-text extra-class"><pre class="language-text"><code>Alice首先建议周三聚餐。
之后Dave和Catby商量觉得周四更合适。
后来Dave又和Ben商量之后觉得周二也行。
最后Alice要汇总大家的意见，得到的反馈如下：
Catby说，他和Dave商量的时间周四。
Ben说，他和Dave商量的时间是周三。
</code></pre></div><p>此时恰好联系不上Dave，而且不知道Catby和Ben分别与Dave确定时间的先后顺序。</p> <div class="language-text extra-class"><pre class="language-text"><code>Alice就不能确定到底该定在哪一天了。
</code></pre></div><p>类似的事情经常会发生。当你向两个或几个人问一些消息时，返回的内容往往不一样，而且你不知道哪个是最新的。Vector Clock就是为了解决这种问题而设计的，简单来说，就是为每一个商议结果附上一个时间戳，当结果改变时，更新时间戳。加上时间戳后，我们再一次描述上面的场景，如下。</p> <p>当Alice第一次提议将时间定为周三时，可以这样描述这个信息：</p> <div class="language-text extra-class"><pre class="language-text"><code>data = Wednesday 
vclock = Alice:1 
</code></pre></div><p>vclock就是这条消息的Vector Clock，Alice：1表示这是从Alice发出的第一个版本。接着，Dave和Ben商量将时间改为周二，Ben发给Dave的消息如下：</p> <div class="language-text extra-class"><pre class="language-text"><code>data = Tuesday 
vclock = Alice:1, Ben:1 
</code></pre></div><p>vclock就是这条消息的Vector Clock，Alice：1表示这是从Alice发出的第一个版本。接着，Dave和Ben商量将时间改为周二，Ben发给Dave的消息如下：</p> <div class="language-text extra-class"><pre class="language-text"><code>data = Tuesday 
vclock = Alice:1, Ben:1 
</code></pre></div><p>注意Ben这条消息保留了Alice的记录，同时加上了自己的记录。Ben：1代表这是Ben第一次修改的记录。接着Dave收到Ben的消息，并同意将时间改为周二，他回给Ben的消息如下：</p> <div class="language-text extra-class"><pre class="language-text"><code>data = Tuesday 
vclock = Alice:1, Ben:1, Dave:1 
</code></pre></div><p>这条消息同样保留了原来已有的vclock记录，同时加上了自己的记录。
另一方面，Catby收到Alice的消息，打算与Dave商量将时间改为周四，于是他发送如下消息给Dave：</p> <div class="language-text extra-class"><pre class="language-text"><code>data = Thursday     
vclock = Alice:1, Catby:1 
</code></pre></div><p>看到这里你可能会奇怪，为什么vclock中没有了之前的Ben和Dave的记录了？这是因为Ben和Dave商量的时候Catby并不知道这个情况。Catby手中的信息还是Alice最初发送的那份。这样当Dave收到来自Catby的消息时就发现有冲突了。Dave手中的两份信息如下：</p> <p>Dave通过比对两份消息的vclock可以发现冲突，这是因为上面两个版本的vclock都不是对方的“祖先”。其中vector clock对祖先的定义是这样的：对于vclock A和vclock B，当且仅当A中的每一个标记ID都存在于B中，同时A中对应的标记版本号要小于等于B时，vclockA才是vclockB的祖先。如果标记ID不存在，可以认为标记版本号为0。</p> <p>Dave通过对比vclock发现了版本冲突，于是尝试解决冲突。两个版本中只能选择一个，他选择了时间为周四的，那么这条消息可以表示为：</p> <div class="language-text extra-class"><pre class="language-text"><code>date = Thursday     
vclock = Alice:1, Ben:1, Catby:1, Dave:2 
</code></pre></div><p>Dave在vclock中加上了两个消息中的全部标记ID（Alice、Ben、Catby和Dave），同时将自己对应的版本号加1，然后将这条消息发送给Catby。</p> <p>最后，当Alice从Catby和Ben收集反馈消息时（此时Dave联系不上），收到如下消息。</p> <p>来自Ben的：</p> <div class="language-text extra-class"><pre class="language-text"><code>data = Thursday 
vclock = Alice:1, Ben:1, Dave:1 
</code></pre></div><p>来自Catby的：</p> <div class="language-text extra-class"><pre class="language-text"><code>data = Thursday     
vclock = Alice:1, Catby:1, Ben:1, Dave:2 
</code></pre></div><p>这时Alice从Catby的消息就可看出，Dave后来改变主意了。</p> <p>到这里，我们来介绍一些分布式环境下的与事务相关的算法和实践。从工程上来说，如果能够避免分布式事务的引入，那么还是避免为好；如果一定要引入分布式事务，那么，可以考虑最终一致的方法，而不要追求强一致。而且从实现上来说，我们是通过补偿的机制不断重试，让之前因为异常而没有进行到底的操作继续进行，而不是回滚。如果还不能满足需求，那么基于Paxos算法的实现会是一个不错的选择。</p> <h4 id="_5-1-4-多机的sequence问题与处理"><a href="#_5-1-4-多机的sequence问题与处理" class="header-anchor">#</a> 5.1.4 多机的Sequence问题与处理</h4></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/posts/dubbo.html" class="prev">
          深度剖析 Apache Dubbo 核心技术内幕
        </a></span> <span class="next"><a href="/posts/other/2FA.html">
          Github 2FA 验证
        </a></span></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/posts/Large-scale_website_system_and_Java_middleware_practice.html#第4章-服务框架" class="sidebar-link reco-side-第4章-服务框架" data-v-b57cc07c>第4章 服务框架</a></li><li class="level-3" data-v-b57cc07c><a href="/posts/Large-scale_website_system_and_Java_middleware_practice.html#_4-1-网站功能持续丰富后的困境与应对" class="sidebar-link reco-side-_4-1-网站功能持续丰富后的困境与应对" data-v-b57cc07c>4.1 网站功能持续丰富后的困境与应对</a></li><li class="level-3" data-v-b57cc07c><a href="/posts/Large-scale_website_system_and_Java_middleware_practice.html#_4-2-服务框架的设计与实现" class="sidebar-link reco-side-_4-2-服务框架的设计与实现" data-v-b57cc07c>4.2 服务框架的设计与实现</a></li><li class="level-3" data-v-b57cc07c><a href="/posts/Large-scale_website_system_and_Java_middleware_practice.html#_4-3-实战中的优化" class="sidebar-link reco-side-_4-3-实战中的优化" data-v-b57cc07c>4.3 实战中的优化</a></li><li class="level-3" data-v-b57cc07c><a href="/posts/Large-scale_website_system_and_Java_middleware_practice.html#_4-4-为服务化护航的服务治理" class="sidebar-link reco-side-_4-4-为服务化护航的服务治理" data-v-b57cc07c>4.4 为服务化护航的服务治理</a></li><li class="level-3" data-v-b57cc07c><a href="/posts/Large-scale_website_system_and_Java_middleware_practice.html#_4-5-服务框架与esb的对比" class="sidebar-link reco-side-_4-5-服务框架与esb的对比" data-v-b57cc07c>4.5 服务框架与ESB的对比</a></li><li class="level-3" data-v-b57cc07c><a href="/posts/Large-scale_website_system_and_Java_middleware_practice.html#_4-6-总结" class="sidebar-link reco-side-_4-6-总结" data-v-b57cc07c>4.6 总结</a></li><li class="level-2" data-v-b57cc07c><a href="/posts/Large-scale_website_system_and_Java_middleware_practice.html#第5章-数据访问层" class="sidebar-link reco-side-第5章-数据访问层" data-v-b57cc07c>第5章 数据访问层</a></li><li class="level-3" data-v-b57cc07c><a href="/posts/Large-scale_website_system_and_Java_middleware_practice.html#_5-1-数据库从单机到分布式的挑战和应对" class="sidebar-link reco-side-_5-1-数据库从单机到分布式的挑战和应对" data-v-b57cc07c>5.1 数据库从单机到分布式的挑战和应对</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.990df87d.js" defer></script><script src="/assets/js/7.491a51aa.js" defer></script><script src="/assets/js/2.e6a59b38.js" defer></script><script src="/assets/js/1.d6963574.js" defer></script><script src="/assets/js/15.56e70929.js" defer></script>
  </body>
</html>
